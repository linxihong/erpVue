{"version":3,"sources":["webpack:///static/js/2.9a5b3ca9fb1e9a0cb4a8.js","webpack:///./~/zrender/lib/mixin/Animatable.js?35cb","webpack:///./~/zrender/lib/mixin/Draggable.js?fbca","webpack:///./~/zrender/lib/tool/path.js?dc4b","webpack:///./~/zrender/lib/tool/transformPath.js?ddb2","webpack:///./~/echarts/lib/chart/bar/BarSeries.js?61cd","webpack:///./~/echarts/lib/chart/bar/BarView.js?20fc","webpack:///./~/echarts/lib/chart/bar/BaseBarSeries.js?72f5","webpack:///./~/echarts/lib/chart/bar/barItemStyle.js?15d9","webpack:///./~/echarts/lib/chart/bar/helper.js?25d2","webpack:///./~/echarts/lib/layout/barGrid.js?d23e","webpack:///./~/echarts/lib/component/helper/listComponent.js?566d","webpack:///./~/echarts/lib/component/legend/LegendModel.js?bbe7","webpack:///./~/echarts/lib/component/legend/LegendView.js?124f","webpack:///./~/echarts/lib/component/legend/legendAction.js?b7a9","webpack:///./~/echarts/lib/component/legend/legendFilter.js?93b2","webpack:///delivery_detail.vue","webpack:///sequence_chart.vue","webpack:///./src/page/erp_pc/erp_report/report_block/sequence_chart.vue?c539","webpack:///./src/page/erp_pc/erp_report/report_block/sequence_chart.vue?9448","webpack:///./src/page/erp_pc/erp_report/report_block/sequence_chart.vue","webpack:///./src/page/erp_pc/erp_report/delivery_detail.vue?d009","webpack:///./src/page/erp_pc/erp_report/report_block/sequence_chart.vue?ae1b","webpack:///./src/page/erp_pc/erp_report/delivery_detail.vue","webpack:///./~/zrender/lib/core/util.js?10f4","webpack:///./~/echarts/lib/util/graphic.js?e267","webpack:///./~/echarts/lib/echarts.js?68a2","webpack:///./~/echarts/lib/util/number.js?43e3","webpack:///./~/echarts/lib/util/model.js?e2bd","webpack:///./~/zrender/lib/core/vector.js?6654","webpack:///./~/zrender/lib/graphic/Path.js?c119","webpack:///./~/zrender/lib/core/env.js?9ccc","webpack:///./~/echarts/lib/config.js?2f63","webpack:///./~/zrender/lib/core/BoundingRect.js?76f6","webpack:///./~/echarts/lib/util/format.js?7f72","webpack:///./~/echarts/lib/model/Model.js?f4df","webpack:///./~/echarts/lib/util/clazz.js?3e66","webpack:///./~/echarts/lib/model/Component.js?0e02","webpack:///./~/zrender/lib/contain/text.js?3a43","webpack:///./~/echarts/lib/util/layout.js?2b1e","webpack:///./~/echarts/lib/coord/axisHelper.js?4730","webpack:///./~/zrender/lib/core/curve.js?9511","webpack:///./~/zrender/lib/core/matrix.js?97a2","webpack:///./~/zrender/lib/core/event.js?24ff","webpack:///./~/zrender/lib/mixin/Eventful.js?223b","webpack:///./~/zrender/lib/tool/color.js?284f","webpack:///./~/echarts/lib/component/axisPointer/modelHelper.js?ba01","webpack:///./~/echarts/lib/data/List.js?b096","webpack:///./~/echarts/lib/scale/Scale.js?c922","webpack:///./~/zrender/lib/config.js?2861","webpack:///./~/zrender/lib/container/Group.js?8d57","webpack:///./~/zrender/lib/core/PathProxy.js?69e9","webpack:///./~/echarts/lib/model/mixin/makeStyleMapper.js?e2b1","webpack:///./~/echarts/lib/model/Series.js?186c","webpack:///./~/echarts/lib/view/Chart.js?72f3","webpack:///./~/echarts/lib/CoordinateSystem.js?2b30","webpack:///./~/echarts/lib/scale/Interval.js?08e9","webpack:///./~/echarts/lib/util/component.js?cc72","webpack:///./~/echarts/lib/util/symbol.js?be2c","webpack:///./~/echarts/lib/util/throttle.js?56b3","webpack:///./~/zrender/lib/core/timsort.js?0a74","webpack:///./~/zrender/lib/graphic/Displayable.js?5c45","webpack:///./~/zrender/lib/graphic/Gradient.js?5165","webpack:///./~/zrender/lib/graphic/helper/image.js?8535","webpack:///./~/echarts/lib/component/tooltip.js?b491","webpack:///./~/echarts/lib/data/helper/completeDimensions.js?9c9e","webpack:///./~/echarts/lib/chart/helper/createListFromArray.js?e3fc","webpack:///./~/echarts/lib/chart/bar.js?931c","webpack:///./~/echarts/lib/component/axisPointer/findPointFromSeries.js?2189","webpack:///./~/echarts/lib/component/axisPointer/globalListener.js?00cf","webpack:///./~/echarts/lib/component/axisPointer/viewHelper.js?35c0","webpack:///./~/echarts/lib/component/axis/AxisBuilder.js?6417","webpack:///./~/echarts/lib/component/axis/AxisView.js?f854","webpack:///./~/echarts/lib/component/axis/cartesianAxisHelper.js?ce88","webpack:///./~/echarts/lib/coord/Axis.js?736c","webpack:///./~/echarts/lib/coord/axisModelCommonMixin.js?a8d0","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js?0573","webpack:///./~/echarts/lib/model/mixin/colorPalette.js?b454","webpack:///./~/echarts/lib/scale/helper.js?370b","webpack:///./~/zrender/lib/Element.js?325b","webpack:///./~/zrender/lib/animation/Animator.js?d2b9","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js?6d88","webpack:///./~/zrender/lib/contain/util.js?0031","webpack:///./~/zrender/lib/contain/windingLine.js?625a","webpack:///./~/zrender/lib/core/LRU.js?018e","webpack:///./~/zrender/lib/core/bbox.js?1b56","webpack:///./~/zrender/lib/core/guid.js?f0e4","webpack:///./~/zrender/lib/core/log.js?26a2","webpack:///./~/zrender/lib/graphic/Image.js?bf1b","webpack:///./~/zrender/lib/graphic/Pattern.js?a97e","webpack:///./~/zrender/lib/graphic/Style.js?22d9","webpack:///./~/zrender/lib/graphic/helper/poly.js?788c","webpack:///./~/zrender/lib/graphic/helper/roundRect.js?418d","webpack:///./~/zrender/lib/graphic/helper/text.js?069c","webpack:///./~/zrender/lib/mixin/Transformable.js?f61b","webpack:///./~/zrender/lib/zrender.js?5dcd","webpack:///./~/echarts/lib/component/legend.js?d893","webpack:///./~/echarts/lib/coord/cartesian/Grid.js?f167","webpack:///./~/zrender/lib/graphic/helper/fixClipWithShadow.js?92a4","webpack:///./~/echarts/lib/component/gridSimple.js?eec5","webpack:///ZLCommonSearch.vue","webpack:///ZLCommonTable.vue","webpack:///./src/components/ZLCommonSearch.vue?9973","webpack:///./~/echarts/lib/ExtensionAPI.js?e283","webpack:///./~/echarts/lib/component/axis.js?8a87","webpack:///./~/echarts/lib/component/axisPointer.js?110d","webpack:///./~/echarts/lib/component/axisPointer/AxisPointerModel.js?e99a","webpack:///./~/echarts/lib/component/axisPointer/AxisPointerView.js?4293","webpack:///./~/echarts/lib/component/axisPointer/BaseAxisPointer.js?027a","webpack:///./~/echarts/lib/component/axisPointer/CartesianAxisPointer.js?ab1e","webpack:///./~/echarts/lib/component/axisPointer/axisTrigger.js?86e8","webpack:///./~/echarts/lib/component/axis/CartesianAxisView.js?076a","webpack:///./~/echarts/lib/component/tooltip/TooltipContent.js?2c54","webpack:///./~/echarts/lib/component/tooltip/TooltipModel.js?19ac","webpack:///./~/echarts/lib/component/tooltip/TooltipView.js?ae52","webpack:///./~/echarts/lib/coord/axisDefault.js?4492","webpack:///./~/echarts/lib/coord/axisModelCreator.js?34e4","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js?9345","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js?9246","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js?103b","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js?1817","webpack:///./~/echarts/lib/coord/geo/Region.js?fc66","webpack:///./~/echarts/lib/coord/geo/parseGeoJson.js?edf7","webpack:///./~/echarts/lib/data/DataDiffer.js?f330","webpack:///./~/echarts/lib/export.js?1f28","webpack:///./~/echarts/lib/helper.js?5794","webpack:///./~/echarts/lib/loading/default.js?8a5f","webpack:///./~/echarts/lib/model/Global.js?b9d3","webpack:///./~/echarts/lib/model/OptionManager.js?a7a5","webpack:///./~/echarts/lib/model/globalDefault.js?fd54","webpack:///./~/echarts/lib/model/mixin/areaStyle.js?4e41","webpack:///./~/echarts/lib/model/mixin/boxLayout.js?92d7","webpack:///./~/echarts/lib/model/mixin/itemStyle.js?9011","webpack:///./~/echarts/lib/model/mixin/lineStyle.js?3579","webpack:///./~/echarts/lib/model/mixin/textStyle.js?e4c8","webpack:///./~/echarts/lib/preprocessor/backwardCompat.js?f171","webpack:///./~/echarts/lib/preprocessor/helper/compatStyle.js?aff6","webpack:///./~/echarts/lib/scale/Log.js?0ad0","webpack:///./~/echarts/lib/scale/Ordinal.js?3a6b","webpack:///./~/echarts/lib/scale/Time.js?6fdf","webpack:///./~/echarts/lib/view/Component.js?415a","webpack:///./~/echarts/lib/visual/seriesColor.js?4b6a","webpack:///./src/components/ZLCommonSearch.vue?165f","webpack:///./src/components/ZLCommonSearch.vue?78e9","webpack:///./src/components/ZLCommonTable.vue?95fb","webpack:///./src/components/ZLCommonSearch.vue?022c","webpack:///./src/components/ZLCommonTable.vue?48b9","webpack:///./~/zrender/lib/Handler.js?fbeb","webpack:///./~/zrender/lib/Layer.js?f586","webpack:///./~/zrender/lib/Painter.js?ee99","webpack:///./~/zrender/lib/Storage.js?7e93","webpack:///./~/zrender/lib/animation/Animation.js?8743","webpack:///./~/zrender/lib/animation/Clip.js?fef9","webpack:///./~/zrender/lib/animation/easing.js?64b6","webpack:///./~/zrender/lib/contain/arc.js?7367","webpack:///./~/zrender/lib/contain/cubic.js?b90e","webpack:///./~/zrender/lib/contain/line.js?4326","webpack:///./~/zrender/lib/contain/path.js?2e7f","webpack:///./~/zrender/lib/contain/polygon.js?1f9f","webpack:///./~/zrender/lib/contain/quadratic.js?f589","webpack:///./~/zrender/lib/core/GestureMgr.js?00fd","webpack:///./~/zrender/lib/dom/HandlerProxy.js?2fc7","webpack:///./~/zrender/lib/graphic/CompoundPath.js?8636","webpack:///./~/zrender/lib/graphic/LinearGradient.js?4250","webpack:///./~/zrender/lib/graphic/RadialGradient.js?895e","webpack:///./~/zrender/lib/graphic/Text.js?3244","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js?2713","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js?a17c","webpack:///./~/zrender/lib/graphic/mixin/RectText.js?94ea","webpack:///./~/zrender/lib/graphic/shape/Arc.js?2994","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js?f5c4","webpack:///./~/zrender/lib/graphic/shape/Circle.js?076e","webpack:///./~/zrender/lib/graphic/shape/Line.js?7728","webpack:///./~/zrender/lib/graphic/shape/Polygon.js?d37d","webpack:///./~/zrender/lib/graphic/shape/Polyline.js?3cdb","webpack:///./~/zrender/lib/graphic/shape/Rect.js?3b3d","webpack:///./~/zrender/lib/graphic/shape/Ring.js?b71c","webpack:///./~/zrender/lib/graphic/shape/Sector.js?9767"],"names":["webpackJsonp","1000","module","exports","__webpack_require__","Animator","log","_util","isString","isFunction","isObject","isArrayLike","indexOf","Animatable","this","animators","prototype","constructor","animate","path","loop","target","animatingShape","el","zr","__zr","pathSplitted","split","prop","i","l","length","id","animator","during","dirty","done","splice","push","animation","addAnimator","stopAnimation","forwardToLast","len","stop","animateTo","time","delay","easing","callback","forceAnimate","count","_animateToShallow","slice","start","source","objShallow","propertyCount","name","hasOwnProperty","props","attr","when","_default","1001","Draggable","on","_dragStart","_drag","_dragEnd","param","e","topTarget","draggingTarget","draggable","_draggingTarget","dragging","_x","offsetX","_y","offsetY","dispatchToElement","event","x","y","dx","dy","drift","dropTarget","findHover","lastDropTarget","_dropTarget","1002","processArc","x1","y1","x2","y2","fa","fs","rx","ry","psiDeg","cmd","psi","PI","xp","mathCos","mathSin","yp","lambda","mathSqrt","f","cxp","cyp","cx","cy","theta","vAngle","u","v","dTheta","vRatio","addData","createPathProxyFromString","data","n","cs","replace","cc","RegExp","prevCmd","arr","cpx","cpy","PathProxy","CMD","str","c","charAt","off","p","shift","parseFloat","isNaN","ctlPtx","ctlPty","L","M","C","pathData","Q","A","Z","toStatic","createPathOptions","opts","pathProxy","buildPath","setData","ctx","getContext","rebuildPath","applyTransform","m","transformPath","createFromString","Path","extendFromString","extend","mergePath","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","shape","pathBundle","appendPath","Math","sqrt","sin","cos","vMag","acos","1003","nPoint","j","k","R","sx","sy","angle","mathAtan2","v2ApplyTransform","points","_vector","atan2","1005","BaseBarSeries","type","dependencies","brushSelector","1006","removeRect","dataIndex","animationModel","style","text","graphic","updateProps","width","parent","remove","removeSector","r","r0","updateStyle","itemModel","layout","seriesModel","isHorizontal","isPolar","color","getItemVisual","opacity","itemStyleModel","getModel","hoverStyle","getBarItemStyle","setShape","get","useStyle","zrUtil","defaults","fill","cursorStyle","getShallow","labelPositionOutside","height","setLabel","setHoverStyle","getLineWidth","rawLayout","lineWidth","BAR_BORDER_WIDTH_QUERY","min","abs","_config","echarts","__DEV__","_helper","Model","barItemStyle","extendChartView","render","ecModel","api","coordinateSystemType","_render","group","dispose","noop","isHorizontalOrRadial","getData","oldData","_data","coord","coordinateSystem","baseAxis","getBaseAxis","dim","isAnimationEnabled","diff","add","hasValue","getItemModel","getLayout","elementCreator","setItemGraphicEl","update","newIndex","oldIndex","getItemGraphicEl","execute","eachItemGraphicEl","removeAll","cartesian2d","isUpdate","rect","Rect","rectShape","animateProperty","animateTarget","polar","isRadial","sector","Sector","sectorShape","startAngle","getItemLayout","fixedLineWidth","signX","signY","endAngle","1007","SeriesModel","createListFromArray","getInitialData","option","getMarkerPosition","value","coordSys","pt","dataToPoint","offset","size","NaN","defaultOption","zlevel","z","legendHoverLink","barMinHeight","barMinAngle","itemStyle","1008","makeStyleMapper","excludes","getBorderLineDash","lineDash","1009","normalStyle","labelModel","hoverLabelModel","setLabelStyle","labelFetcher","labelDataIndex","defaultText","getRawValue","isRectText","autoColor","fixPosition","textPosition","1016","getSeriesStackId","STACK_PREFIX","seriesIndex","getAxisKey","axis","index","getLayoutOnAxis","opt","params","bandWidth","getBandWidth","axisKey","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","calBarWidthAndOffset","barSeries","map","cartesian","axisExtent","getExtent","barWidth","parsePercent","barMaxWidth","barGap","barCategoryGap","seriesInfoList","columnsMap","each","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","coordSysName","barGapPercent","autoWidth","max","column","stack","lastColumn","widthSum","barLayoutGrid","seriesType","barWidthAndOffset","filter","getSeriesByType","isSeriesFiltered","lastStackCoords","lastStackCoordsOrigin","eachSeriesByType","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","valueAxisStart","onZero","toGlobalCoord","dataToCoord","getGlobalExtent","coordDims","coordDimToDataDim","coords","mapArray","setLayout","sign","lastCoord","lastCoordOrigin","setItemLayout","_number","1041","componentModel","boxLayoutParams","getBoxLayoutParams","padding","viewportSize","getWidth","getHeight","getLayoutRect","layoutBox","positionElement","makeBackground","formatUtil","normalizeCssArray","getItemStyle","silent","z2","_layout","box","1042","LegendModel","extendComponentModel","layoutMode","ignoreSize","init","parentModel","mergeDefaultAndTheme","selected","mergeOption","superCall","optionUpdated","_updateData","legendData","hasSelected","isSelected","select","dataItem","availableNames","getSeries","series","eachSeries","legendDataProvider","concat","getName","_availableNames","unSelect","toggleSelected","show","orient","left","top","align","backgroundColor","borderColor","borderRadius","borderWidth","itemGap","itemWidth","itemHeight","inactiveColor","textStyle","selectedMode","tooltip","1043","dispatchSelectAction","dispatchAction","dispatchHighlightAction","dataName","getZr","storage","getDisplayList","useHoverLayer","seriesName","dispatchDownplayAction","_symbol","createSymbol","_listComponent","layoutUtil","curry","Group","extendComponentView","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","maxSize","mainRect","layoutInner","layoutRect","contentGroup","legendDrawnMap","createHashMap","selectMode","newline","getSeriesByName","getVisual","getDataParams","legendSymbolType","symbolType","itemGroup","_createItem","set","eachRawSeries","indexOfName","textStyleModel","itemIcon","tooltipModel","legendGlobalTooltipModel","textX","textAlign","formatter","content","Text","setTextStyle","textFill","getTextColor","textVerticalAlign","hitRect","getBoundingRect","invisible","formatterParams","componentType","legendIndex","componentIndex","$vars","eachChild","child","__legendDataIndex","contentRect","1044","legendSelectActionHandler","methodName","payload","selectedMap","isToggleSelect","eachComponent","model","isItemSelected","registerAction","1045","legendModels","findComponents","mainType","filterSeries","1227","__webpack_exports__","Object","defineProperty","__WEBPACK_IMPORTED_MODULE_0__components_ZLCommonSearch__","__WEBPACK_IMPORTED_MODULE_0__components_ZLCommonSearch___default","__WEBPACK_IMPORTED_MODULE_1__components_ZLCommonTable__","__WEBPACK_IMPORTED_MODULE_1__components_ZLCommonTable___default","__WEBPACK_IMPORTED_MODULE_2__report_block_sequence_chart__","__WEBPACK_IMPORTED_MODULE_2__report_block_sequence_chart___default","_this","tabHeight","isLoading","deliveryData","searchFields","fieldName","label","recentDate","itemValues","widthI","buttons","arrowBot","arrowTop","searchVisible","formHeight","detailVisible","dialogW","dialog_top","components","ZLCommonSearch","a","ZLCommonTable","sequence_chart","mounted","_this2","setTimeout","getDivHeight","methods","getlist","pageHeight","$refs","offsetHeight","btnHeight","$store","state","toggleSearch","_this3","initials","search","cPage","_this4","getAjax","cSize","then","status","list","forEach","contracttype","contracttypename","cTotal","total","$message","message","showDetail","rows","_this5","$nextTick","sequence","initEchart","sendnum","1237","sendObj","producecommandtime","makematerialtime","qualitychecktime","targetbuildsitetime","buildsiteoffloadtime","targetstarttime","fetch","setCustomChart","obj","lastII","lastIII","lastIV","lastV","lastVI","myChart","setOption","grid","xAxis","axisLine","symbol","yAxis","axisTick","splitLine","nameLocation","nameTextStyle","fontWeight","fontSize","axisLabel","normal","barBorderColor","emphasis","position","1371","version","sources","names","mappings","file","sourcesContent","sourceRoot","1502","locals","1559","injectStyle","ssrContext","Component","1683","_vm","_h","$createElement","_c","_self","ref","staticClass","attrs","_v","title","click","_e","directives","rawName","expression","fields","searchII","tableData","detail","current-page","page-sizes","cpageSizes","page-size","size-change","handleSizeChange","current-change","handleCurrentChange","show-close","visible","modal","update:visible","$event","staticRenderFns","1716","_m","_s","769","794","$override","fn","clone","typeStr","objToString","call","TYPED_ARRAY","Ctor","from","BUILTIN_OBJECT","isPrimitive","isDom","key","merge","overwrite","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","overlay","_ctx","createCanvas","array","inherits","clazz","baseClazz","F","clazzPrototype","superClass","mixin","cb","context","nativeForEach","nativeMap","reduce","memo","nativeReduce","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","Function","val","assert","condition","Error","setAsPrimitive","primitiveKey","HashMap","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","toString","arrayProto","Array","document","createElement","prefixedKey","removeKey","808","extendShape","extendPath","pathTool","makePath","boundingRect","centerGraphic","resizePath","makeImage","imageUrl","Image","image","onload","img","setStyle","aspect","pathRect","calculateTransform","subPixelOptimizeLine","round","subPixelOptimize","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","hasFillOrStroke","fillOrStroke","liftColor","colorTool","lift","cacheElementStl","__hoverStlDirty","stroke","__hoverStl","__normalStl","doSingleEnterHover","__isHover","addHover","insideRollbackOpt","rollbackInsideStyle","extendFrom","applyInsideStyle","insideOriginalTextPosition","doSingleLeaveHover","normalStl","removeHover","doEnterHover","traverse","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","hoverSilentOnTouch","emphasisStyle","normalModel","emphasisModel","normalSpecified","emphasisSpecified","EMPTY_OBJ","labelDimIndex","showNormal","showEmphasis","baseText","getFormattedLabel","normalStyleText","emphasisStyleText","specifiedTextStyle","isEmphasis","setTextStyleCommon","host","setText","defaultColor","textOffset","labelRotate","textRotation","textDistance","richResult","globalTextStyle","richItemNames","getRichItemNames","richTextStyle","setTokenTextStyle","rich","forceRich","richItemNameMap","isBlock","getAutoColor","textStroke","textBorderColor","textStrokeWidth","textBorderWidth","originalTextPosition","insideRollback","fontStyle","fontFamily","textLineHeight","textWidth","textHeight","textTag","disableBox","textBackgroundColor","textPadding","textBorderRadius","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","useInsideStyle","getFont","gTextStyleModel","join","animateOrSetProps","animatableModel","postfix","duration","animationEasing","animationDelay","getAnimationDelayParams","initProps","getTransform","ancestor","mat","matrix","identity","mul","getLocalTransform","transform","invert","Transformable","vector","transformDirection","direction","hBase","vBase","vertex","groupTransition","g1","g2","getAnimatableProps","rotation","elMap1","g","elMap","isGroup","anid","oldEl","newProp","clipPointsByRect","point","mathMax","mathMin","clipRectByRect","targetRect","createIcon","iconStr","rectHover","strokeNoScale","Circle","Ring","Polygon","Polyline","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","809","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","prioritySortFunc","b","prio","themeStorage","_dom","_zr","zrender","renderer","devicePixelRatio","_throttledZrFlush","throttle","flush","backwardCompat","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_coordSysMgr","CoordinateSystemManager","_api","createExtensionAPI","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","_onframe","doConvertPixel","finder","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","updateDirectly","ecIns","subType","callView","view","__alive","__model","query","__viewId","doDispatchAction","payloadType","escapeConnect","actionWrap","actions","actionInfo","cptType","updateMethod","pop","parseClassType","IN_MAIN_PROCESS","payloads","batched","batch","eventObj","eventObjBatch","isHighDown","batchItem","action","main","sub","OPTION_UPDATED","updateMethods","prepareAndUpdate","trigger","flushPendingActions","pendingActions","triggerUpdatedEvent","invokeUpdateMethod","component","updateZ","chart","updateProgressiveAndBlend","updateHoverLayerStatus","postUpdateFuncs","prepareView","isComponent","viewList","viewMap","viewId","classType","Clazz","ComponentView","getClass","ChartView","__id","__ecComponentInfo","processData","process","stackSeriesData","stackedDataMap","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","excludesLayout","clearColorPalette","doRender","componentView","chartView","elCount","env","node","ignore","frameDrawNum","needProgressive","progressive","floor","blendMode","ecInstance","coordSysMgr","ExtensionAPI","getComponentByElement","modelInfo","getComponent","enableConnect","updateConnectedChartsStatus","charts","STATUS_KEY","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","otherChart","existInstance","getInstanceByDom","idBase","setAttribute","DOM_ATTRIBUTE_KEY","connect","groupId","groupIdBase","disConnect","isDisposed","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","optionPreprocessorFuncs","registerProcessor","priority","processorFunc","PRIORITY_PROCESSOR_FILTER","registerPostUpdate","postUpdateFunc","ACTION_REG","test","registerCoordinateSystem","CoordinateSystem","register","getCoordinateSystemDimensions","coordSysCreator","getDimensionsInfo","dimensions","registerLayout","layoutFunc","PRIORITY_VISUAL_LAYOUT","registerVisual","visualFunc","PRIORITY_VISUAL_CHART","registerLoading","loadingFx","loadingEffects","ComponentModel","extendSeriesModel","setCanvasCreator","creator","registerMap","mapName","geoJson","specialAreas","features","JSON","parse","mapDataStores","getMap","GlobalModel","OptionManager","_throttle","seriesColor","loadingDefault","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","one","echartsProto","getDom","notMerge","lazyUpdate","optionManager","setTheme","console","getOption","getDevicePixelRatio","painter","dpr","window","getRenderedCanvas","canvasSupported","pixelRatio","getSvgDataUrl","svgSupported","pathToSvg","getDataURL","excludeComponents","excludesComponentViews","self","url","getType","toDataURL","getConnectedDataURL","Infinity","right","bottom","canvasList","canvas","getBoundingClientRect","targetCanvas","refreshImmediately","convertToPixel","convertFromPixel","containPixel","models","containPoint","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","getViewOfComponentModel","getViewOfSeriesModel","restoreData","create","isSingleCanvas","configLayer","clearColor","colorArr","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","optionChanged","resetOption","_loadingFX","showLoading","cfg","hideLoading","browser","weChat","MOUSE_EVENT_NAMES","eveName","dataModel","getSeriesByIndex","dataType","eventData","_disposed","clear","Date","disconnect","dataTool","___ec_export","810","_trim","linearMap","domain","range","clamp","subDomain","subRange","percent","all","match","precision","returnStr","toFixed","asc","sort","getPrecision","getPrecisionSafe","eIndex","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","isFinite","getPercentWithPrecision","valueList","sum","acc","digits","pow","votesPerQuota","targetSeats","seats","votes","currentSum","remainder","Number","NEGATIVE_INFINITY","maxId","remRadian","radian","pi2","isRadianAroundZero","RADIAN_EPSILON","parseDate","TIME_REG","exec","hour","toUpperCase","UTC","quantity","quantityExponent","nice","nf","exponent","exp10","reformIntervals","littleThan","lg","interval","close","curr","currClose","isNumeric","MAX_SAFE_INTEGER","811","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","normalOpt","subOptName","getDataItemValue","isDataItemOption","converDataValue","dimInfo","dimType","nubmerUtil","createDataFormatModel","dataFormatMixin","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","existCpt","keyInfo","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","seriesId","dataIndices","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","has","parsedKey","queryType","includeMainTypes","queryParam","queryComponents","dataDimToCoordDim","dataDim","getDimension","dimItem","getDimensionInfo","coordDim","dimName","coordDimIndex","otherDimToDataDim","otherDim","otherDims","dimIndex","TEXT_STYLE_OPTIONS","rawValue","rawDataIndex","getRawIndex","itemOpt","getRawDataItem","componentSubType","marker","getTooltipMarker","labelProp","formatTpl","formatTooltip","makeGetter","hostObj","812","out","ArrayCtor","copy","v1","v2","scaleAndAdd","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","Float32Array","lengthSquare","dist","distSquare","813","Displayable","pathContain","Pattern","getCanvasPattern","pathProxyForDraw","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirtyPath","refresh","__clipTarget","animateShape","attrKV","Sub","defaultShape","thisShape","819","navigator","os","ua","firefox","ie","edge","SVGRect","touchEventsSupported","pointerEventsSupported","userAgent","820","global","dev","821","vec2","union","other","lt","rb","lb","rt","maxX","maxY","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","822","addCommas","toCamelCase","upperCaseFirst","group1","encodeHTML","String","tpl","paramsList","encode","seriesLen","alias","TPL_VAR_ALIAS","wrapVar","seriesIdx","formatTplSimple","extraCssText","formatTime","isUTC","date","numberUtil","utc","h","s2d","capitalFirst","substr","textContain","varName","truncateText","getTextRect","823","doGet","pathArr","getParent","getParentMethod","clazzUtil","lineStyleMixin","areaStyleMixin","textStyleMixin","itemStyleMixin","ignoreParent","parsePath","thisParentModel","isEmpty","setReadOnly","properties","customizeGetParent","enableClassExtend","824","MEMBER_PRIFIX","hasOwn","ret","TYPE_DELIMITER","checkClassType","RootClass","mandatoryMethods","$constructor","proto","ExtendedClass","superApply","enableClassManagement","entity","options","makeContainer","container","IS_CONTAINER","registerClass","componentMainType","throwWhenNotFound","getClassesByMainType","o","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","838","getDependencies","deps","arrayPush","componentUtil","boxLayoutMixin","dependentModels","uid","extraOpt","getUID","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","newCptOption","isInit","optList","Class","getReferringComponents","enableSubTypeDefaulter","enableTopologicalTravel","844","font","DEFAULT_FONT","textWidthCache","textLines","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","adjustTextX","adjustTextY","lineHeight","parseRichText","adjustTextPositionOnRect","halfHeight","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","lines","truncOuterHeight","truncOuterWidth","lastIndex","STYLE_REG","matchedIndex","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","imageHelper","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","textFont","845","boxLayout","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","childAt","nextChildRect","moveX","moveY","getAvailableSize","containerRect","margin","containerHeight","verticalMargin","horizontalMargin","hv","boundingMode","needLocalTransform","elPos","sizeCalculable","hvIdx","HV_NAMES","targetOption","newOption","newParams","newValueCount","merged","mergedValueCount","hasProp","hResult","vResult","copyLayoutParams","LOCATION_PARAMS","vbox","hbox","846","getScaleExtent","axisDataLen","boundaryGap","span","scaleType","getMin","getMax","fixMin","fixMax","originalExtent","setBlank","getNeedCrossZero","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","maxInterval","setInterval","createScaleByModel","axisType","OrdinalScale","getCategories","IntervalScale","Scale","ifAxisCrossZero","getAxisLabelInterval","tickCoords","labels","axisRotate","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tick","getAxisRawValue","getLabel","847","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","B","t1","disc","K","t2","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","tmp","THREE_SQRT","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","848","m1","m2","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","851","clientToLocal","calculate","defaultGetZrXY","layerX","zrX","zrY","layerY","clientX","clientY","normalizeEvent","touch","targetTouches","changedTouches","zrDelta","wheelDelta","button","which","undefined","MOUSE_EVENT_REG","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","notLeftMouse","Dispatcher","preventDefault","stopPropagation","cancelBubble","returnValue","852","arrySlice","_$handlers","isSilent","newList","argLen","triggerWithContext","853","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","G","vMin","vMax","delta","deltaR","deltaG","deltaB","level","toHex","fastLerp","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","854","collect","axesInfo","seriesInvolved","coordSysAxesInfo","coordSysMap","collectAxesInfo","collectSeriesInfo","globalTooltipModel","globalAxisPointerModel","linksOption","linkGroups","saveTooltipAxisInfo","fromTooltip","triggerTooltip","axisPointerModel","axisPointerShow","isHandleTrigger","makeAxisPointerModel","baseTooltipModel","snap","makeKey","involveSeries","axisInfo","useHandle","seriesModels","axesInfoInCoordSys","groupIndex","getLinkGroupIndex","linkGroup","mapper","axisPointerEnabled","coordSysKey","coordSysModel","getAxes","getTooltipAxes","triggerAxis","cross","tooltipAxes","baseAxes","otherAxes","tooltipAxisPointerModel","volatileOption","field","labelOption","crossStyle","lineStyle","seriesTooltipTrigger","seriesTooltipShow","getAxis","seriesDataCount","axisModel","linkOption","checkPropInLink","linkPropValue","axisPropValue","fixValue","getAxisInfo","reverse","isBlank","getAxisPointerModel","855","transferProperties","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","DefaultDataProvider","dataArray","_array","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","List","hostModel","_storage","originalStorage","dimStore","DataDiffer","globalObj","dataCtors","float","Float64Array","int","Int32Array","ordinal","number","pure","getItem","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","initData","nameList","dimValueGetter","nameDimIdx","dimensionInfoMap","idList","nameRepeatCount","itemName","DataCtor","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","rawIndex","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","MAX_VALUE","minDiff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setVisual","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","856","setting","_setting","_interval","getSetting","unionExtent","unionExtentFromData","end","thisExtent","_isBlank","857","debugMode","858","Element","_children","__storage","children","childOfName","childCount","_doAdd","addBefore","nextSibling","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","childRect","859","curve","bbox","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_len","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","anticlockwise","arcTo","radius","closePath","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","860","includes","868","_format","_clazz","colorPaletteMixin","visualColorAccessPath","themeSubType","fillDataTextStyle","newSeriesOption","getLinkedData","getRawData","multipleSeries","formattedValue","setEachItem","dimIdx","valStr","vertially","tooltipName","tooltipDims","colorEl","animationEnabled","getColorFromPalette","scope","getAxisTooltipData","getTooltipPosition","869","Chart","elSetState","toggleHighlight","dataIdx","highlight","downplay","chartProto","872","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","873","helper","roundNumber","_intervalPrecision","getInterval","_niceExtent","getIntervalPrecision","intervalScaleGetTicks","niceTicks","intervalScaleNiceTicks","intervalPrecision","niceTickExtent","expandSize","874","random","DELIMITER","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","componentTypeMain","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","875","symbolPathSetColor","innerColor","symbolStyle","symbolShape","__isEmptyBrush","keepAspect","symbolPath","SymbolClz","setColor","Triangle","Diamond","Pin","asin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","beforeBrush","proxySymbol","876","debounce","lastExec","getTime","timer","currCall","debounceNextCall","lastCall","thisDelay","thisDebounce","clearTimeout","debounceDelay","createOrUpdate","fnAttr","throttleType","originFn","ORIGIN_METHOD","lastThrottleType","THROTTLE_TYPE","RATE","877","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","remaining","ts","minRun","force","878","Style","__clipPaths","RectText","culling","cursor","afterBrush","rectContain","animateStyle","879","Gradient","addColorStop","880","newImageOrSrc","cachedImgObj","globalImageCache","createOrUpdateImage","hostEl","cbPayload","__zrImageSrc","pendingWrap","pending","imageOnLoad","__cachedImgObj","src","881","882","completeDimensions","sysDims","applyDim","resultItem","OTHER_DIMS","coordDimNameMap","genName","fromZero","dimsDef","encodeDef","dataDimNameMap","dimCount","retrieveValue","sysDimItem","sysDimItemDimsDef","dimDefItem","userDimName","dataDims","resultDimIdx","availDimIdx","sysDimIndex","sysDimItemOtherDims","extra","extraPrefix","extraFromZero","isExtraCoord","guessOrdinal","883","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","creators","registeredCoordSys","completeDimOpt","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","884","885","886","records","initGlobalListeners","useHandler","dis","makeDispatchAction","record","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","currTrigger","unregister","887","buildElStyle","axisPointerType","styleModel","getLineStyle","getAreaStyle","buildLabelElOption","elOption","labelPos","getValueLabel","paddings","textRect","verticalAlign","confineInContainer","bgColor","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","viewWidth","viewHeight","seriesDataIndices","axisHelper","seriesData","idxItem","dataParams","getTransformedPosition","layoutInfo","labelOffset","labelDirection","labelMargin","buildCartesianSingleLabelElOption","textLayout","AxisBuilder","innerTextLayout","makeLineShape","xDimIndex","makeRectShape","xy","wh","makeSectorShape","clockwise","888","makeAxisEventDataBase","endTextLayout","textRotate","rotationDiff","inverse","onLeft","tooltipOpt","fixMinMaxLabelShow","labelEls","tickEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","current","labelLayout","firstRect","nextRect","mRotationBack","matrixUtil","isNameLocationCenter","buildAxisTick","axisBuilder","tickModel","lineStyleModel","tickLen","tickInterval","labelInterval","ticksCoords","getTicksCoords","pt1","pt2","_transform","ticksCnt","ifIgnoreOnTick","tickDirection","tickEl","buildAxisLabel","axisLabelShow","labelRotation","categoryData","triggerEvent","tickVal","itemLabelModel","textColor","pos","labelStr","textEl","targetType","_dumbGroup","updateTransform","decomposeTransform","nameDirection","dumbGroup","hasBuilder","builders","getGroup","lineCap","arrows","arrowSize","symbolWidth","symbolHeight","axisTickLabel","axisName","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","nameTruncateMaxWidth","truncatedText","__fullText","__truncatedText","axisRotation","rawTick","889","updateAxisPointer","axisView","forceRender","AxisView","getAxisPointerClass","axisPointerClass","axisPointerModelHelper","_axisPointer","disposeAxisPointer","axisPointer","axisPointerClazz","registerAxisPointerClass","890","gridModel","rawAxisPosition","axisPosition","axisDim","getRect","rectBound","axisOffset","posBound","otherAxis","onZeroAxisIndex","onZeroCoord","dirMap","labelInside","getLabelInterval","891","fixExtentWithBands","nTick","normalizedExtent","Axis","onBand","_labelInterval","containData","coordToData","pointToData","alignWithLabel","bands","getBands","getLabelsCoords","getRotate","892","origin","rangeStart","rangeEnd","getCoordSysModel","setRange","resetRange","893","getAxisType","axisModelCreator","axisModelCommonMixin","AxisModel","gridIndex","gridId","extraOption","894","colorIdx","colorNameMap","colorPalette","895","fixExtent","896","guid","clipPath","beforeUpdate","afterUpdate","hide","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","removeAnimator","897","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","getArrayDim","keyframes","lastValue","createTrackClip","oneTrackDone","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","898","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","899","normalizeRadian","PI2","900","windingLine","dir","901","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","902","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","extremity","903","idStart","904","905","ZImage","_image","sWidth","sHeight","drawImage","906","repeat","createPattern","907","createLinearGradient","createRadialGradient","STYLE_COMMON_PROPS","transformText","textOrigin","blend","prevStyle","firstDraw","globalAlpha","globalCompositeOperation","otherStyle","newStyle","canvasGradient","styleProto","908","smooth","controlPoints","smoothBezier","smoothConstraint","cp1","cp2","smoothSpline","909","r1","r2","r3","r4","910","normalizeTextStyle","normalizeStyle","VALID_TEXT_ALIGN","textBaseline","VALID_TEXT_VERTICAL_ALIGN","renderText","renderRichText","renderPlainText","setCtx","__textCotentBlock","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","textY","needDrawBg","needDrawBackground","boxX","drawBackground","getTextXForPadding","getStroke","getFill","strokeText","fillText","drawRichText","xLeft","lineTop","xRight","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","isPlainBg","roundRectHelper","onBgImageLoaded","blockHeiht","maxValue","lastIndexOf","needDrawText","center","middle","911","mIdentity","transformableProto","parentHasTransform","invTransform","tmpTransform","transformCoordToGlobal","912","ZRender","getInstance","registerPainter","painterCtors","delInstance","Handler","Storage","Painter","Animation","HandlerProxy","useVML","rendererType","vml","handerProxy","getViewportRoot","root","stage","_needsRefresh","oldDelFromStorage","oldAddToStorage","addRoot","delRoot","zLevel","config","_needsRefreshHover","refreshHoverImmediately","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","eventHandler","914","legendFilter","915","isAxisUsedInTheGrid","rotateTextRect","rotateRadians","boundingBox","beforeWidth","beforeHeight","afterWidth","afterHeight","getLabelUnionRect","axisLabelModel","labelCount","isLabelIgnored","unrotatedSingleRect","singleRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","fixAxisOnZero","axesMap","otherAxisDim","axes","canNotOnZeroToAxis","updateAxisTransfrom","coordBase","axisExtentSum","toLocalCoord","findAxesModels","axesTypes","isCartesian2D","Cartesian2D","Axis2D","gridProto","_updateScale","ignoreContainLabel","adjustAxes","axesList","gridRect","labelUnionRect","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","getCartesians","_findConvertTarget","coordsList","createAxisCreator","axisPositionUsed","axesCount","addAxis","grids","916","orignalBrush","modified","clipPaths","shadowTemp","917","922","multi","paramVersion","default","isWithExts","Boolean","resolution","conditionWdith","a_type","a_val","fieldValues","_","pickerOptions","shortcuts","onClick","picker","$emit","formatDate","getDate","daycount","pickerOptionsI","onSearchButtonClick","tmpParmas","tmpParmasII","temp","exts","_index","onRestButtonClick","sdate","edate","923","isbutton","buttontype","arrValues","inboxcdData","tagSearch","checkList","watch","jungleHeight","buttonClick","buttonClickI","checkChange","row","filterTag","clientname","getTableData","reduceObj","ischeckbox","inboxcd","getIsbutton","handleSelectionChange","format","cellValue","924","925","chartInstance","echartsAPIList","926","927","axisTrigger","link","928","AxisPointerModel","triggerOn","animationDurationUpdate","shadowStyle","handle","icon","929","globalListener","AxisPointerView","930","BaseAxisPointer","moveAnimation","propsEqual","lastProp","lastProps","newProps","equals","updateLabelShowHide","labelEl","getHandleTransProps","trans","updateMandatoryProps","eventTool","throttleUtil","_group","_lastGraphicKey","_handle","_dragging","_lastValue","_lastStatus","_payloadInfo","animationThreshold","_axisModel","_axisPointerModel","makeElOption","graphicKey","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","isCategoryAxis","useSnap","pointerOption","pointer","pointerEl","updateHandleTransform","handleModel","onmousemove","onmousedown","_onHandleDragMove","ondragend","_onHandleDragEnd","includeStyles","handleSize","_moveHandleToValue","getHandleTransform","_doDispatchAxisPointer","payloadInfo","cursorPoint","tooltipOption","doClear","buildLabel","931","getAxisDimIndex","viewHelper","cartesianAxisHelper","CartesianAxisPointer","otherExtent","pixelValue","elStyle","pointerShapeBuilder","currPosition","cursorOtherValue","tooltipOptions","targetShape","shadow","932","illegalPoint","findPointFromSeries","isIllegalPoint","inputAxesInfo","shouldHide","outputFinder","showValueMap","dataByCoordSys","updaters","showPointer","showTooltip","coordSysContainsPoint","inputAxisInfo","findInputAxisInfo","processOnAxis","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","makeMapperParam","updateModelActually","dispatchTooltipActually","dispatchHighDownActually","newValue","dontSnap","buildPayloadsBySeries","payloadBatch","snapToValue","seriesNestestValue","nestestValue","modelHelper","coordSysItem","coordSysId","coordSysIndex","coordSysType","coordSysMainType","dataByAxis","axisId","valueLabelOpt","outputAxesInfo","valItem","lastHighlights","newHighlights","toHighlight","toDownplay","933","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","oldAxisGroup","_axisGroup","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","areaStyle","934","assembleTransition","transitionText","vendors","vendorPrefix","assembleFont","cssText","assembleCssText","transitionDuration","zrColor","borderName","camelCase","TooltipContent","appendChild","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","eventUtil","dispatch","onmouseleave","hideLater","_hideDelay","stl","currentStyle","defaultView","getComputedStyle","domStyle","display","innerHTML","setContent","setEnterable","enterable","getSize","clientWidth","clientHeight","viewportRootOffset","getViewportRootOffset","offsetLeft","offsetTop","isShow","935","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","animationEasingUpdate","936","buildTooltipModel","modelCascade","resultModel","refixTooltipPosition","gapH","gapV","getOuterSize","confineTooltipPosition","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","isCenterAlign","axisPointerViewHelper","proxyRect","tooltipContent","_tooltipContent","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","_initGlobalListener","_keepShow","_tryShow","_hide","_lastX","_lastY","_refreshUpdateTimeout","manuallyShowTip","_ticket","_manuallyAxisShowTip","pointInfo","manuallyHideTip","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","axisValue","seriesDefaultHTML","valueLabel","axisValueLabel","firstLine","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","tooltipTrigger","defaultHtml","asyncTicket","subTooltipModel","html","cbTicket","vAlign","viewSize","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisItemCoordSys","thisDataByAxis","lastItem","indexAxis","lastIndices","lastIdxItem","newIdxItem","937","nameRotate","nameTruncate","nameGap","symbolSize","inside","splitArea","axisDefault","categoryAxis","timeAxis","logAxis","logBase","938","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","AXIS_TYPES","939","coordExtent","940","dimAxisMapper","_axes","Cartesian","_dimList","getAxesByScale","_dataCoordConvert","input","dimList","output","941","axisX","axisY","942","containLabel","943","Region","geometries","cp","polygonContain","MAX_NUMBER","exterior","loopGeo","interiors","transformTo","944","decode","json","UTF8Encoding","encodeScale","UTF8Scale","feature","geometry","coordinates","encodeOffsets","coordinate","decodePolygon","c2","polygon","featureObj","region","945","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetterName","dataDiffer","existence","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","946","ecHelper","_List","_Model","_Axis","_env","_parseGeoJson","parseGeoJson","ecUtil","util","947","createList","createScale","mixinAxisModelCommonMethods","_completeDimensions","948","maskColor","mask","labelRect","949","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","existComponent","createSeriesIndices","filterBySubType","cpt","colorPaletteMinin","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","ComponentModelClass","newCptTypes","componentOption","cpts","isIdArray","isNameArray","queryCond","q","indexAttr","idAttr","nameAttr","queryResult","oneSeries","rawSeriesIndex","eachRawSeriesByType","getCurrentSeriesIndices","filteredSeries","componentTypes","950","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","951","platform","animationDuration","progressiveThreshold","hoverLayerThreshold","useUTC","952","953","954","lineType","955","getLineDash","dotSize","dashSize","956","graphicUtil","PATH_COLOR","957","compatLayoutProperties","LAYOUT_PROPERTIES","isTheme","compatStyle","seriesOpt","clockWise","pointerColor","COMPATITABLE_SERIES","dataRange","visualMap","COMPATITABLE_COMPONENTS","componentName","958","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","compatTextStyle","labelOptSingle","compatLabelTextStyle","labelOpt","processSeries","upperLabel","edgeLabel","markPoint","markLine","markArea","mpData","mlData","toArr","toObj","axisOpt","parallel","parallelOpt","parallelAxisDefault","calendar","calendarOpt","radar","radarOpt","geoOpt","regions","regionObj","959","fixRoundingError","originalVal","roundingErrorFix","scaleProto","intervalScaleProto","mathFloor","mathCeil","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","err","960","rank","961","scaleHelper","bisect","TimeScale","stepLvl","_stepLvl","ONE_HOUR","getFullYear","getMonth","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","timezoneOffset","getTimezoneOffset","ONE_SECOND","ONE_MINUTE","ONE_DAY","962","componentProto","963","encodeColor","colorAccessPath","964","965","966","967","label-width","nativeOn","keyup","_k","keyCode","_l","$$v","$set","picker-options","readonly","clearable","multiple","collapse-tags","true-label","slot","968","border","highlight-current-row","select-all","scopedSlots","_u","disabled","$index","change","sortable","filters","tagFilter","filter-method","placement","effect","code","969","makeEventPacket","eveType","targetInfo","gestureEvent","pinchX","pinchY","pinchScale","EmptyProxy","isHover","displayable","SILENT","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","mousemove","lastHovered","lastHoveredTarget","hovered","hoveredTarget","setCursor","mouseout","innerDom","element","toElement","relatedTarget","parentNode","eventArgs","eventPacket","eachOtherLayer","layer","exclude","hoverCheckResult","_downEl","_downPoint","_upEl","970","returnFalse","createDom","newDom","newDomStyle","Layer","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","__currentValues","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","save","fillRect","restore","971","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","singleCanvas","nodeName","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","_progressiveLayers","_hoverlayer","_hoverElements","viewportRoot","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","displayableSortFunc","getLayer","originalEl","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","MAX_PROGRESSIVE_LAYER_NUMBER","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","clearLayer","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","displayList","whIdx","cwh","plt","prb","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","pathTransform","ImageShape","imgShape","972","shapeCompareFunc","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","973","_event","_clips","_running","_time","_pausedTime","_pauseStart","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","974","_life","_initialized","onrestart","easingFuncs","globalTime","deltaTime","_startTime","easingFunc","schedule","restart","arg","975","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","976","977","978","_a","_b","979","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","windingQuadratic","y_","x_","windingArc","containPath","isStroke","cubic","quadratic","980","981","_curve","982","pointPair","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","983","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","instance","_touching","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","handlerDomProxyProto","984","paths","_updatePathDirty","985","globalCoord","986","987","textHelper","988","isLoop","constraint","prevPoint","nextPoint","cps","v2Min","v2Max","v2Clone","v2Sub","v2Scale","d0","v2Distance","cp0","v2Add","989","interpolate","segs","w2","w3","990","991","unitX","unitY","992","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","pointAt","tangentAt","993","994","995","polyHelper","996","997","998","999","fixClipWithShadow"],"mappings":"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","file":"static/js/2.9a5b3ca9fb1e9a0cb4a8.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 1000:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Animator = __webpack_require__(897);\n\nvar log = __webpack_require__(904);\n\nvar _util = __webpack_require__(794);\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * \n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * \n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1001:\n/***/ (function(module, exports) {\n\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1002:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\nvar PathProxy = __webpack_require__(859);\n\nvar transformPath = __webpack_require__(1003);\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n\n/***/ }),\n\n/***/ 1003:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar PathProxy = __webpack_require__(859);\n\nvar _vector = __webpack_require__(812);\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1005:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BaseBarSeries = __webpack_require__(1007);\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1006:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar graphic = __webpack_require__(808);\n\nvar _helper = __webpack_require__(1009);\n\nvar setLabel = _helper.setLabel;\n\nvar Model = __webpack_require__(823);\n\nvar barItemStyle = __webpack_require__(1008);\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1007:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SeriesModel = __webpack_require__(868);\n\nvar createListFromArray = __webpack_require__(883);\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 0\n    barMinHeight: 0,\n    // 0\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // \n    // barWidth: null,\n    // 30%\n    // barGap: '30%',\n    // 20%\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: ''\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1008:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(860);\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1009:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(808);\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n/***/ }),\n\n/***/ 1016:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar _number = __webpack_require__(810);\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1041:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(845);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(822);\n\nvar graphic = __webpack_require__(808);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 1042:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar Model = __webpack_require__(823);\n\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    this._data = legendData;\n    var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n      return series.name;\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        availableNames = availableNames.concat(data.mapArray(data.getName));\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1043:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar _symbol = __webpack_require__(875);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(808);\n\nvar _listComponent = __webpack_require__(1041);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(845);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1044:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n/***/ }),\n\n/***/ 1045:\n/***/ (function(module, exports) {\n\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1227:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_ZLCommonSearch__ = __webpack_require__(965);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_ZLCommonSearch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__components_ZLCommonSearch__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_ZLCommonTable__ = __webpack_require__(966);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_ZLCommonTable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_ZLCommonTable__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__report_block_sequence_chart__ = __webpack_require__(1559);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__report_block_sequence_chart___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__report_block_sequence_chart__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        var _this = this;\n        return {\n            tabHeight: null,\n            isLoading: false,\n            deliveryData: [],\n            searchFields: [{\n                name: '',\n                type: 'daterange',\n                fieldName: 'datehandle',\n                label: 'senddate',\n                value: [_this.recentDate(1), _this.recentDate(1)]\n            }, {\n                name: '',\n                type: 'select',\n                fieldName: 'contracttype',\n                label: [{ label: '', value: '0' }, { label: '', value: '1' }, { label: '', value: '2' }]\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'ordernum_like'\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'clientname_like'\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'buildsite_like'\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'goodsname_like'\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'buildpartname_like'\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'empname_like'\n            },\n            //                    {\n            //                        name: '',//todo\n            //                        type: 'select',\n            //                        fieldName: 'clientcode_like'\n            //                    },\n            //                    {\n            //                        name: '',//todo\n            //                        type: 'string',\n            //                        fieldName: 'clientcode_like'\n            //                    },\n            {\n                name: '',\n                type: 'string',\n                fieldName: 'senddriver_like'\n            }, {\n                name: '',\n                type: 'string',\n                fieldName: 'senddrivername_like'\n            }],\n            itemValues: [{\n                name: 'contracttypename',\n                label: '',\n                width: 80,\n                widthI: 70,\n                type: 'normal'\n            }, {\n                name: 'sendnum',\n                label: '',\n                width: 90,\n                type: 'normal'\n            }, {\n                name: 'senddate',\n                label: '',\n                width: 80,\n                widthI: 70,\n                type: 'normal',\n                formatter: true\n            }, {\n                name: 'empname',\n                label: '',\n                width: 60,\n                widthI: 45,\n                type: 'normal'\n            }, {\n                name: 'clientname',\n                label: '',\n                width: '',\n                type: 'normal'\n            }, {\n                name: 'buildsite',\n                label: '',\n                width: '',\n                type: 'normal'\n            }, {\n                name: 'goodsname',\n                label: '',\n                width: 100,\n                widthI: 90,\n                type: 'normal'\n            }, {\n                name: 'buildpartname',\n                label: '',\n                width: 100,\n                widthI: 90,\n                type: 'normal'\n            }, {\n                name: 'buildwayname',\n                label: '',\n                width: 65,\n                widthI: 40,\n                type: 'normal'\n            }, {\n                name: 'buildslumpname',\n                label: '',\n                width: 60,\n                widthI: 45,\n                type: 'normal'\n            }, {\n                name: 'sendqty',\n                label: '',\n                width: 65,\n                widthI: 40,\n                type: 'normal'\n            }, {\n                name: 'senddriver',\n                label: '',\n                width: '',\n                type: 'normal'\n            }, {\n                name: 'senddrivername',\n                label: '',\n                width: 65,\n                widthI: 45,\n                type: 'normal'\n            },\n            //                    {\n            //                        name:'remark',//todo\n            //                        label:'',\n            //                        width:60,\n            //                        widthI:45,\n            //                        type:'normal'\n            //                    },\n            //                    {\n            //                        name:'remark',//todo\n            //                        label:'',\n            //                        width:65,\n            //                        widthI:45,\n            //                        type:'normal'\n            //                    },\n            //                    {\n            //                        name:'remark',//todo\n            //                        label:'',\n            //                        width:60,\n            //                        widthI:50,\n            //                        type:'normal'\n            //                    },\n            //                    {\n            //                        name:'remark',//todo\n            //                        label:'',\n            //                        width:'',\n            //                        type:'normal'\n            //                    },\n            {\n                name: 'warnmark',\n                label: '',\n                width: '',\n                type: 'normal'\n            }, {\n                type: 'button',\n                label: '',\n                width: 120,\n                buttons: [{ name: 'detail', label: '' }]\n            }],\n            content: 'senddate_ge_date=' + _this.recentDate(1) + '&senddate_le_date=' + _this.recentDate(1) + '&sendstatus_gt=-1',\n            arrowBot: true,\n            arrowTop: false,\n            searchVisible: true,\n            height: null,\n            formHeight: null,\n            detailVisible: false,\n            dialogW: \"850px\",\n            dialog_top: \"100px\"\n        };\n    },\n\n    components: {\n        ZLCommonSearch: __WEBPACK_IMPORTED_MODULE_0__components_ZLCommonSearch___default.a, ZLCommonTable: __WEBPACK_IMPORTED_MODULE_1__components_ZLCommonTable___default.a, sequence_chart: __WEBPACK_IMPORTED_MODULE_2__report_block_sequence_chart___default.a\n    },\n    mounted: function mounted() {\n        var _this2 = this;\n\n        this.init();\n        setTimeout(function () {\n            _this2.getDivHeight();\n        }, 20);\n    },\n\n    methods: {\n        init: function init() {\n            this.getlist();\n        },\n        getDivHeight: function getDivHeight() {\n            var pageHeight = this.$refs.pageHeight.offsetHeight;\n            var btnHeight = this.$refs.btnHeight.offsetHeight;\n            this.formHeight = this.$refs.formHeight.offsetHeight;\n            this.height = pageHeight - btnHeight - this.$store.state.pageHeight;\n            this.tabHeight = this.height - this.formHeight;\n        },\n\n\n        //\n        toggleSearch: function toggleSearch() {\n            var _this3 = this;\n\n            this.arrowBot = !this.arrowBot;\n            this.arrowTop = !this.arrowTop;\n            this.searchVisible = !this.searchVisible;\n            if (this.searchVisible) {\n                setTimeout(function () {\n                    _this3.tabHeight = _this3.height - _this3.formHeight;\n                }, 20);\n            } else {\n                this.tabHeight = this.height;\n            }\n        },\n\n\n        //\n        initials: function initials() {\n            this.$refs.ZLCommonSearch.init();\n        },\n\n\n        //\n        search: function search(params) {\n            this.content = params + '&sendstatus_gt=-1';\n            this.cPage = 1;\n            this.getlist();\n        },\n\n\n        //\n        getlist: function getlist() {\n            var _this4 = this;\n\n            this.isLoading = true;\n            this.getAjax('/finance/erpMes/erp-prod-send?pageNo=' + this.cPage + '&pageSize=' + this.cSize + '&' + this.content).then(function (result) {\n                if (result.status === 200) {\n                    if (result.data.list[0] === null) {\n                        _this4.deliveryData = [];\n                        _this4.isLoading = false;\n                    } else {\n                        result.data.list.forEach(function (item, index) {\n                            if (item.contracttype === 0) {\n                                item.contracttypename = '';\n                            } else if (item.contracttype === 1) {\n                                item.contracttypename = '';\n                            } else if (item.contracttype === 2) {\n                                item.contracttypename = '';\n                            } else {\n                                item.contracttypename = null;\n                            }\n                        });\n                        _this4.deliveryData = result.data.list;\n                        _this4.cTotal = result.data.total;\n                        _this4.isLoading = false;\n                    }\n                } else {\n                    _this4.$message({\n                        message: result.message || '',\n                        type: 'error'\n                    });\n                    _this4.isLoading = false;\n                }\n            });\n        },\n\n\n        //\n        showDetail: function showDetail(index, rows) {\n            var _this5 = this;\n\n            this.detailVisible = true;\n            this.$nextTick(function () {\n                _this5.$refs.sequence.initEchart(rows[index].sendnum);\n            });\n        }\n    }\n});\n\n/***/ }),\n\n/***/ 1237:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nvar echarts = __webpack_require__(809);\n__webpack_require__(884);\n__webpack_require__(881);\n__webpack_require__(914);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    data: function data() {\n        return {\n            sendObj: {\n                producecommandtime: 0,\n                makematerialtime: 0,\n                qualitychecktime: 0,\n                targetbuildsitetime: 0,\n                buildsiteoffloadtime: 0,\n                targetstarttime: 0\n            }\n        };\n    },\n\n    methods: {\n        //echart\n        initEchart: function initEchart(sendnum) {\n            var _this = this;\n\n            //this.myChart = echarts.init(this.$refs.myChart);\n            this.fetch('/location/prodsendmonitor/prodsendMonitorInfos', { sendnum: sendnum }).then(function (result) {\n                if (result.status === 200) {\n                    _this.sendObj = result.data;\n                    //this.setCustomChart(result.data);\n                } else {}\n            });\n        },\n\n\n        //echart\n        setCustomChart: function setCustomChart(obj) {\n            var lastII = 0,\n                lastIII = 0,\n                lastIV = 0,\n                lastV = 0,\n                lastVI = void 0;\n            lastII = obj.targetstarttime + obj.buildsiteoffloadtime;\n            lastIII = lastII + obj.targetbuildsitetime;\n            lastIV = lastIII + obj.qualitychecktime;\n            lastV = lastIV + obj.makematerialtime;\n            lastVI = lastV + obj.producecommandtime;\n            this.myChart.setOption({\n                grid: {\n                    left: '15%',\n                    top: '10%'\n                },\n                xAxis: {\n                    name: '()',\n                    type: 'value',\n                    axisLine: {\n                        symbol: ['none', 'arrow']\n                    }\n                },\n                yAxis: {\n                    name: '',\n                    type: 'category',\n                    axisTick: false,\n                    splitLine: { show: false },\n                    data: ['', '', '', '', '', ''],\n                    axisLine: {\n                        symbol: ['none', 'arrow']\n                    },\n                    nameLocation: 'middle',\n                    nameTextStyle: {\n                        fontWeight: 500,\n                        fontSize: 14\n                    },\n                    axisLabel: {\n                        show: false\n                    }\n                },\n                series: [{\n                    name: '',\n                    type: 'bar',\n                    stack: '',\n                    itemStyle: {\n                        normal: {\n                            barBorderColor: 'rgba(0,0,0,0)',\n                            color: 'rgba(0,0,0,0)'\n                        },\n                        emphasis: {\n                            barBorderColor: 'rgba(0,0,0,0)',\n                            color: 'rgba(0,0,0,0)'\n                        }\n                    },\n                    data: [lastVI - obj.targetstarttime, lastVI - lastII, lastVI - lastIII, lastVI - lastIV, lastVI - lastV, 0]\n                }, {\n                    name: '',\n                    type: 'bar',\n                    stack: '',\n                    barWidth: 15,\n                    label: {\n                        normal: {\n                            show: true,\n                            position: 'right',\n                            formatter: '{b}\\n{c}'\n                        }\n                    },\n                    data: [{ value: obj.targetstarttime, itemStyle: { normal: { color: \"#670b88\" } } }, { value: obj.buildsiteoffloadtime, itemStyle: { normal: { color: \"#0300fa\" } } }, { value: obj.targetbuildsitetime, itemStyle: { normal: { color: \"#00878c\" } } }, { value: obj.qualitychecktime, itemStyle: { normal: { color: \"#857f00\" } } }, { value: obj.makematerialtime, itemStyle: { normal: { color: \"#ff6500\" } } }, { value: obj.producecommandtime, itemStyle: { normal: { color: \"#fc0000\" } } }]\n                }]\n            });\n        }\n    }\n});\n\n/***/ }),\n\n/***/ 1371:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(656)(true);\n// imports\n\n\n// module\nexports.push([module.i, \".chart-wrap[data-v-9eaf5f0e]{width:600px;height:720px}@media screen and (max-width:1500px){.chart-wrap[data-v-9eaf5f0e]{height:550px}}@media screen and (min-width:1200px) and (max-width:1500px){.chart-wrap[data-v-9eaf5f0e]{height:470px}}.myChart[data-v-9eaf5f0e]{width:800px;height:400px}.chart-div[data-v-9eaf5f0e]{position:relative}.x-text[data-v-9eaf5f0e]{position:absolute;right:6%;bottom:-5%;color:#000;font-weight:600}.y-text[data-v-9eaf5f0e]{left:5%;top:35%;position:absolute;color:#000;font-weight:600;display:inline-flex;flex-direction:column}.left-arrow[data-v-9eaf5f0e]{position:absolute;left:6%;top:-5%;width:0;height:0;border:10px solid transparent;border-bottom-color:#000}.bot-arrow[data-v-9eaf5f0e]{position:absolute;right:6%;bottom:-2%;width:0;height:0;border:10px solid transparent;border-left-color:#000}.time-wrap[data-v-9eaf5f0e]{width:700px;height:400px;border-left:2px solid #000;border-bottom:2px solid #000;margin:20px 70px 20px auto;position:relative}.time-wrap .item-div[data-v-9eaf5f0e]{position:absolute;text-align:center;border-right:1px dashed #ccc;height:100%}.time-wrap .text[data-v-9eaf5f0e]{color:#ae1d3a;line-height:1.2;font-weight:600}.time-wrap .time[data-v-9eaf5f0e]{height:20px;color:#fff;text-align:center;border:1px solid #000}.time-wrap .itemI[data-v-9eaf5f0e]{left:0;top:10%;width:7%}.time-wrap .itemI .time[data-v-9eaf5f0e]{background:#fc0000}.time-wrap .itemII[data-v-9eaf5f0e]{left:7%;top:25%;width:13%}.time-wrap .itemII .time[data-v-9eaf5f0e]{background:#ff6500}.time-wrap .itemIII[data-v-9eaf5f0e]{left:20%;top:40%;width:9%}.time-wrap .itemIII .time[data-v-9eaf5f0e]{background:#857f00}.time-wrap .itemIV[data-v-9eaf5f0e]{left:29%;top:55%;width:22%}.time-wrap .itemIV .time[data-v-9eaf5f0e]{background:#00878c}.time-wrap .itemV[data-v-9eaf5f0e]{left:51%;top:70%;width:18%}.time-wrap .itemV .time[data-v-9eaf5f0e]{background:#0300fa}.time-wrap .itemVI[data-v-9eaf5f0e]{left:69%;top:85%;width:22%}.time-wrap .itemVI .time[data-v-9eaf5f0e]{background:#670b88}.xtext[data-v-9eaf5f0e]{position:absolute;bottom:-5%;font-weight:600;color:#000}.xtextI[data-v-9eaf5f0e]{left:12%}.xtextII[data-v-9eaf5f0e]{left:23%}.xtextIII[data-v-9eaf5f0e]{left:30%}.xtextIV[data-v-9eaf5f0e]{left:49%}.xtextV[data-v-9eaf5f0e]{left:64%}.xtextVI[data-v-9eaf5f0e]{left:82%}\", \"\", {\"version\":3,\"sources\":[\"F:/pc_project/erp-aluminium/yunerp/src/page/erp_pc/erp_report/report_block/sequence_chart.vue\"],\"names\":[],\"mappings\":\"AACA,6BACE,YAAa,AACb,YAAc,CACf,AACD,qCACA,6BACI,YAAc,CACjB,CACA,AACD,4DACA,6BACI,YAAc,CACjB,CACA,AACD,0BACE,YAAa,AACb,YAAc,CACf,AACD,4BACE,iBAAmB,CACpB,AACD,yBACE,kBAAmB,AACnB,SAAU,AACV,WAAY,AACZ,WAAY,AACZ,eAAiB,CAClB,AACD,yBACE,QAAS,AACT,QAAS,AACT,kBAAmB,AACnB,WAAY,AACZ,gBAAiB,AACjB,oBAAqB,AACrB,qBAAuB,CACxB,AACD,6BACE,kBAAmB,AACnB,QAAS,AACT,QAAS,AACT,QAAS,AACT,SAAU,AACV,8BAA+B,AAC/B,wBAA0B,CAC3B,AACD,4BACE,kBAAmB,AACnB,SAAU,AACV,WAAY,AACZ,QAAS,AACT,SAAU,AACV,8BAA+B,AAC/B,sBAAwB,CACzB,AACD,4BACE,YAAa,AACb,aAAc,AACd,2BAA4B,AAC5B,6BAA8B,AAC9B,2BAA4B,AAC5B,iBAAmB,CACpB,AACD,sCACE,kBAAmB,AACnB,kBAAmB,AACnB,6BAA8B,AAC9B,WAAa,CACd,AACD,kCACE,cAAe,AACf,gBAAiB,AACjB,eAAiB,CAClB,AACD,kCACE,YAAa,AACb,WAAa,AACb,kBAAmB,AACnB,qBAAuB,CACxB,AACD,mCACE,OAAQ,AACR,QAAS,AACT,QAAU,CACX,AACD,yCACE,kBAAoB,CACrB,AACD,oCACE,QAAS,AACT,QAAS,AACT,SAAW,CACZ,AACD,0CACE,kBAAoB,CACrB,AACD,qCACE,SAAU,AACV,QAAS,AACT,QAAU,CACX,AACD,2CACE,kBAAoB,CACrB,AACD,oCACE,SAAU,AACV,QAAS,AACT,SAAW,CACZ,AACD,0CACE,kBAAoB,CACrB,AACD,mCACE,SAAU,AACV,QAAS,AACT,SAAW,CACZ,AACD,yCACE,kBAAoB,CACrB,AACD,oCACE,SAAU,AACV,QAAS,AACT,SAAW,CACZ,AACD,0CACE,kBAAoB,CACrB,AACD,wBACE,kBAAmB,AACnB,WAAY,AACZ,gBAAiB,AACjB,UAAY,CACb,AACD,yBACE,QAAU,CACX,AACD,0BACE,QAAU,CACX,AACD,2BACE,QAAU,CACX,AACD,0BACE,QAAU,CACX,AACD,yBACE,QAAU,CACX,AACD,0BACE,QAAU,CACX\",\"file\":\"sequence_chart.vue\",\"sourcesContent\":[\"\\n.chart-wrap[data-v-9eaf5f0e] {\\n  width: 600px;\\n  height: 720px;\\n}\\n@media screen and (max-width: 1500px) {\\n.chart-wrap[data-v-9eaf5f0e] {\\n    height: 550px;\\n}\\n}\\n@media screen and (min-width: 1200px) and (max-width: 1500px) {\\n.chart-wrap[data-v-9eaf5f0e] {\\n    height: 470px;\\n}\\n}\\n.myChart[data-v-9eaf5f0e] {\\n  width: 800px;\\n  height: 400px;\\n}\\n.chart-div[data-v-9eaf5f0e] {\\n  position: relative;\\n}\\n.x-text[data-v-9eaf5f0e] {\\n  position: absolute;\\n  right: 6%;\\n  bottom: -5%;\\n  color: #000;\\n  font-weight: 600;\\n}\\n.y-text[data-v-9eaf5f0e] {\\n  left: 5%;\\n  top: 35%;\\n  position: absolute;\\n  color: #000;\\n  font-weight: 600;\\n  display: inline-flex;\\n  flex-direction: column;\\n}\\n.left-arrow[data-v-9eaf5f0e] {\\n  position: absolute;\\n  left: 6%;\\n  top: -5%;\\n  width: 0;\\n  height: 0;\\n  border: 10px solid transparent;\\n  border-bottom-color: #000;\\n}\\n.bot-arrow[data-v-9eaf5f0e] {\\n  position: absolute;\\n  right: 6%;\\n  bottom: -2%;\\n  width: 0;\\n  height: 0;\\n  border: 10px solid transparent;\\n  border-left-color: #000;\\n}\\n.time-wrap[data-v-9eaf5f0e] {\\n  width: 700px;\\n  height: 400px;\\n  border-left: 2px solid #000;\\n  border-bottom: 2px solid #000;\\n  margin: 20px 70px 20px auto;\\n  position: relative;\\n}\\n.time-wrap .item-div[data-v-9eaf5f0e] {\\n  position: absolute;\\n  text-align: center;\\n  border-right: 1px dashed #ccc;\\n  height: 100%;\\n}\\n.time-wrap .text[data-v-9eaf5f0e] {\\n  color: #ae1d3a;\\n  line-height: 1.2;\\n  font-weight: 600;\\n}\\n.time-wrap .time[data-v-9eaf5f0e] {\\n  height: 20px;\\n  color: white;\\n  text-align: center;\\n  border: 1px solid #000;\\n}\\n.time-wrap .itemI[data-v-9eaf5f0e] {\\n  left: 0;\\n  top: 10%;\\n  width: 7%;\\n}\\n.time-wrap .itemI .time[data-v-9eaf5f0e] {\\n  background: #fc0000;\\n}\\n.time-wrap .itemII[data-v-9eaf5f0e] {\\n  left: 7%;\\n  top: 25%;\\n  width: 13%;\\n}\\n.time-wrap .itemII .time[data-v-9eaf5f0e] {\\n  background: #ff6500;\\n}\\n.time-wrap .itemIII[data-v-9eaf5f0e] {\\n  left: 20%;\\n  top: 40%;\\n  width: 9%;\\n}\\n.time-wrap .itemIII .time[data-v-9eaf5f0e] {\\n  background: #857f00;\\n}\\n.time-wrap .itemIV[data-v-9eaf5f0e] {\\n  left: 29%;\\n  top: 55%;\\n  width: 22%;\\n}\\n.time-wrap .itemIV .time[data-v-9eaf5f0e] {\\n  background: #00878c;\\n}\\n.time-wrap .itemV[data-v-9eaf5f0e] {\\n  left: 51%;\\n  top: 70%;\\n  width: 18%;\\n}\\n.time-wrap .itemV .time[data-v-9eaf5f0e] {\\n  background: #0300fa;\\n}\\n.time-wrap .itemVI[data-v-9eaf5f0e] {\\n  left: 69%;\\n  top: 85%;\\n  width: 22%;\\n}\\n.time-wrap .itemVI .time[data-v-9eaf5f0e] {\\n  background: #670b88;\\n}\\n.xtext[data-v-9eaf5f0e] {\\n  position: absolute;\\n  bottom: -5%;\\n  font-weight: 600;\\n  color: #000;\\n}\\n.xtextI[data-v-9eaf5f0e] {\\n  left: 12%;\\n}\\n.xtextII[data-v-9eaf5f0e] {\\n  left: 23%;\\n}\\n.xtextIII[data-v-9eaf5f0e] {\\n  left: 30%;\\n}\\n.xtextIV[data-v-9eaf5f0e] {\\n  left: 49%;\\n}\\n.xtextV[data-v-9eaf5f0e] {\\n  left: 64%;\\n}\\n.xtextVI[data-v-9eaf5f0e] {\\n  left: 82%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1502:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(1371);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(657)(\"6903b422\", content, true, {});\n\n/***/ }),\n\n/***/ 1559:\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction injectStyle (ssrContext) {\n  __webpack_require__(1502)\n}\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(1237),\n  /* template */\n  __webpack_require__(1716),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  \"data-v-9eaf5f0e\",\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 1683:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"pageHeight\",\n    staticClass: \"page-secondnav page-commonnav\"\n  }, [_c('div', {\n    staticClass: \"f-content\"\n  }, [_c('div', {\n    ref: \"btnHeight\",\n    staticClass: \"console-pt4 console-pb4\"\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"text\"\n    }\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"pull-right\"\n  }, [_c('el-button', {\n    staticClass: \"ui-color2 console-mr2\",\n    attrs: {\n      \"title\": \"\"\n    },\n    on: {\n      \"click\": _vm.initials\n    }\n  }, [_c('i', {\n    staticClass: \"fa fa-refresh\"\n  })]), _vm._v(\" \"), (_vm.arrowBot) ? _c('span', {\n    staticClass: \"color-1 margin-2 fm-query\",\n    on: {\n      \"click\": _vm.toggleSearch\n    }\n  }, [_vm._v(\"\"), _c('i', {\n    staticClass: \"el-icon-arrow-down margin-2\"\n  })]) : _vm._e(), _vm._v(\" \"), (_vm.arrowTop) ? _c('span', {\n    staticClass: \"color-1 margin-2 fm-query\",\n    on: {\n      \"click\": _vm.toggleSearch\n    }\n  }, [_vm._v(\"\"), _c('i', {\n    staticClass: \"el-icon-arrow-up margin-2\"\n  })]) : _vm._e()], 1)], 1), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.searchVisible),\n      expression: \"searchVisible\"\n    }],\n    ref: \"formHeight\",\n    staticClass: \"console-pb4\"\n  }, [_c('ZLCommonSearch', {\n    ref: \"ZLCommonSearch\",\n    attrs: {\n      \"fields\": _vm.searchFields\n    },\n    on: {\n      \"searchII\": _vm.search\n    }\n  })], 1), _vm._v(\" \"), _c('ZLCommonTable', {\n    attrs: {\n      \"tableData\": _vm.deliveryData,\n      \"tabHeight\": _vm.tabHeight,\n      \"itemValues\": _vm.itemValues,\n      \"isLoading\": _vm.isLoading\n    },\n    on: {\n      \"detail\": _vm.showDetail\n    }\n  }), _vm._v(\" \"), _c('el-pagination', {\n    staticClass: \"console-mt5\",\n    attrs: {\n      \"current-page\": _vm.cPage,\n      \"page-sizes\": _vm.cpageSizes,\n      \"page-size\": _vm.cSize,\n      \"layout\": \"total, sizes, prev, pager, next\",\n      \"total\": _vm.cTotal\n    },\n    on: {\n      \"size-change\": _vm.handleSizeChange,\n      \"current-change\": _vm.handleCurrentChange\n    }\n  }), _vm._v(\" \"), _c('el-dialog', {\n    staticClass: \"dialogDiv dialogDivII\",\n    attrs: {\n      \"show-close\": false,\n      \"size\": \"tiny\",\n      \"top\": _vm.dialog_top,\n      \"visible\": _vm.detailVisible,\n      \"width\": _vm.dialogW,\n      \"modal\": true\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.detailVisible = $event\n      }\n    }\n  }, [_c('div', {\n    staticClass: \"slideContent leftOffsetIII\",\n    style: ({\n      width: _vm.dialogW\n    })\n  }, [_c('div', {\n    directives: [{\n      name: \"drag1\",\n      rawName: \"v-drag1\"\n    }],\n    staticClass: \"slideTop\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"slideMid\"\n  }, [_c('sequence_chart', {\n    ref: \"sequence\",\n    attrs: {\n      \"detailVisible\": _vm.detailVisible\n    }\n  })], 1)])])], 1)])\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 1716:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"chart-div\"\n  }, [_c('div', {\n    staticClass: \"bot-arrow\"\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"left-arrow\"\n  }), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('div', {\n    staticClass: \"time-wrap\"\n  }, [_c('div', {\n    staticClass: \"item-div itemI\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemII\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.makematerialtime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemIII\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.qualitychecktime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemIV\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.targetbuildsitetime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemV\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.buildsiteoffloadtime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemVI\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.targetstarttime) + \"\")])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextI\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextII\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextIII\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextIV\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime + _vm.sendObj.targetbuildsitetime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextV\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime + _vm.sendObj.targetbuildsitetime + _vm.sendObj.buildsiteoffloadtime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextVI\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime + _vm.sendObj.targetbuildsitetime + _vm.sendObj.buildsiteoffloadtime + _vm.sendObj.targetstarttime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"x-text\"\n  }, [_vm._v(\"()\")])])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"y-text\"\n  }, [_c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")])])\n}]}\n\n/***/ }),\n\n/***/ 769:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(1227),\n  /* template */\n  __webpack_require__(1683),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 794:\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/core/util\n */\n// mergeDate\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // overwritetrue\n        // NOTE target[key] \n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * \n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz \n * @param {Function} baseClazz \n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n/***/ }),\n\n/***/ 808:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar pathTool = __webpack_require__(1002);\n\nvar colorTool = __webpack_require__(853);\n\nvar matrix = __webpack_require__(848);\n\nvar vector = __webpack_require__(812);\n\nvar Path = __webpack_require__(813);\n\nvar Transformable = __webpack_require__(911);\n\nvar Image = __webpack_require__(905);\n\nexports.Image = Image;\n\nvar Group = __webpack_require__(858);\n\nexports.Group = Group;\n\nvar Text = __webpack_require__(987);\n\nexports.Text = Text;\n\nvar Circle = __webpack_require__(993);\n\nexports.Circle = Circle;\n\nvar Sector = __webpack_require__(999);\n\nexports.Sector = Sector;\n\nvar Ring = __webpack_require__(998);\n\nexports.Ring = Ring;\n\nvar Polygon = __webpack_require__(995);\n\nexports.Polygon = Polygon;\n\nvar Polyline = __webpack_require__(996);\n\nexports.Polyline = Polyline;\n\nvar Rect = __webpack_require__(997);\n\nexports.Rect = Rect;\n\nvar Line = __webpack_require__(994);\n\nexports.Line = Line;\n\nvar BezierCurve = __webpack_require__(992);\n\nexports.BezierCurve = BezierCurve;\n\nvar Arc = __webpack_require__(991);\n\nexports.Arc = Arc;\n\nvar CompoundPath = __webpack_require__(984);\n\nexports.CompoundPath = CompoundPath;\n\nvar LinearGradient = __webpack_require__(985);\n\nexports.LinearGradient = LinearGradient;\n\nvar RadialGradient = __webpack_require__(986);\n\nexports.RadialGradient = RadialGradient;\n\nvar BoundingRect = __webpack_require__(821);\n\nexports.BoundingRect = BoundingRect;\nvar round = Math.round;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar EMPTY_OBJ = {};\n/**\n * Extend shape with parameters\n */\n\nfunction extendShape(opts) {\n  return Path.extend(opts);\n}\n/**\n * Extend path\n */\n\n\nfunction extendPath(pathData, opts) {\n  return pathTool.extendFromString(pathData, opts);\n}\n/**\n * Create a path element from path data string\n * @param {string} pathData\n * @param {Object} opts\n * @param {module:zrender/core/BoundingRect} rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\n\n\nfunction makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n  var boundingRect = path.getBoundingRect();\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, boundingRect);\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\n * Create a image element from image url\n * @param {string} imageUrl image url\n * @param {Object} opts options\n * @param {module:zrender/core/BoundingRect} rect constrain rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\n\n\nfunction makeImage(imageUrl, rect, layout) {\n  var path = new Image({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        path.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return path;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  {Object} rect         element local bounding box\n * @param  {Object} boundingRect constraint bounding box\n * @return {Object} element position containing x, y, width, and height\n */\n\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nvar mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param {module:zrender/graphic/Path} path\n * @param {Object} rect\n */\n\nfunction resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x1]\n * @param {number} [param.shape.y1]\n * @param {number} [param.shape.x2]\n * @param {number} [param.shape.y2]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\n\n\nfunction subPixelOptimizeLine(param) {\n  var shape = param.shape;\n  var lineWidth = param.style.lineWidth;\n\n  if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n  }\n\n  if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n  }\n\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x]\n * @param {number} [param.shape.y]\n * @param {number} [param.shape.width]\n * @param {number} [param.shape.height]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\n\n\nfunction subPixelOptimizeRect(param) {\n  var shape = param.shape;\n  var lineWidth = param.style.lineWidth;\n  var originX = shape.x;\n  var originY = shape.y;\n  var originWidth = shape.width;\n  var originHeight = shape.height;\n  shape.x = subPixelOptimize(shape.x, lineWidth, true);\n  shape.y = subPixelOptimize(shape.y, lineWidth, true);\n  shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n  shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nfunction hasFillOrStroke(fillOrStroke) {\n  return fillOrStroke != null && fillOrStroke != 'none';\n}\n\nfunction liftColor(color) {\n  return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n}\n/**\n * @private\n */\n\n\nfunction cacheElementStl(el) {\n  if (el.__hoverStlDirty) {\n    var stroke = el.style.stroke;\n    var fill = el.style.fill; // Create hoverStyle on mouseover\n\n    var hoverStyle = el.__hoverStl;\n    hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n    hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n    var normalStyle = {};\n\n    for (var name in hoverStyle) {\n      // See comment in `doSingleEnterHover`.\n      if (hoverStyle[name] != null) {\n        normalStyle[name] = el.style[name];\n      }\n    }\n\n    el.__normalStl = normalStyle;\n    el.__hoverStlDirty = false;\n  }\n}\n/**\n * @private\n */\n\n\nfunction doSingleEnterHover(el) {\n  if (el.__isHover) {\n    return;\n  }\n\n  cacheElementStl(el);\n\n  if (el.useHoverLayer) {\n    el.__zr && el.__zr.addHover(el, el.__hoverStl);\n  } else {\n    var style = el.style;\n    var insideRollbackOpt = style.insideRollbackOpt; // Consider case: only `position: 'top'` is set on emphasis, then text\n    // color should be returned to `autoColor`, rather than remain '#fff'.\n    // So we should rollback then apply again after style merging.\n\n    insideRollbackOpt && rollbackInsideStyle(style); // styles can be:\n    // {\n    //     label: {\n    //         normal: {\n    //             show: false,\n    //             position: 'outside',\n    //             fontSize: 18\n    //         },\n    //         emphasis: {\n    //             show: true\n    //         }\n    //     }\n    // },\n    // where properties of `emphasis` may not appear in `normal`. We previously use\n    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.\n    // But consider rich text and setOption in merge mode, it is impossible to cover\n    // all properties in merge. So we use merge mode when setting style here, where\n    // only properties that is not `null/undefined` can be set. The disadventage:\n    // null/undefined can not be used to remove style any more in `emphasis`.\n\n    style.extendFrom(el.__hoverStl); // Do not save `insideRollback`.\n\n    if (insideRollbackOpt) {\n      applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt); // textFill may be rollbacked to null.\n\n      if (style.textFill == null) {\n        style.textFill = insideRollbackOpt.autoColor;\n      }\n    }\n\n    el.dirty(false);\n    el.z2 += 1;\n  }\n\n  el.__isHover = true;\n}\n/**\n * @inner\n */\n\n\nfunction doSingleLeaveHover(el) {\n  if (!el.__isHover) {\n    return;\n  }\n\n  var normalStl = el.__normalStl;\n\n  if (el.useHoverLayer) {\n    el.__zr && el.__zr.removeHover(el);\n  } else {\n    // Consider null/undefined value, should use\n    // `setStyle` but not `extendFrom(stl, true)`.\n    normalStl && el.setStyle(normalStl);\n    el.z2 -= 1;\n  }\n\n  el.__isHover = false;\n}\n/**\n * @inner\n */\n\n\nfunction doEnterHover(el) {\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      doSingleEnterHover(child);\n    }\n  }) : doSingleEnterHover(el);\n}\n\nfunction doLeaveHover(el) {\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      doSingleLeaveHover(child);\n    }\n  }) : doSingleLeaveHover(el);\n}\n/**\n * @inner\n */\n\n\nfunction setElementHoverStl(el, hoverStl) {\n  // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n  // Often used when item group has a label element and it's hoverStyle is different\n  el.__hoverStl = el.hoverStyle || hoverStl || {};\n  el.__hoverStlDirty = true;\n\n  if (el.__isHover) {\n    cacheElementStl(el);\n  }\n}\n/**\n * @inner\n */\n\n\nfunction onElementMouseOver(e) {\n  if (this.__hoverSilentOnTouch && e.zrByTouch) {\n    return;\n  } // Only if element is not in emphasis status\n\n\n  !this.__isEmphasis && doEnterHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction onElementMouseOut(e) {\n  if (this.__hoverSilentOnTouch && e.zrByTouch) {\n    return;\n  } // Only if element is not in emphasis status\n\n\n  !this.__isEmphasis && doLeaveHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction enterEmphasis() {\n  this.__isEmphasis = true;\n  doEnterHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction leaveEmphasis() {\n  this.__isEmphasis = false;\n  doLeaveHover(this);\n}\n/**\n * Set hover style of element.\n * This method can be called repeatly without side-effects.\n * @param {module:zrender/Element} el\n * @param {Object} [hoverStyle]\n * @param {Object} [opt]\n * @param {boolean} [opt.hoverSilentOnTouch=false]\n *        In touch device, mouseover event will be trigger on touchstart event\n *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n *        conviniently use hoverStyle when tap on touch screen without additional\n *        code for compatibility.\n *        But if the chart/component has select feature, which usually also use\n *        hoverStyle, there might be conflict between 'select-highlight' and\n *        'hover-highlight' especially when roam is enabled (see geo for example).\n *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n *        on touch device.\n */\n\n\nfunction setHoverStyle(el, hoverStyle, opt) {\n  el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      setElementHoverStl(child, hoverStyle);\n    }\n  }) : setElementHoverStl(el, hoverStyle); // Duplicated function will be auto-ignored, see Eventful.js.\n\n  el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually\n\n  el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n}\n/**\n * @param {Object|module:zrender/graphic/Style} normalStyle\n * @param {Object} emphasisStyle\n * @param {module:echarts/model/Model} normalModel\n * @param {module:echarts/model/Model} emphasisModel\n * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.\n * @param {Object} [opt.defaultText]\n * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by\n *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {Object} [normalSpecified]\n * @param {Object} [emphasisSpecified]\n */\n\n\nfunction setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {\n  opt = opt || EMPTY_OBJ;\n  var labelFetcher = opt.labelFetcher;\n  var labelDataIndex = opt.labelDataIndex;\n  var labelDimIndex = opt.labelDimIndex; // This scenario, `label.normal.show = true; label.emphasis.show = false`,\n  // is not supported util someone requests.\n\n  var showNormal = normalModel.getShallow('show');\n  var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.\n  // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,\n  // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.\n\n  var baseText = showNormal || showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex) : null, opt.defaultText) : null;\n  var normalStyleText = showNormal ? baseText : null;\n  var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.\n\n  if (normalStyleText != null || emphasisStyleText != null) {\n    // Always set `textStyle` even if `normalStyle.text` is null, because default\n    // values have to be set on `normalStyle`.\n    // If we set default values on `emphasisStyle`, consider case:\n    // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`\n    // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`\n    // Then the 'red' will not work on emphasis.\n    setTextStyle(normalStyle, normalModel, normalSpecified, opt);\n    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);\n  }\n\n  normalStyle.text = normalStyleText;\n  emphasisStyle.text = emphasisStyleText;\n}\n/**\n * Set basic textStyle properties.\n * @param {Object|module:zrender/graphic/Style} textStyle\n * @param {module:echarts/model/Model} model\n * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.\n * @param {Object} [opt] See `opt` of `setTextStyleCommon`.\n * @param {boolean} [isEmphasis]\n */\n\n\nfunction setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {\n  setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);\n  specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);\n  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n  return textStyle;\n}\n/**\n * Set text option in the style.\n * @deprecated\n * @param {Object} textStyle\n * @param {module:echarts/model/Model} labelModel\n * @param {string|boolean} defaultColor Default text color.\n *        If set as false, it will be processed as a emphasis style.\n */\n\n\nfunction setText(textStyle, labelModel, defaultColor) {\n  var opt = {\n    isRectText: true\n  };\n  var isEmphasis;\n\n  if (defaultColor === false) {\n    isEmphasis = true;\n  } else {\n    // Support setting color as 'auto' to get visual color.\n    opt.autoColor = defaultColor;\n  }\n\n  setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);\n  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n}\n/**\n * {\n *      disableBox: boolean, Whether diable drawing box of block (outer most).\n *      isRectText: boolean,\n *      autoColor: string, specify a color when color is 'auto',\n *              for textFill, textStroke, textBackgroundColor, and textBorderColor.\n *              If autoColor specified, it is used as default textFill.\n *      useInsideStyle:\n *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)\n *                  if `textFill` is not specified.\n *              `false`: Do not use inside style.\n *              `null/undefined`: use inside style if `isRectText` is true and\n *                  `textFill` is not specified and textPosition contains `'inside'`.\n *      forceRich: boolean\n * }\n */\n\n\nfunction setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {\n  // Consider there will be abnormal when merge hover style to normal style if given default value.\n  opt = opt || EMPTY_OBJ;\n\n  if (opt.isRectText) {\n    var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used\n    // in bar series, and magric type should be considered.\n\n    textPosition === 'outside' && (textPosition = 'top');\n    textStyle.textPosition = textPosition;\n    textStyle.textOffset = textStyleModel.getShallow('offset');\n    var labelRotate = textStyleModel.getShallow('rotate');\n    labelRotate != null && (labelRotate *= Math.PI / 180);\n    textStyle.textRotation = labelRotate;\n    textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);\n  }\n\n  var ecModel = textStyleModel.ecModel;\n  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:\n  // {\n  //     data: [{\n  //         value: 12,\n  //         label: {\n  //             normal: {\n  //                 rich: {\n  //                     // no 'a' here but using parent 'a'.\n  //                 }\n  //             }\n  //         }\n  //     }],\n  //     rich: {\n  //         a: { ... }\n  //     }\n  // }\n\n  var richItemNames = getRichItemNames(textStyleModel);\n  var richResult;\n\n  if (richItemNames) {\n    richResult = {};\n\n    for (var name in richItemNames) {\n      if (richItemNames.hasOwnProperty(name)) {\n        // Cascade is supported in rich.\n        var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.\n\n        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);\n      }\n    }\n  }\n\n  textStyle.rich = richResult;\n  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);\n\n  if (opt.forceRich && !opt.textStyle) {\n    opt.textStyle = {};\n  }\n\n  return textStyle;\n} // Consider case:\n// {\n//     data: [{\n//         value: 12,\n//         label: {\n//             normal: {\n//                 rich: {\n//                     // no 'a' here but using parent 'a'.\n//                 }\n//             }\n//         }\n//     }],\n//     rich: {\n//         a: { ... }\n//     }\n// }\n\n\nfunction getRichItemNames(textStyleModel) {\n  // Use object to remove duplicated names.\n  var richItemNameMap;\n\n  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n    var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n\n    if (rich) {\n      richItemNameMap = richItemNameMap || {};\n\n      for (var name in rich) {\n        if (rich.hasOwnProperty(name)) {\n          richItemNameMap[name] = 1;\n        }\n      }\n    }\n\n    textStyleModel = textStyleModel.parentModel;\n  }\n\n  return richItemNameMap;\n}\n\nfunction setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {\n  // In merge mode, default value should not be given.\n  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;\n  textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;\n  textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;\n  textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);\n\n  if (!isEmphasis) {\n    if (isBlock) {\n      // Always set `insideRollback`, for clearing previous.\n      var originalTextPosition = textStyle.textPosition;\n      textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt); // Save original textPosition, because style.textPosition will be repalced by\n      // real location (like [10, 30]) in zrender.\n\n      textStyle.insideOriginalTextPosition = originalTextPosition;\n      textStyle.insideRollbackOpt = opt;\n    } // Set default finally.\n\n\n    if (textStyle.textFill == null) {\n      textStyle.textFill = opt.autoColor;\n    }\n  } // Do not use `getFont` here, because merge should be supported, where\n  // part of these properties may be changed in emphasis style, and the\n  // others should remain their original value got from normal style.\n\n\n  textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;\n  textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;\n  textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;\n  textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;\n  textStyle.textAlign = textStyleModel.getShallow('align');\n  textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');\n  textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');\n  textStyle.textWidth = textStyleModel.getShallow('width');\n  textStyle.textHeight = textStyleModel.getShallow('height');\n  textStyle.textTag = textStyleModel.getShallow('tag');\n\n  if (!isBlock || !opt.disableBox) {\n    textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);\n    textStyle.textPadding = textStyleModel.getShallow('padding');\n    textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);\n    textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');\n    textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');\n    textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');\n    textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');\n    textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');\n    textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');\n  }\n\n  textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;\n  textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;\n  textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;\n  textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;\n}\n\nfunction getAutoColor(color, opt) {\n  return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;\n}\n\nfunction applyInsideStyle(textStyle, textPosition, opt) {\n  var useInsideStyle = opt.useInsideStyle;\n  var insideRollback;\n\n  if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition // textPosition can be [10, 30]\n  && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {\n    insideRollback = {\n      textFill: null,\n      textStroke: textStyle.textStroke,\n      textStrokeWidth: textStyle.textStrokeWidth\n    };\n    textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.\n\n    if (textStyle.textStroke == null) {\n      textStyle.textStroke = opt.autoColor;\n      textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);\n    }\n  }\n\n  return insideRollback;\n}\n\nfunction rollbackInsideStyle(style) {\n  var insideRollback = style.insideRollback;\n\n  if (insideRollback) {\n    style.textFill = insideRollback.textFill;\n    style.textStroke = insideRollback.textStroke;\n    style.textStrokeWidth = insideRollback.textStrokeWidth;\n  }\n}\n\nfunction getFont(opt, ecModel) {\n  // ecModel or default text style model.\n  var gTextStyleModel = ecModel || ecModel.getModel('textStyle');\n  return [// FIXME in node-canvas fontWeight is before fontStyle\n  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' ');\n}\n\nfunction animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n  if (typeof dataIndex === 'function') {\n    cb = dataIndex;\n    dataIndex = null;\n  } // Do not check 'animation' property directly here. Consider this case:\n  // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n  // but its parent model (`seriesModel`) does.\n\n\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n  if (animationEnabled) {\n    var postfix = isUpdate ? 'Update' : '';\n    var duration = animatableModel.getShallow('animationDuration' + postfix);\n    var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n    var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n\n    if (typeof animationDelay === 'function') {\n      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n    }\n\n    if (typeof duration === 'function') {\n      duration = duration(dataIndex);\n    }\n\n    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());\n  } else {\n    el.stopAnimation();\n    el.attr(props);\n    cb && cb();\n  }\n}\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} [cb]\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\n\n\nfunction updateProps(el, props, animatableModel, dataIndex, cb) {\n  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n}\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} cb\n */\n\n\nfunction initProps(el, props, animatableModel, dataIndex, cb) {\n  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n}\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param {module:zrender/mixin/Transformable} target\n * @param {module:zrender/mixin/Transformable} [ancestor]\n */\n\n\nfunction getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param {Array.<number>} target [x, y]\n * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param {boolean=} invert Whether use invert matrix.\n * @return {Array.<number>} [x, y]\n */\n\n\nfunction applyTransform(target, transform, invert) {\n  if (transform && !zrUtil.isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param {string} direction 'left' 'right' 'top' 'bottom'\n * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param {boolean=} invert Whether use invert matrix.\n * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\n\nfunction transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\n\nfunction groupTransition(g1, g2, animatableModel, cb) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (!el.isGroup && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      position: vector.clone(el.position),\n      rotation: el.rotation\n    };\n\n    if (el.shape) {\n      obj.shape = zrUtil.extend({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (!el.isGroup && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, el.dataIndex);\n      } // else {\n      //     if (el.previousProps) {\n      //         graphic.updateProps\n      //     }\n      // }\n\n    }\n  });\n}\n/**\n * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n * @param {Object} rect {x, y, width, height}\n * @return {Array.<Array.<number>>} A new clipped points.\n */\n\n\nfunction clipPointsByRect(points, rect) {\n  return zrUtil.map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * @param {Object} targetRect {x, y, width, height}\n * @param {Object} rect {x, y, width, height}\n * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n */\n\n\nfunction clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n/**\n * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.\n * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.\n * @param {Object} [rect] {x, y, width, height}\n * @return {module:zrender/Element} Icon path or image element.\n */\n\n\nfunction createIcon(iconStr, opt, rect) {\n  opt = zrUtil.extend({\n    rectHover: true\n  }, opt);\n  var style = opt.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new Image(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');\n  }\n}\n\nexports.extendShape = extendShape;\nexports.extendPath = extendPath;\nexports.makePath = makePath;\nexports.makeImage = makeImage;\nexports.mergePath = mergePath;\nexports.resizePath = resizePath;\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;\nexports.setHoverStyle = setHoverStyle;\nexports.setLabelStyle = setLabelStyle;\nexports.setTextStyle = setTextStyle;\nexports.setText = setText;\nexports.getFont = getFont;\nexports.updateProps = updateProps;\nexports.initProps = initProps;\nexports.getTransform = getTransform;\nexports.applyTransform = applyTransform;\nexports.transformDirection = transformDirection;\nexports.groupTransition = groupTransition;\nexports.clipPointsByRect = clipPointsByRect;\nexports.clipRectByRect = clipRectByRect;\nexports.createIcon = createIcon;\n\n/***/ }),\n\n/***/ 809:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrender = __webpack_require__(912);\n\nvar zrUtil = __webpack_require__(794);\n\nvar colorTool = __webpack_require__(853);\n\nvar env = __webpack_require__(819);\n\nvar timsort = __webpack_require__(877);\n\nvar Eventful = __webpack_require__(852);\n\nvar GlobalModel = __webpack_require__(949);\n\nvar ExtensionAPI = __webpack_require__(925);\n\nvar CoordinateSystemManager = __webpack_require__(872);\n\nvar OptionManager = __webpack_require__(950);\n\nvar backwardCompat = __webpack_require__(957);\n\nvar ComponentModel = __webpack_require__(838);\n\nvar SeriesModel = __webpack_require__(868);\n\nvar ComponentView = __webpack_require__(962);\n\nvar ChartView = __webpack_require__(869);\n\nvar graphic = __webpack_require__(808);\n\nvar modelUtil = __webpack_require__(811);\n\nvar _throttle = __webpack_require__(876);\n\nvar throttle = _throttle.throttle;\n\nvar seriesColor = __webpack_require__(963);\n\nvar loadingDefault = __webpack_require__(948);\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\nvar each = zrUtil.each;\nvar parseClassType = ComponentModel.parseClassType;\nvar version = '3.8.5';\nvar dependencies = {\n  zrender: '3.7.4'\n};\nvar PRIORITY_PROCESSOR_FILTER = 1000;\nvar PRIORITY_PROCESSOR_STATISTIC = 5000;\nvar PRIORITY_VISUAL_LAYOUT = 1000;\nvar PRIORITY_VISUAL_GLOBAL = 2000;\nvar PRIORITY_VISUAL_CHART = 3000;\nvar PRIORITY_VISUAL_COMPONENT = 4000; // FIXME\n// necessary?\n\nvar PRIORITY_VISUAL_BRUSH = 5000;\nvar PRIORITY = {\n  PROCESSOR: {\n    FILTER: PRIORITY_PROCESSOR_FILTER,\n    STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n  },\n  VISUAL: {\n    LAYOUT: PRIORITY_VISUAL_LAYOUT,\n    GLOBAL: PRIORITY_VISUAL_GLOBAL,\n    CHART: PRIORITY_VISUAL_CHART,\n    COMPONENT: PRIORITY_VISUAL_COMPONENT,\n    BRUSH: PRIORITY_VISUAL_BRUSH\n  }\n}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n// where they must not be invoked nestedly, except the only case: invoke\n// dispatchAction with updateMethod \"none\" in main process.\n// This flag is used to carry out this rule.\n// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\nvar IN_MAIN_PROCESS = '__flagInMainProcess';\nvar HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\nvar OPTION_UPDATED = '__optionUpdated';\nvar ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\nfunction createRegisterEventWithLowercaseName(method) {\n  return function (eventName, handler, context) {\n    // Event name is all lowercase\n    eventName = eventName && eventName.toLowerCase();\n    Eventful.prototype[method].call(this, eventName, handler, context);\n  };\n}\n/**\n * @module echarts~MessageCenter\n */\n\n\nfunction MessageCenter() {\n  Eventful.call(this);\n}\n\nMessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\nMessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\nMessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\nzrUtil.mixin(MessageCenter, Eventful);\n/**\n * @module echarts~ECharts\n */\n\nfunction ECharts(dom, theme, opts) {\n  opts = opts || {}; // Get theme by name\n\n  if (typeof theme === 'string') {\n    theme = themeStorage[theme];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  this.id;\n  /**\n   * Group id\n   * @type {string}\n   */\n\n  this.group;\n  /**\n   * @type {HTMLElement}\n   * @private\n   */\n\n  this._dom = dom;\n  var defaultRenderer = 'canvas';\n\n  /**\n   * @type {module:zrender/ZRender}\n   * @private\n   */\n  var zr = this._zr = zrender.init(dom, {\n    renderer: opts.renderer || defaultRenderer,\n    devicePixelRatio: opts.devicePixelRatio,\n    width: opts.width,\n    height: opts.height\n  });\n  /**\n   * Expect 60 pfs.\n   * @type {Function}\n   * @private\n   */\n\n  this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);\n  var theme = zrUtil.clone(theme);\n  theme && backwardCompat(theme, true);\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._theme = theme;\n  /**\n   * @type {Array.<module:echarts/view/Chart>}\n   * @private\n   */\n\n  this._chartsViews = [];\n  /**\n   * @type {Object.<string, module:echarts/view/Chart>}\n   * @private\n   */\n\n  this._chartsMap = {};\n  /**\n   * @type {Array.<module:echarts/view/Component>}\n   * @private\n   */\n\n  this._componentsViews = [];\n  /**\n   * @type {Object.<string, module:echarts/view/Component>}\n   * @private\n   */\n\n  this._componentsMap = {};\n  /**\n   * @type {module:echarts/CoordinateSystem}\n   * @private\n   */\n\n  this._coordSysMgr = new CoordinateSystemManager();\n  /**\n   * @type {module:echarts/ExtensionAPI}\n   * @private\n   */\n\n  this._api = createExtensionAPI(this);\n  Eventful.call(this);\n  /**\n   * @type {module:echarts~MessageCenter}\n   * @private\n   */\n\n  this._messageCenter = new MessageCenter(); // Init mouse events\n\n  this._initEvents(); // In case some people write `window.onresize = chart.resize`\n\n\n  this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure\n\n  this._pendingActions = []; // Sort on demand\n\n  function prioritySortFunc(a, b) {\n    return a.prio - b.prio;\n  }\n\n  timsort(visualFuncs, prioritySortFunc);\n  timsort(dataProcessorFuncs, prioritySortFunc);\n  zr.animation.on('frame', this._onframe, this); // ECharts instance can be used as value.\n\n  zrUtil.setAsPrimitive(this);\n}\n\nvar echartsProto = ECharts.prototype;\n\nechartsProto._onframe = function () {\n  // Lazy update\n  if (this[OPTION_UPDATED]) {\n    var silent = this[OPTION_UPDATED].silent;\n    this[IN_MAIN_PROCESS] = true;\n    updateMethods.prepareAndUpdate.call(this);\n    this[IN_MAIN_PROCESS] = false;\n    this[OPTION_UPDATED] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  }\n};\n/**\n * @return {HTMLElement}\n */\n\n\nechartsProto.getDom = function () {\n  return this._dom;\n};\n/**\n * @return {module:zrender~ZRender}\n */\n\n\nechartsProto.getZr = function () {\n  return this._zr;\n};\n/**\n * Usage:\n * chart.setOption(option, notMerge, lazyUpdate);\n * chart.setOption(option, {\n *     notMerge: ...,\n *     lazyUpdate: ...,\n *     silent: ...\n * });\n *\n * @param {Object} option\n * @param {Object|boolean} [opts] opts or notMerge.\n * @param {boolean} [opts.notMerge=false]\n * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n */\n\n\nechartsProto.setOption = function (option, notMerge, lazyUpdate) {\n  var silent;\n\n  if (zrUtil.isObject(notMerge)) {\n    lazyUpdate = notMerge.lazyUpdate;\n    silent = notMerge.silent;\n    notMerge = notMerge.notMerge;\n  }\n\n  this[IN_MAIN_PROCESS] = true;\n\n  if (!this._model || notMerge) {\n    var optionManager = new OptionManager(this._api);\n    var theme = this._theme;\n    var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n    ecModel.init(null, null, theme, optionManager);\n  }\n\n  this._model.setOption(option, optionPreprocessorFuncs);\n\n  if (lazyUpdate) {\n    this[OPTION_UPDATED] = {\n      silent: silent\n    };\n    this[IN_MAIN_PROCESS] = false;\n  } else {\n    updateMethods.prepareAndUpdate.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be\n    // fetched after `setOption`.\n\n    this._zr.flush();\n\n    this[OPTION_UPDATED] = false;\n    this[IN_MAIN_PROCESS] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  }\n};\n/**\n * @DEPRECATED\n */\n\n\nechartsProto.setTheme = function () {\n  console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n};\n/**\n * @return {module:echarts/model/Global}\n */\n\n\nechartsProto.getModel = function () {\n  return this._model;\n};\n/**\n * @return {Object}\n */\n\n\nechartsProto.getOption = function () {\n  return this._model && this._model.getOption();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getWidth = function () {\n  return this._zr.getWidth();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getHeight = function () {\n  return this._zr.getHeight();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getDevicePixelRatio = function () {\n  return this._zr.painter.dpr || window.devicePixelRatio || 1;\n};\n/**\n * Get canvas which has all thing rendered\n * @param {Object} opts\n * @param {string} [opts.backgroundColor]\n * @return {string}\n */\n\n\nechartsProto.getRenderedCanvas = function (opts) {\n  if (!env.canvasSupported) {\n    return;\n  }\n\n  opts = opts || {};\n  opts.pixelRatio = opts.pixelRatio || 1;\n  opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n  var zr = this._zr;\n  var list = zr.storage.getDisplayList(); // Stop animations\n\n  zrUtil.each(list, function (el) {\n    el.stopAnimation(true);\n  });\n  return zr.painter.getRenderedCanvas(opts);\n};\n/**\n * Get svg data url\n * @return {string}\n */\n\n\nechartsProto.getSvgDataUrl = function () {\n  if (!env.svgSupported) {\n    return;\n  }\n\n  var zr = this._zr;\n  var list = zr.storage.getDisplayList(); // Stop animations\n\n  zrUtil.each(list, function (el) {\n    el.stopAnimation(true);\n  });\n  return zr.painter.pathToSvg();\n};\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n * @param {string} [opts.excludeComponents]\n */\n\n\nechartsProto.getDataURL = function (opts) {\n  opts = opts || {};\n  var excludeComponents = opts.excludeComponents;\n  var ecModel = this._model;\n  var excludesComponentViews = [];\n  var self = this;\n  each(excludeComponents, function (componentType) {\n    ecModel.eachComponent({\n      mainType: componentType\n    }, function (component) {\n      var view = self._componentsMap[component.__viewId];\n\n      if (!view.group.ignore) {\n        excludesComponentViews.push(view);\n        view.group.ignore = true;\n      }\n    });\n  });\n  var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n  each(excludesComponentViews, function (view) {\n    view.group.ignore = false;\n  });\n  return url;\n};\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n */\n\n\nechartsProto.getConnectedDataURL = function (opts) {\n  if (!env.canvasSupported) {\n    return;\n  }\n\n  var groupId = this.group;\n  var mathMin = Math.min;\n  var mathMax = Math.max;\n  var MAX_NUMBER = Infinity;\n\n  if (connectedGroups[groupId]) {\n    var left = MAX_NUMBER;\n    var top = MAX_NUMBER;\n    var right = -MAX_NUMBER;\n    var bottom = -MAX_NUMBER;\n    var canvasList = [];\n    var dpr = opts && opts.pixelRatio || 1;\n    zrUtil.each(instances, function (chart, id) {\n      if (chart.group === groupId) {\n        var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n        var boundingRect = chart.getDom().getBoundingClientRect();\n        left = mathMin(boundingRect.left, left);\n        top = mathMin(boundingRect.top, top);\n        right = mathMax(boundingRect.right, right);\n        bottom = mathMax(boundingRect.bottom, bottom);\n        canvasList.push({\n          dom: canvas,\n          left: boundingRect.left,\n          top: boundingRect.top\n        });\n      }\n    });\n    left *= dpr;\n    top *= dpr;\n    right *= dpr;\n    bottom *= dpr;\n    var width = right - left;\n    var height = bottom - top;\n    var targetCanvas = zrUtil.createCanvas();\n    targetCanvas.width = width;\n    targetCanvas.height = height;\n    var zr = zrender.init(targetCanvas);\n    each(canvasList, function (item) {\n      var img = new graphic.Image({\n        style: {\n          x: item.left * dpr - left,\n          y: item.top * dpr - top,\n          image: item.dom\n        }\n      });\n      zr.add(img);\n    });\n    zr.refreshImmediately();\n    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n  } else {\n    return this.getDataURL(opts);\n  }\n};\n/**\n * Convert from logical coordinate system to pixel coordinate system.\n * See CoordinateSystem#convertToPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId, geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\n\n\nechartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n/**\n * Convert from pixel coordinate system to logical coordinate system.\n * See CoordinateSystem#convertFromPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\n\nechartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\nfunction doConvertPixel(methodName, finder, value) {\n  var ecModel = this._model;\n\n  var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\n  var result;\n  finder = modelUtil.parseFinder(ecModel, finder);\n\n  for (var i = 0; i < coordSysList.length; i++) {\n    var coordSys = coordSysList[i];\n\n    if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {\n      return result;\n    }\n  }\n}\n/**\n * Is the specified coordinate systems or components contain the given pixel point.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {boolean} result\n */\n\n\nechartsProto.containPixel = function (finder, value) {\n  var ecModel = this._model;\n  var result;\n  finder = modelUtil.parseFinder(ecModel, finder);\n  zrUtil.each(finder, function (models, key) {\n    key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n      var coordSys = model.coordinateSystem;\n\n      if (coordSys && coordSys.containPoint) {\n        result |= !!coordSys.containPoint(value);\n      } else if (key === 'seriesModels') {\n        var view = this._chartsMap[model.__viewId];\n\n        if (view && view.containPoint) {\n          result |= view.containPoint(value, model);\n        } else {}\n      } else {}\n    }, this);\n  }, this);\n  return !!result;\n};\n/**\n * Get visual from series or data.\n * @param {string|Object} finder\n *        If string, e.g., 'series', means {seriesIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            dataIndex / dataIndexInside\n *        }\n *        If dataIndex is not specified, series visual will be fetched,\n *        but not data item visual.\n *        If all of seriesIndex, seriesId, seriesName are not specified,\n *        visual will be fetched from first series.\n * @param {string} visualType 'color', 'symbol', 'symbolSize'\n */\n\n\nechartsProto.getVisual = function (finder, visualType) {\n  var ecModel = this._model;\n  finder = modelUtil.parseFinder(ecModel, finder, {\n    defaultMainType: 'series'\n  });\n  var seriesModel = finder.seriesModel;\n  var data = seriesModel.getData();\n  var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;\n  return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);\n};\n/**\n * Get view of corresponding component model\n * @param  {module:echarts/model/Component} componentModel\n * @return {module:echarts/view/Component}\n */\n\n\nechartsProto.getViewOfComponentModel = function (componentModel) {\n  return this._componentsMap[componentModel.__viewId];\n};\n/**\n * Get view of corresponding series model\n * @param  {module:echarts/model/Series} seriesModel\n * @return {module:echarts/view/Chart}\n */\n\n\nechartsProto.getViewOfSeriesModel = function (seriesModel) {\n  return this._chartsMap[seriesModel.__viewId];\n};\n\nvar updateMethods = {\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  update: function (payload) {\n    // console.profile && console.profile('update');\n    var ecModel = this._model;\n    var api = this._api;\n    var coordSysMgr = this._coordSysMgr;\n    var zr = this._zr; // update before setOption\n\n    if (!ecModel) {\n      return;\n    } // Fixme First time update ?\n\n\n    ecModel.restoreData(); // TODO\n    // Save total ecModel here for undo/redo (after restoring data and before processing data).\n    // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n    // Create new coordinate system each update\n    // In LineView may save the old coordinate system and use it to get the orignal point\n\n    coordSysMgr.create(this._model, this._api);\n    processData.call(this, ecModel, api);\n    stackSeriesData.call(this, ecModel);\n    coordSysMgr.update(ecModel, api);\n    doVisualEncoding.call(this, ecModel, payload);\n    doRender.call(this, ecModel, payload); // Set background\n\n    var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n    var painter = zr.painter; // TODO all use clearColor ?\n\n    if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n      zr.configLayer(0, {\n        clearColor: backgroundColor\n      });\n    } else {\n      // In IE8\n      if (!env.canvasSupported) {\n        var colorArr = colorTool.parse(backgroundColor);\n        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\n        if (colorArr[3] === 0) {\n          backgroundColor = 'transparent';\n        }\n      }\n\n      if (backgroundColor.colorStops || backgroundColor.image) {\n        // Gradient background\n        // FIXME Fixed layer\n        zr.configLayer(0, {\n          clearColor: backgroundColor\n        });\n        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n        this._dom.style.background = 'transparent';\n      } else {\n        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n          zr.configLayer(0, {\n            clearColor: null\n          });\n        }\n\n        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n        this._dom.style.background = backgroundColor;\n      }\n    }\n\n    each(postUpdateFuncs, function (func) {\n      func(ecModel, api);\n    }); // console.profile && console.profileEnd('update');\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateView: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    ecModel.eachSeries(function (seriesModel) {\n      seriesModel.getData().clearAllVisual();\n    });\n    doVisualEncoding.call(this, ecModel, payload);\n    invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateVisual: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    ecModel.eachSeries(function (seriesModel) {\n      seriesModel.getData().clearAllVisual();\n    });\n    doVisualEncoding.call(this, ecModel, payload, true);\n    invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateLayout: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    doLayout.call(this, ecModel, payload);\n    invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  prepareAndUpdate: function (payload) {\n    var ecModel = this._model;\n    prepareView.call(this, 'component', ecModel);\n    prepareView.call(this, 'chart', ecModel);\n    updateMethods.update.call(this, payload);\n  }\n};\n/**\n * @private\n */\n\nfunction updateDirectly(ecIns, method, payload, mainType, subType) {\n  var ecModel = ecIns._model; // broadcast\n\n  if (!mainType) {\n    each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n    return;\n  }\n\n  var query = {};\n  query[mainType + 'Id'] = payload[mainType + 'Id'];\n  query[mainType + 'Index'] = payload[mainType + 'Index'];\n  query[mainType + 'Name'] = payload[mainType + 'Name'];\n  var condition = {\n    mainType: mainType,\n    query: query\n  };\n  subType && (condition.subType = subType); // subType may be '' by parseClassType;\n  // If dispatchAction before setOption, do nothing.\n\n  ecModel && ecModel.eachComponent(condition, function (model, index) {\n    callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);\n  }, ecIns);\n\n  function callView(view) {\n    view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);\n  }\n}\n/**\n * Resize the chart\n * @param {Object} opts\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n * @param {boolean} [opts.silent=false]\n */\n\n\nechartsProto.resize = function (opts) {\n  this[IN_MAIN_PROCESS] = true;\n\n  this._zr.resize(opts);\n\n  var optionChanged = this._model && this._model.resetOption('media');\n\n  var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n  updateMethods[updateMethod].call(this); // Resize loading effect\n\n  this._loadingFX && this._loadingFX.resize();\n  this[IN_MAIN_PROCESS] = false;\n  var silent = opts && opts.silent;\n  flushPendingActions.call(this, silent);\n  triggerUpdatedEvent.call(this, silent);\n};\n/**\n * Show loading effect\n * @param  {string} [name='default']\n * @param  {Object} [cfg]\n */\n\n\nechartsProto.showLoading = function (name, cfg) {\n  if (zrUtil.isObject(name)) {\n    cfg = name;\n    name = '';\n  }\n\n  name = name || 'default';\n  this.hideLoading();\n\n  if (!loadingEffects[name]) {\n    return;\n  }\n\n  var el = loadingEffects[name](this._api, cfg);\n  var zr = this._zr;\n  this._loadingFX = el;\n  zr.add(el);\n};\n/**\n * Hide loading effect\n */\n\n\nechartsProto.hideLoading = function () {\n  this._loadingFX && this._zr.remove(this._loadingFX);\n  this._loadingFX = null;\n};\n/**\n * @param {Object} eventObj\n * @return {Object}\n */\n\n\nechartsProto.makeActionFromEvent = function (eventObj) {\n  var payload = zrUtil.extend({}, eventObj);\n  payload.type = eventActionMap[eventObj.type];\n  return payload;\n};\n/**\n * @pubilc\n * @param {Object} payload\n * @param {string} [payload.type] Action type\n * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n * @param {boolean} [opt.silent=false] Whether trigger events.\n * @param {boolean} [opt.flush=undefined]\n *                  true: Flush immediately, and then pixel in canvas can be fetched\n *                      immediately. Caution: it might affect performance.\n *                  false: Not not flush.\n *                  undefined: Auto decide whether perform flush.\n */\n\n\nechartsProto.dispatchAction = function (payload, opt) {\n  if (!zrUtil.isObject(opt)) {\n    opt = {\n      silent: !!opt\n    };\n  }\n\n  if (!actions[payload.type]) {\n    return;\n  } // Avoid dispatch action before setOption. Especially in `connect`.\n\n\n  if (!this._model) {\n    return;\n  } // May dispatchAction in rendering procedure\n\n\n  if (this[IN_MAIN_PROCESS]) {\n    this._pendingActions.push(payload);\n\n    return;\n  }\n\n  doDispatchAction.call(this, payload, opt.silent);\n\n  if (opt.flush) {\n    this._zr.flush(true);\n  } else if (opt.flush !== false && env.browser.weChat) {\n    // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n    // hang when sliding page (on touch event), which cause that zr does not\n    // refresh util user interaction finished, which is not expected.\n    // But `dispatchAction` may be called too frequently when pan on touch\n    // screen, which impacts performance if do not throttle them.\n    this._throttledZrFlush();\n  }\n\n  flushPendingActions.call(this, opt.silent);\n  triggerUpdatedEvent.call(this, opt.silent);\n};\n\nfunction doDispatchAction(payload, silent) {\n  var payloadType = payload.type;\n  var escapeConnect = payload.escapeConnect;\n  var actionWrap = actions[payloadType];\n  var actionInfo = actionWrap.actionInfo;\n  var cptType = (actionInfo.update || 'update').split(':');\n  var updateMethod = cptType.pop();\n  cptType = cptType[0] != null && parseClassType(cptType[0]);\n  this[IN_MAIN_PROCESS] = true;\n  var payloads = [payload];\n  var batched = false; // Batch action\n\n  if (payload.batch) {\n    batched = true;\n    payloads = zrUtil.map(payload.batch, function (item) {\n      item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n      item.batch = null;\n      return item;\n    });\n  }\n\n  var eventObjBatch = [];\n  var eventObj;\n  var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n  each(payloads, function (batchItem) {\n    // Action can specify the event by return it.\n    eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside\n\n    eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType\n\n    eventObj.type = actionInfo.event || eventObj.type;\n    eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.\n\n    if (isHighDown) {\n      // method, payload, mainType, subType\n      updateDirectly(this, updateMethod, batchItem, 'series');\n    } else if (cptType) {\n      updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n    }\n  }, this);\n\n  if (updateMethod !== 'none' && !isHighDown && !cptType) {\n    // Still dirty\n    if (this[OPTION_UPDATED]) {\n      // FIXME Pass payload ?\n      updateMethods.prepareAndUpdate.call(this, payload);\n      this[OPTION_UPDATED] = false;\n    } else {\n      updateMethods[updateMethod].call(this, payload);\n    }\n  } // Follow the rule of action batch\n\n\n  if (batched) {\n    eventObj = {\n      type: actionInfo.event || payloadType,\n      escapeConnect: escapeConnect,\n      batch: eventObjBatch\n    };\n  } else {\n    eventObj = eventObjBatch[0];\n  }\n\n  this[IN_MAIN_PROCESS] = false;\n  !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n}\n\nfunction flushPendingActions(silent) {\n  var pendingActions = this._pendingActions;\n\n  while (pendingActions.length) {\n    var payload = pendingActions.shift();\n    doDispatchAction.call(this, payload, silent);\n  }\n}\n\nfunction triggerUpdatedEvent(silent) {\n  !silent && this.trigger('updated');\n}\n/**\n * Register event\n * @method\n */\n\n\nechartsProto.on = createRegisterEventWithLowercaseName('on');\nechartsProto.off = createRegisterEventWithLowercaseName('off');\nechartsProto.one = createRegisterEventWithLowercaseName('one');\n/**\n * @param {string} methodName\n * @private\n */\n\nfunction invokeUpdateMethod(methodName, ecModel, payload) {\n  var api = this._api; // Update all components\n\n  each(this._componentsViews, function (component) {\n    var componentModel = component.__model;\n    component[methodName](componentModel, ecModel, api, payload);\n    updateZ(componentModel, component);\n  }, this); // Upate all charts\n\n  ecModel.eachSeries(function (seriesModel, idx) {\n    var chart = this._chartsMap[seriesModel.__viewId];\n    chart[methodName](seriesModel, ecModel, api, payload);\n    updateZ(seriesModel, chart);\n    updateProgressiveAndBlend(seriesModel, chart);\n  }, this); // If use hover layer\n\n  updateHoverLayerStatus(this._zr, ecModel); // Post render\n\n  each(postUpdateFuncs, function (func) {\n    func(ecModel, api);\n  });\n}\n/**\n * Prepare view instances of charts and components\n * @param  {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction prepareView(type, ecModel) {\n  var isComponent = type === 'component';\n  var viewList = isComponent ? this._componentsViews : this._chartsViews;\n  var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n  var zr = this._zr;\n\n  for (var i = 0; i < viewList.length; i++) {\n    viewList[i].__alive = false;\n  }\n\n  ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n    if (isComponent) {\n      if (componentType === 'series') {\n        return;\n      }\n    } else {\n      model = componentType;\n    } // Consider: id same and type changed.\n\n\n    var viewId = '_ec_' + model.id + '_' + model.type;\n    var view = viewMap[viewId];\n\n    if (!view) {\n      var classType = parseClassType(model.type);\n      var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\n      if (Clazz) {\n        view = new Clazz();\n        view.init(ecModel, this._api);\n        viewMap[viewId] = view;\n        viewList.push(view);\n        zr.add(view.group);\n      } else {\n        // Error\n        return;\n      }\n    }\n\n    model.__viewId = view.__id = viewId;\n    view.__alive = true;\n    view.__model = model;\n    view.group.__ecComponentInfo = {\n      mainType: model.mainType,\n      index: model.componentIndex\n    };\n  }, this);\n\n  for (var i = 0; i < viewList.length;) {\n    var view = viewList[i];\n\n    if (!view.__alive) {\n      zr.remove(view.group);\n      view.dispose(ecModel, this._api);\n      viewList.splice(i, 1);\n      delete viewMap[view.__id];\n      view.__id = view.group.__ecComponentInfo = null;\n    } else {\n      i++;\n    }\n  }\n}\n/**\n * Processor data in each series\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction processData(ecModel, api) {\n  each(dataProcessorFuncs, function (process) {\n    process.func(ecModel, api);\n  });\n}\n/**\n * @private\n */\n\n\nfunction stackSeriesData(ecModel) {\n  var stackedDataMap = {};\n  ecModel.eachSeries(function (series) {\n    var stack = series.get('stack');\n    var data = series.getData();\n\n    if (stack && data.type === 'list') {\n      var previousStack = stackedDataMap[stack]; // Avoid conflict with Object.prototype\n\n      if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n        data.stackedOn = previousStack;\n      }\n\n      stackedDataMap[stack] = data;\n    }\n  });\n}\n/**\n * Layout before each chart render there series, special visual encoding stage\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction doLayout(ecModel, payload) {\n  var api = this._api;\n  each(visualFuncs, function (visual) {\n    if (visual.isLayout) {\n      visual.func(ecModel, api, payload);\n    }\n  });\n}\n/**\n * Encode visual infomation from data after data processing\n *\n * @param {module:echarts/model/Global} ecModel\n * @param {object} layout\n * @param {boolean} [excludesLayout]\n * @private\n */\n\n\nfunction doVisualEncoding(ecModel, payload, excludesLayout) {\n  var api = this._api;\n  ecModel.clearColorPalette();\n  ecModel.eachSeries(function (seriesModel) {\n    seriesModel.clearColorPalette();\n  });\n  each(visualFuncs, function (visual) {\n    (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload);\n  });\n}\n/**\n * Render each chart and component\n * @private\n */\n\n\nfunction doRender(ecModel, payload) {\n  var api = this._api; // Render all components\n\n  each(this._componentsViews, function (componentView) {\n    var componentModel = componentView.__model;\n    componentView.render(componentModel, ecModel, api, payload);\n    updateZ(componentModel, componentView);\n  }, this);\n  each(this._chartsViews, function (chart) {\n    chart.__alive = false;\n  }, this); // Render all charts\n\n  ecModel.eachSeries(function (seriesModel, idx) {\n    var chartView = this._chartsMap[seriesModel.__viewId];\n    chartView.__alive = true;\n    chartView.render(seriesModel, ecModel, api, payload);\n    chartView.group.silent = !!seriesModel.get('silent');\n    updateZ(seriesModel, chartView);\n    updateProgressiveAndBlend(seriesModel, chartView);\n  }, this); // If use hover layer\n\n  updateHoverLayerStatus(this._zr, ecModel); // Remove groups of unrendered charts\n\n  each(this._chartsViews, function (chart) {\n    if (!chart.__alive) {\n      chart.remove(ecModel, api);\n    }\n  }, this);\n}\n\nvar MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];\n/**\n * @private\n */\n\nechartsProto._initEvents = function () {\n  each(MOUSE_EVENT_NAMES, function (eveName) {\n    this._zr.on(eveName, function (e) {\n      var ecModel = this.getModel();\n      var el = e.target;\n      var params; // no e.target when 'globalout'.\n\n      if (eveName === 'globalout') {\n        params = {};\n      } else if (el && el.dataIndex != null) {\n        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n      } // If element has custom eventData of components\n      else if (el && el.eventData) {\n          params = zrUtil.extend({}, el.eventData);\n        }\n\n      if (params) {\n        params.event = e;\n        params.type = eveName;\n        this.trigger(eveName, params);\n      }\n    }, this);\n  }, this);\n  each(eventActionMap, function (actionType, eventType) {\n    this._messageCenter.on(eventType, function (event) {\n      this.trigger(eventType, event);\n    }, this);\n  }, this);\n};\n/**\n * @return {boolean}\n */\n\n\nechartsProto.isDisposed = function () {\n  return this._disposed;\n};\n/**\n * Clear\n */\n\n\nechartsProto.clear = function () {\n  this.setOption({\n    series: []\n  }, true);\n};\n/**\n * Dispose instance\n */\n\n\nechartsProto.dispose = function () {\n  if (this._disposed) {\n    return;\n  }\n\n  this._disposed = true;\n  var api = this._api;\n  var ecModel = this._model;\n  each(this._componentsViews, function (component) {\n    component.dispose(ecModel, api);\n  });\n  each(this._chartsViews, function (chart) {\n    chart.dispose(ecModel, api);\n  }); // Dispose after all views disposed\n\n  this._zr.dispose();\n\n  delete instances[this.id];\n};\n\nzrUtil.mixin(ECharts, Eventful);\n\nfunction updateHoverLayerStatus(zr, ecModel) {\n  var storage = zr.storage;\n  var elCount = 0;\n  storage.traverse(function (el) {\n    if (!el.isGroup) {\n      elCount++;\n    }\n  });\n\n  if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n    storage.traverse(function (el) {\n      if (!el.isGroup) {\n        el.useHoverLayer = true;\n      }\n    });\n  }\n}\n/**\n * Update chart progressive and blend.\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\n\n\nfunction updateProgressiveAndBlend(seriesModel, chartView) {\n  // Progressive configuration\n  var elCount = 0;\n  chartView.group.traverse(function (el) {\n    if (el.type !== 'group' && !el.ignore) {\n      elCount++;\n    }\n  });\n  var frameDrawNum = +seriesModel.get('progressive');\n  var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\n  if (needProgressive) {\n    chartView.group.traverse(function (el) {\n      // FIXME marker and other components\n      if (!el.isGroup) {\n        el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\n        if (needProgressive) {\n          el.stopAnimation(true);\n        }\n      }\n    });\n  } // Blend configration\n\n\n  var blendMode = seriesModel.get('blendMode') || null;\n  chartView.group.traverse(function (el) {\n    // FIXME marker and other components\n    if (!el.isGroup) {\n      el.setStyle('blend', blendMode);\n    }\n  });\n}\n/**\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\n\n\nfunction updateZ(model, view) {\n  var z = model.get('z');\n  var zlevel = model.get('zlevel'); // Set z and zlevel\n\n  view.group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n    }\n  });\n}\n\nfunction createExtensionAPI(ecInstance) {\n  var coordSysMgr = ecInstance._coordSysMgr;\n  return zrUtil.extend(new ExtensionAPI(ecInstance), {\n    // Inject methods\n    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),\n    getComponentByElement: function (el) {\n      while (el) {\n        var modelInfo = el.__ecComponentInfo;\n\n        if (modelInfo != null) {\n          return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n        }\n\n        el = el.parent;\n      }\n    }\n  });\n}\n/**\n * @type {Object} key: actionType.\n * @inner\n */\n\n\nvar actions = {};\n/**\n * Map eventType to actionType\n * @type {Object}\n */\n\nvar eventActionMap = {};\n/**\n * Data processor functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\n\nvar dataProcessorFuncs = [];\n/**\n * @type {Array.<Function>}\n * @inner\n */\n\nvar optionPreprocessorFuncs = [];\n/**\n * @type {Array.<Function>}\n * @inner\n */\n\nvar postUpdateFuncs = [];\n/**\n * Visual encoding functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\n\nvar visualFuncs = [];\n/**\n * Theme storage\n * @type {Object.<key, Object>}\n */\n\nvar themeStorage = {};\n/**\n * Loading effects\n */\n\nvar loadingEffects = {};\nvar instances = {};\nvar connectedGroups = {};\nvar idBase = new Date() - 0;\nvar groupIdBase = new Date() - 0;\nvar DOM_ATTRIBUTE_KEY = '_echarts_instance_';\nvar mapDataStores = {};\n\nfunction enableConnect(chart) {\n  var STATUS_PENDING = 0;\n  var STATUS_UPDATING = 1;\n  var STATUS_UPDATED = 2;\n  var STATUS_KEY = '__connectUpdateStatus';\n\n  function updateConnectedChartsStatus(charts, status) {\n    for (var i = 0; i < charts.length; i++) {\n      var otherChart = charts[i];\n      otherChart[STATUS_KEY] = status;\n    }\n  }\n\n  zrUtil.each(eventActionMap, function (actionType, eventType) {\n    chart._messageCenter.on(eventType, function (event) {\n      if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n        if (event && event.escapeConnect) {\n          return;\n        }\n\n        var action = chart.makeActionFromEvent(event);\n        var otherCharts = [];\n        zrUtil.each(instances, function (otherChart) {\n          if (otherChart !== chart && otherChart.group === chart.group) {\n            otherCharts.push(otherChart);\n          }\n        });\n        updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n        each(otherCharts, function (otherChart) {\n          if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n            otherChart.dispatchAction(action);\n          }\n        });\n        updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n      }\n    });\n  });\n}\n/**\n * @param {HTMLElement} dom\n * @param {Object} [theme]\n * @param {Object} opts\n * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n *                              Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n *                               Can be 'auto' (the same as null/undefined)\n */\n\n\nfunction init(dom, theme, opts) {\n  var existInstance = getInstanceByDom(dom);\n\n  if (existInstance) {\n    return existInstance;\n  }\n\n  var chart = new ECharts(dom, theme, opts);\n  chart.id = 'ec_' + idBase++;\n  instances[chart.id] = chart;\n\n  if (dom.setAttribute) {\n    dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n  } else {\n    dom[DOM_ATTRIBUTE_KEY] = chart.id;\n  }\n\n  enableConnect(chart);\n  return chart;\n}\n/**\n * @return {string|Array.<module:echarts~ECharts>} groupId\n */\n\n\nfunction connect(groupId) {\n  // Is array of charts\n  if (zrUtil.isArray(groupId)) {\n    var charts = groupId;\n    groupId = null; // If any chart has group\n\n    zrUtil.each(charts, function (chart) {\n      if (chart.group != null) {\n        groupId = chart.group;\n      }\n    });\n    groupId = groupId || 'g_' + groupIdBase++;\n    zrUtil.each(charts, function (chart) {\n      chart.group = groupId;\n    });\n  }\n\n  connectedGroups[groupId] = true;\n  return groupId;\n}\n/**\n * @DEPRECATED\n * @return {string} groupId\n */\n\n\nfunction disConnect(groupId) {\n  connectedGroups[groupId] = false;\n}\n/**\n * @return {string} groupId\n */\n\n\nvar disconnect = disConnect;\n/**\n * Dispose a chart instance\n * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n */\n\nfunction dispose(chart) {\n  if (typeof chart === 'string') {\n    chart = instances[chart];\n  } else if (!(chart instanceof ECharts)) {\n    // Try to treat as dom\n    chart = getInstanceByDom(chart);\n  }\n\n  if (chart instanceof ECharts && !chart.isDisposed()) {\n    chart.dispose();\n  }\n}\n/**\n * @param  {HTMLElement} dom\n * @return {echarts~ECharts}\n */\n\n\nfunction getInstanceByDom(dom) {\n  var key;\n\n  if (dom.getAttribute) {\n    key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n  } else {\n    key = dom[DOM_ATTRIBUTE_KEY];\n  }\n\n  return instances[key];\n}\n/**\n * @param {string} key\n * @return {echarts~ECharts}\n */\n\n\nfunction getInstanceById(key) {\n  return instances[key];\n}\n/**\n * Register theme\n */\n\n\nfunction registerTheme(name, theme) {\n  themeStorage[name] = theme;\n}\n/**\n * Register option preprocessor\n * @param {Function} preprocessorFunc\n */\n\n\nfunction registerPreprocessor(preprocessorFunc) {\n  optionPreprocessorFuncs.push(preprocessorFunc);\n}\n/**\n * @param {number} [priority=1000]\n * @param {Function} processorFunc\n */\n\n\nfunction registerProcessor(priority, processorFunc) {\n  if (typeof priority === 'function') {\n    processorFunc = priority;\n    priority = PRIORITY_PROCESSOR_FILTER;\n  }\n\n  dataProcessorFuncs.push({\n    prio: priority,\n    func: processorFunc\n  });\n}\n/**\n * Register postUpdater\n * @param {Function} postUpdateFunc\n */\n\n\nfunction registerPostUpdate(postUpdateFunc) {\n  postUpdateFuncs.push(postUpdateFunc);\n}\n/**\n * Usage:\n * registerAction('someAction', 'someEvent', function () { ... });\n * registerAction('someAction', function () { ... });\n * registerAction(\n *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n *     function () { ... }\n * );\n *\n * @param {(string|Object)} actionInfo\n * @param {string} actionInfo.type\n * @param {string} [actionInfo.event]\n * @param {string} [actionInfo.update]\n * @param {string} [eventName]\n * @param {Function} action\n */\n\n\nfunction registerAction(actionInfo, eventName, action) {\n  if (typeof eventName === 'function') {\n    action = eventName;\n    eventName = '';\n  }\n\n  var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {\n    event: eventName\n  }][0]; // Event name is all lowercase\n\n  actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n  eventName = actionInfo.event; // Validate action type and event name.\n\n  zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n  if (!actions[actionType]) {\n    actions[actionType] = {\n      action: action,\n      actionInfo: actionInfo\n    };\n  }\n\n  eventActionMap[eventName] = actionType;\n}\n/**\n * @param {string} type\n * @param {*} CoordinateSystem\n */\n\n\nfunction registerCoordinateSystem(type, CoordinateSystem) {\n  CoordinateSystemManager.register(type, CoordinateSystem);\n}\n/**\n * Get dimensions of specified coordinate system.\n * @param {string} type\n * @return {Array.<string|Object>}\n */\n\n\nfunction getCoordinateSystemDimensions(type) {\n  var coordSysCreator = CoordinateSystemManager.get(type);\n\n  if (coordSysCreator) {\n    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();\n  }\n}\n/**\n * Layout is a special stage of visual encoding\n * Most visual encoding like color are common for different chart\n * But each chart has it's own layout algorithm\n *\n * @param {number} [priority=1000]\n * @param {Function} layoutFunc\n */\n\n\nfunction registerLayout(priority, layoutFunc) {\n  if (typeof priority === 'function') {\n    layoutFunc = priority;\n    priority = PRIORITY_VISUAL_LAYOUT;\n  }\n\n  visualFuncs.push({\n    prio: priority,\n    func: layoutFunc,\n    isLayout: true\n  });\n}\n/**\n * @param {number} [priority=3000]\n * @param {Function} visualFunc\n */\n\n\nfunction registerVisual(priority, visualFunc) {\n  if (typeof priority === 'function') {\n    visualFunc = priority;\n    priority = PRIORITY_VISUAL_CHART;\n  }\n\n  visualFuncs.push({\n    prio: priority,\n    func: visualFunc\n  });\n}\n/**\n * @param {string} name\n */\n\n\nfunction registerLoading(name, loadingFx) {\n  loadingEffects[name] = loadingFx;\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendComponentModel(opts\n/*, superClass*/\n) {\n  // var Clazz = ComponentModel;\n  // if (superClass) {\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n  // }\n  return ComponentModel.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendComponentView(opts\n/*, superClass*/\n) {\n  // var Clazz = ComponentView;\n  // if (superClass) {\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n  // }\n  return ComponentView.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendSeriesModel(opts\n/*, superClass*/\n) {\n  // var Clazz = SeriesModel;\n  // if (superClass) {\n  //     superClass = 'series.' + superClass.replace('series.', '');\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n  // }\n  return SeriesModel.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendChartView(opts\n/*, superClass*/\n) {\n  // var Clazz = ChartView;\n  // if (superClass) {\n  //     superClass = superClass.replace('series.', '');\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ChartView.getClass(classType.main, true);\n  // }\n  return ChartView.extend(opts);\n}\n/**\n * ZRender need a canvas context to do measureText.\n * But in node environment canvas may be created by node-canvas.\n * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n *\n * Be careful of using it in the browser.\n *\n * @param {Function} creator\n * @example\n *     var Canvas = require('canvas');\n *     var echarts = require('echarts');\n *     echarts.setCanvasCreator(function () {\n *         // Small size is enough.\n *         return new Canvas(32, 32);\n *     });\n */\n\n\nfunction setCanvasCreator(creator) {\n  zrUtil.$override('createCanvas', creator);\n}\n/**\n * @param {string} mapName\n * @param {Object|string} geoJson\n * @param {Object} [specialAreas]\n *\n * @example\n *     $.get('USA.json', function (geoJson) {\n *         echarts.registerMap('USA', geoJson);\n *         // Or\n *         echarts.registerMap('USA', {\n *             geoJson: geoJson,\n *             specialAreas: {}\n *         })\n *     });\n */\n\n\nfunction registerMap(mapName, geoJson, specialAreas) {\n  if (geoJson.geoJson && !geoJson.features) {\n    specialAreas = geoJson.specialAreas;\n    geoJson = geoJson.geoJson;\n  }\n\n  if (typeof geoJson === 'string') {\n    geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();\n  }\n\n  mapDataStores[mapName] = {\n    geoJson: geoJson,\n    specialAreas: specialAreas\n  };\n}\n/**\n * @param {string} mapName\n * @return {Object}\n */\n\n\nfunction getMap(mapName) {\n  return mapDataStores[mapName];\n}\n\nregisterVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);\nregisterPreprocessor(backwardCompat);\nregisterLoading('default', loadingDefault); // Default actions\n\nregisterAction({\n  type: 'highlight',\n  event: 'highlight',\n  update: 'highlight'\n}, zrUtil.noop);\nregisterAction({\n  type: 'downplay',\n  event: 'downplay',\n  update: 'downplay'\n}, zrUtil.noop); // For backward compatibility, where the namespace `dataTool` will\n// be mounted on `echarts` is the extension `dataTool` is imported.\n\nvar dataTool = {};\nexports.version = version;\nexports.dependencies = dependencies;\nexports.PRIORITY = PRIORITY;\nexports.init = init;\nexports.connect = connect;\nexports.disConnect = disConnect;\nexports.disconnect = disconnect;\nexports.dispose = dispose;\nexports.getInstanceByDom = getInstanceByDom;\nexports.getInstanceById = getInstanceById;\nexports.registerTheme = registerTheme;\nexports.registerPreprocessor = registerPreprocessor;\nexports.registerProcessor = registerProcessor;\nexports.registerPostUpdate = registerPostUpdate;\nexports.registerAction = registerAction;\nexports.registerCoordinateSystem = registerCoordinateSystem;\nexports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;\nexports.registerLayout = registerLayout;\nexports.registerVisual = registerVisual;\nexports.registerLoading = registerLoading;\nexports.extendComponentModel = extendComponentModel;\nexports.extendComponentView = extendComponentView;\nexports.extendSeriesModel = extendSeriesModel;\nexports.extendChartView = extendChartView;\nexports.setCanvasCreator = setCanvasCreator;\nexports.registerMap = registerMap;\nexports.getMap = getMap;\nexports.dataTool = dataTool;\nvar ___ec_export = __webpack_require__(946);\n(function () {\n    for (var key in ___ec_export) {\n        if (___ec_export.hasOwnProperty(key)) {\n            exports[key] = ___ec_export[key];\n        }\n    }\n})();\n\n/***/ }),\n\n/***/ 810:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar RADIAN_EPSILON = 1e-4;\n\nfunction _trim(str) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n/**\n * Linear mapping a value from domain to range\n * @memberOf module:echarts/util/number\n * @param  {(number|Array.<number>)} val\n * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n * @param  {boolean} clamp\n * @return {(number|Array.<number>}\n */\n\n\nfunction linearMap(val, domain, range, clamp) {\n  var subDomain = domain[1] - domain[0];\n  var subRange = range[1] - range[0];\n\n  if (subDomain === 0) {\n    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n  } // Avoid accuracy problem in edge, such as\n  // 146.39 - 62.83 === 83.55999999999999.\n  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n  // It is a little verbose for efficiency considering this method\n  // is a hotspot.\n\n\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= domain[0]) {\n        return range[0];\n      } else if (val >= domain[1]) {\n        return range[1];\n      }\n    } else {\n      if (val >= domain[0]) {\n        return range[0];\n      } else if (val <= domain[1]) {\n        return range[1];\n      }\n    }\n  } else {\n    if (val === domain[0]) {\n      return range[0];\n    }\n\n    if (val === domain[1]) {\n      return range[1];\n    }\n  }\n\n  return (val - domain[0]) / subDomain * subRange + range[0];\n}\n/**\n * Convert a percent string to absolute number.\n * Returns NaN if percent is not a valid string or number\n * @memberOf module:echarts/util/number\n * @param {string|number} percent\n * @param {number} all\n * @return {number}\n */\n\n\nfunction parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n\n  if (typeof percent === 'string') {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n\n    return parseFloat(percent);\n  }\n\n  return percent == null ? NaN : +percent;\n}\n/**\n * (1) Fix rounding error of float numbers.\n * (2) Support return string to avoid scientific notation like '3.5e-7'.\n *\n * @param {number} x\n * @param {number} [precision]\n * @param {boolean} [returnStr]\n * @return {number|string}\n */\n\n\nfunction round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  } // Avoid range error\n\n\n  precision = Math.min(Math.max(0, precision), 20);\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\n\nfunction asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\n/**\n * Get precision\n * @param {number} val\n */\n\n\nfunction getPrecision(val) {\n  val = +val;\n\n  if (isNaN(val)) {\n    return 0;\n  } // It is much faster than methods converting number to string as follows\n  //      var tmp = val.toString();\n  //      return tmp.length - 1 - tmp.indexOf('.');\n  // especially when precision is low\n\n\n  var e = 1;\n  var count = 0;\n\n  while (Math.round(val * e) / e !== val) {\n    e *= 10;\n    count++;\n  }\n\n  return count;\n}\n/**\n * @param {string|number} val\n * @return {number}\n */\n\n\nfunction getPrecisionSafe(val) {\n  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'\n\n  var eIndex = str.indexOf('e');\n\n  if (eIndex > 0) {\n    var precision = +str.slice(eIndex + 1);\n    return precision < 0 ? -precision : 0;\n  } else {\n    var dotIndex = str.indexOf('.');\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n  }\n}\n/**\n * Minimal dicernible data precisioin according to a single pixel.\n *\n * @param {Array.<number>} dataExtent\n * @param {Array.<number>} pixelExtent\n * @return {number} precision\n */\n\n\nfunction getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.\n\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\n/**\n * Get a data of given precision, assuring the sum of percentages\n * in valueList is 1.\n * The largest remainer method is used.\n * https://en.wikipedia.org/wiki/Largest_remainder_method\n *\n * @param {Array.<number>} valueList a list of all data\n * @param {number} idx index of the data to be processed in valueList\n * @param {number} precision integer number showing digits of precision\n * @return {number} percent ranging from 0 to 100\n */\n\n\nfunction getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n\n  var sum = zrUtil.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n\n  if (sum === 0) {\n    return 0;\n  }\n\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrUtil.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrUtil.map(votesPerQuota, function (votes) {\n    // Assign automatic seats.\n    return Math.floor(votes);\n  });\n  var currentSum = zrUtil.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  }); // Has remainding votes.\n\n  while (currentSum < targetSeats) {\n    // Find next largest remainder.\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    } // Add a vote to max remainder.\n\n\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n\n  return seats[idx] / digits;\n} // Number.MAX_SAFE_INTEGER, ie do not support.\n\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * To 0 - 2 * PI, considering negative radian.\n * @param {number} radian\n * @return {number}\n */\n\nfunction remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\n/**\n * @param {type} radian\n * @return {boolean}\n */\n\n\nfunction isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n/**\n * @param {string|Date|number} value These values can be accepted:\n *   + An instance of Date, represent a time in its own time zone.\n *   + Or string in a subset of ISO 8601, only including:\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n *     all of which will be treated as local time if time zone is not specified\n *     (see <https://momentjs.com/>).\n *   + Or other string format, including (all of which will be treated as loacal time):\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n *   + a timestamp, which represent a time in UTC.\n * @return {Date} date\n */\n\nfunction parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (typeof value === 'string') {\n    // Different browsers parse date in different way, so we parse it manually.\n    // Some other issues:\n    // new Date('1970-01-01') is UTC,\n    // new Date('1970/01/01') and new Date('1970-1-01') is local.\n    // See issue #3623\n    var match = TIME_REG.exec(value);\n\n    if (!match) {\n      // return Invalid Date.\n      return new Date(NaN);\n    } // Use local time when no timezone offset specifed.\n\n\n    if (!match[8]) {\n      // match[n] can only be string or undefined.\n      // But take care of '12' + 1 => '121'.\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n    // For example, system timezone is set as \"Time Zone: America/Toronto\",\n    // then these code will get different result:\n    // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n    // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n    // So we should not use `new Date`, but use `Date.UTC`.\n    else {\n        var hour = +match[4] || 0;\n\n        if (match[8].toUpperCase() !== 'Z') {\n          hour -= match[8].slice(0, 3);\n        }\n\n        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n      }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n\n  return new Date(Math.round(value));\n}\n/**\n * Quantity of a number. e.g. 0.1, 1, 10, 100\n *\n * @param  {number} val\n * @return {number}\n */\n\n\nfunction quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\n\nfunction quantityExponent(val) {\n  return Math.floor(Math.log(val) / Math.LN10);\n}\n/**\n * find a nice number approximately equal to x. Round the number if round = true,\n * take ceiling if round = false. The primary observation is that the nicest\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n *\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n *\n * @param  {number} val Non-negative value.\n * @param  {boolean} round\n * @return {number}\n */\n\n\nfunction nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10; // 1 <= f < 10\n\n  var nf;\n\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n\n  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n  // 20 is the uppper bound of toFixed.\n\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n/**\n * Order intervals asc, and split them when overlap.\n * expect(numberUtil.reformIntervals([\n *     {interval: [18, 62], close: [1, 1]},\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [1, 1]},\n *     {interval: [62, 150], close: [1, 1]},\n *     {interval: [106, 150], close: [1, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ])).toEqual([\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [0, 1]},\n *     {interval: [18, 62], close: [0, 1]},\n *     {interval: [62, 150], close: [0, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ]);\n * @param {Array.<Object>} list, where `close` mean open or close\n *        of the interval, and Infinity can be used.\n * @return {Array.<Object>} The origin list, which has been reformed.\n */\n\n\nfunction reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close = list[i].close;\n\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close[lg] = !lg ? 1 - currClose : 1;\n      }\n\n      curr = interval[lg];\n      currClose = close[lg];\n    }\n\n    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  return list;\n\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\n/**\n * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n * subtraction forces infinities to NaN\n *\n * @param {*} v\n * @return {boolean}\n */\n\n\nfunction isNumeric(v) {\n  return v - parseFloat(v) >= 0;\n}\n\nexports.linearMap = linearMap;\nexports.parsePercent = parsePercent;\nexports.round = round;\nexports.asc = asc;\nexports.getPrecision = getPrecision;\nexports.getPrecisionSafe = getPrecisionSafe;\nexports.getPixelPrecision = getPixelPrecision;\nexports.getPercentWithPrecision = getPercentWithPrecision;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nexports.remRadian = remRadian;\nexports.isRadianAroundZero = isRadianAroundZero;\nexports.parseDate = parseDate;\nexports.quantity = quantity;\nexports.nice = nice;\nexports.reformIntervals = reformIntervals;\nexports.isNumeric = isNumeric;\n\n/***/ }),\n\n/***/ 811:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar formatUtil = __webpack_require__(822);\n\nvar nubmerUtil = __webpack_require__(810);\n\nvar Model = __webpack_require__(823);\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *         normal: {\n *             show: false,\n *             position: 'outside',\n *             fontSize: 18\n *         },\n *         emphasis: {\n *             show: true\n *         }\n *     }\n * @param {Object} opt\n * @param {Array.<string>} subOpts\n */\n\n\nfunction defaultEmphasis(opt, subOpts) {\n  if (opt) {\n    var emphasisOpt = opt.emphasis = opt.emphasis || {};\n    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {\n        emphasisOpt[subOptName] = normalOpt[subOptName];\n      }\n    }\n  }\n}\n\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n * @param {string|number|Date|Array|Object} dataItem\n * @return {number|string|Date|Array.<number|string|Date>}\n */\n\nfunction getDataItemValue(dataItem) {\n  // Performance sensitive.\n  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n * @param {string|number|Date|Array|Object} dataItem\n */\n\n\nfunction isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n/**\n * This helper method convert value in data.\n * @param {string|number|Date} value\n * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n */\n\n\nfunction converDataValue(value, dimInfo) {\n  // Performance sensitive.\n  var dimType = dimInfo && dimInfo.type;\n\n  if (dimType === 'ordinal') {\n    return value;\n  }\n\n  if (dimType === 'time' // spead up when using timestamp\n  && typeof value !== 'number' && value != null && value !== '-') {\n    value = +nubmerUtil.parseDate(value);\n  } // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n\n\n  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n}\n/**\n * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n * @param {module:echarts/data/List} data\n * @param {Object} opt\n * @param {string} [opt.seriesIndex]\n * @param {Object} [opt.name]\n * @param {Object} [opt.mainType]\n * @param {Object} [opt.subType]\n */\n\n\nfunction createDataFormatModel(data, opt) {\n  var model = new Model();\n  zrUtil.mixin(model, dataFormatMixin);\n  model.seriesIndex = opt.seriesIndex;\n  model.name = opt.name || '';\n  model.mainType = opt.mainType;\n  model.subType = opt.subType;\n\n  model.getData = function () {\n    return data;\n  };\n\n  return model;\n} // PENDING A little ugly\n\n\nvar dataFormatMixin = {\n  /**\n   * Get params for formatter\n   * @param {number} dataIndex\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex, dataType) {\n    var data = this.getData(dataType);\n    var rawValue = this.getRawValue(dataIndex, dataType);\n    var rawDataIndex = data.getRawIndex(dataIndex);\n    var name = data.getName(dataIndex, true);\n    var itemOpt = data.getRawDataItem(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n    return {\n      componentType: this.mainType,\n      componentSubType: this.subType,\n      seriesType: this.mainType === 'series' ? this.subType : null,\n      seriesIndex: this.seriesIndex,\n      seriesId: this.id,\n      seriesName: this.name,\n      name: name,\n      dataIndex: rawDataIndex,\n      data: itemOpt,\n      dataType: dataType,\n      value: rawValue,\n      color: color,\n      marker: formatUtil.getTooltipMarker(color),\n      // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n      $vars: ['seriesName', 'name', 'value']\n    };\n  },\n\n  /**\n   * Format label\n   * @param {number} dataIndex\n   * @param {string} [status='normal'] 'normal' or 'emphasis'\n   * @param {string} [dataType]\n   * @param {number} [dimIndex]\n   * @param {string} [labelProp='label']\n   * @return {string}\n   */\n  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n    status = status || 'normal';\n    var data = this.getData(dataType);\n    var itemModel = data.getItemModel(dataIndex);\n    var params = this.getDataParams(dataIndex, dataType);\n\n    if (dimIndex != null && params.value instanceof Array) {\n      params.value = params.value[dimIndex];\n    }\n\n    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n    if (typeof formatter === 'function') {\n      params.status = status;\n      return formatter(params);\n    } else if (typeof formatter === 'string') {\n      return formatUtil.formatTpl(formatter, params);\n    }\n  },\n\n  /**\n   * Get raw value in option\n   * @param {number} idx\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getRawValue: function (idx, dataType) {\n    var data = this.getData(dataType);\n    var dataItem = data.getRawDataItem(idx);\n\n    if (dataItem != null) {\n      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n    }\n  },\n\n  /**\n   * Should be implemented.\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   * @return {string} tooltip string\n   */\n  formatTooltip: zrUtil.noop\n};\n/**\n * Mapping to exists for merge.\n *\n * @public\n * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n * @param {Object|Array.<Object>} newCptOptions\n * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          index of which is the same as exists.\n */\n\nfunction mappingToExists(exists, newCptOptions) {\n  // Mapping by the order by original option (but not order of\n  // new option) in merge mode. Because we should ensure\n  // some specified index (like xAxisIndex) is consistent with\n  // original option, which is easy to understand, espatially in\n  // media query. And in most case, merge option is used to\n  // update partial option but not be expected to change order.\n  newCptOptions = (newCptOptions || []).slice();\n  var result = zrUtil.map(exists || [], function (obj, index) {\n    return {\n      exist: obj\n    };\n  }); // Mapping by id or name if specified.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    } // id has highest priority.\n\n\n    for (var i = 0; i < result.length; i++) {\n      if (!result[i].option // Consider name: two map to one.\n      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Consider name: two map to one.\n      // Can not match when both ids exist but different.\n      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n  }); // Otherwise mapping by index.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    }\n\n    var i = 0;\n\n    for (; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Existing model that already has id should be able to\n      // mapped to (because after mapping performed model may\n      // be assigned with a id, whish should not affect next\n      // mapping), except those has inner id.\n      && !isIdInner(exist) // Caution:\n      // Do not overwrite id. But name can be overwritten,\n      // because axis use name as 'show label text'.\n      // 'exist' always has id and name and we dont\n      // need to check it.\n      && cptOption.id == null) {\n        result[i].option = cptOption;\n        break;\n      }\n    }\n\n    if (i >= result.length) {\n      result.push({\n        option: cptOption\n      });\n    }\n  });\n  return result;\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n *\n * @public\n * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          which order is the same as exists.\n * @return {Array.<Object>} The input.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = zrUtil.createHashMap();\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    existCpt && idMap.set(existCpt.id, item);\n  });\n  each(mapResult, function (item, index) {\n    var opt = item.option;\n    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    var opt = item.option;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\\0-'; // name may be displayed on screen, so use '-'.\n\n    if (existCpt) {\n      keyInfo.id = existCpt.id;\n    } else if (opt.id != null) {\n      keyInfo.id = opt.id + '';\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n/**\n * @public\n * @param {Object} cptOption\n * @return {boolean}\n */\n\n\nfunction isIdInner(cptOption) {\n  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n */\n\n\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = sourceBatch[i].seriesId;\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n */\n\n\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * var get = modelUitl.makeGetter();\n *\n * function some(hostObj) {\n *      get(hostObj)._someProperty = 1212;\n *      ...\n * }\n *\n * @return {Function}\n */\n\n\nvar makeGetter = function () {\n  var index = 0;\n  return function () {\n    var key = '\\0__ec_prop_getter_' + index++;\n    return function (hostObj) {\n      return hostObj[key] || (hostObj[key] = {});\n    };\n  };\n}();\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex, seriesId, seriesName,\n *            geoIndex, geoId, geoName,\n *            bmapIndex, bmapId, bmapName,\n *            xAxisIndex, xAxisId, xAxisName,\n *            yAxisIndex, yAxisId, yAxisName,\n *            gridIndex, gridId, gridName,\n *            ... (can be extended)\n *        }\n *        Each properties can be number|string|Array.<number>|Array.<string>\n *        For example, a finder could be\n *        {\n *            seriesIndex: 3,\n *            geoId: ['aa', 'cc'],\n *            gridName: ['xx', 'rr']\n *        }\n *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n *        If nothing or null/undefined specified, return nothing.\n * @param {Object} [opt]\n * @param {string} [opt.defaultMainType]\n * @param {Array.<string>} [opt.includeMainTypes]\n * @return {Object} result like:\n *        {\n *            seriesModels: [seriesModel1, seriesModel2],\n *            seriesModel: seriesModel1, // The first model\n *            geoModels: [geoModel1, geoModel2],\n *            geoModel: geoModel1, // The first model\n *            ...\n *        }\n */\n\n\nfunction parseFinder(ecModel, finder, opt) {\n  if (zrUtil.isString(finder)) {\n    var obj = {};\n    obj[finder + 'Index'] = 0;\n    finder = obj;\n  }\n\n  var defaultMainType = opt && opt.defaultMainType;\n\n  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {\n    finder[defaultMainType + 'Index'] = 0;\n  }\n\n  var result = {};\n  each(finder, function (value, key) {\n    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.\n\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      result[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    var queryParam = {\n      mainType: mainType\n    };\n\n    if (queryType !== 'index' || value !== 'all') {\n      queryParam[queryType] = value;\n    }\n\n    var models = ecModel.queryComponents(queryParam);\n    result[mainType + 'Models'] = models;\n    result[mainType + 'Model'] = models[0];\n  });\n  return result;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string|number} dataDim\n * @return {string}\n */\n\n\nfunction dataDimToCoordDim(data, dataDim) {\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} coordDim\n * @return {Array.<string>} data dimensions on the coordDim.\n */\n\n\nfunction coordDimToDataDim(data, coordDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n\n    if (dimItem.coordDim === coordDim) {\n      dataDim[dimItem.coordDimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} otherDim Can be `otherDims`\n *                        like 'label' or 'tooltip'.\n * @return {Array.<string>} data dimensions on the otherDim.\n */\n\n\nfunction otherDimToDataDim(data, otherDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var otherDims = dimItem.otherDims;\n    var dimIndex = otherDims[otherDim];\n\n    if (dimIndex != null && dimIndex !== false) {\n      dataDim[dimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n\nfunction has(obj, prop) {\n  return obj && obj.hasOwnProperty(prop);\n}\n\nexports.normalizeToArray = normalizeToArray;\nexports.defaultEmphasis = defaultEmphasis;\nexports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;\nexports.getDataItemValue = getDataItemValue;\nexports.isDataItemOption = isDataItemOption;\nexports.converDataValue = converDataValue;\nexports.createDataFormatModel = createDataFormatModel;\nexports.dataFormatMixin = dataFormatMixin;\nexports.mappingToExists = mappingToExists;\nexports.makeIdAndName = makeIdAndName;\nexports.isIdInner = isIdInner;\nexports.compressBatches = compressBatches;\nexports.queryDataIndex = queryDataIndex;\nexports.makeGetter = makeGetter;\nexports.parseFinder = parseFinder;\nexports.dataDimToCoordDim = dataDimToCoordDim;\nexports.coordDimToDataDim = coordDimToDataDim;\nexports.otherDimToDataDim = otherDimToDataDim;\n\n/***/ }),\n\n/***/ 812:\n/***/ (function(module, exports) {\n\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * \n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} \n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n\n/***/ }),\n\n/***/ 813:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Displayable = __webpack_require__(878);\n\nvar zrUtil = __webpack_require__(794);\n\nvar PathProxy = __webpack_require__(859);\n\nvar pathContain = __webpack_require__(979);\n\nvar Pattern = __webpack_require__(906);\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n *  Path element, \n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME  extend position, rotation \n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 819:\n/***/ (function(module, exports) {\n\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // canvas\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 820:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// (1) The code `if (__DEV__) ...` can be removed by build tool.\n// (2) If intend to use `__DEV__`, this module should be imported. Use a global\n// variable `__DEV__` may cause that miss the declaration (see #6535), or the\n// declaration is behind of the using position (for example in `Model.extent`,\n// And tools like rollup can not analysis the dependency if not import).\nvar dev; // In browser\n\nif (typeof window !== 'undefined') {\n  dev = window.__DEV__;\n} // In node\nelse if (typeof global !== 'undefined') {\n    dev = global.__DEV__;\n  }\n\nif (typeof dev === 'undefined') {\n  dev = true;\n}\n\nvar __DEV__ = dev;\nexports.__DEV__ = __DEV__;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n\n/***/ 821:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar vec2 = __webpack_require__(812);\n\nvar matrix = __webpack_require__(848);\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // \n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 822:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar textContain = __webpack_require__(844);\n\nvar numberUtil = __webpack_require__(810);\n\n/**\n * ,\n * @param {string|number} x\n * @return {string}\n */\nfunction addCommas(x) {\n  if (isNaN(x)) {\n    return '-';\n  }\n\n  x = (x + '').split('.');\n  return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n}\n/**\n * @param {string} str\n * @param {boolean} [upperCaseFirst=false]\n * @return {string} str\n */\n\n\nfunction toCamelCase(str, upperCaseFirst) {\n  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\n    return group1.toUpperCase();\n  });\n\n  if (upperCaseFirst && str) {\n    str = str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  return str;\n}\n\nvar normalizeCssArray = zrUtil.normalizeCssArray;\n\nfunction encodeHTML(source) {\n  return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n}\n\nvar TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\nvar wrapVar = function (varName, seriesIdx) {\n  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n};\n/**\n * Template formatter\n * @param {string} tpl\n * @param {Array.<Object>|Object} paramsList\n * @param {boolean} [encode=false]\n * @return {string}\n */\n\n\nfunction formatTpl(tpl, paramsList, encode) {\n  if (!zrUtil.isArray(paramsList)) {\n    paramsList = [paramsList];\n  }\n\n  var seriesLen = paramsList.length;\n\n  if (!seriesLen) {\n    return '';\n  }\n\n  var $vars = paramsList[0].$vars || [];\n\n  for (var i = 0; i < $vars.length; i++) {\n    var alias = TPL_VAR_ALIAS[i];\n    var val = wrapVar(alias, 0);\n    tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n  }\n\n  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n    for (var k = 0; k < $vars.length; k++) {\n      var val = paramsList[seriesIdx][$vars[k]];\n      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);\n    }\n  }\n\n  return tpl;\n}\n/**\n * simple Template formatter\n *\n * @param {string} tpl\n * @param {Object} param\n * @param {boolean} [encode=false]\n * @return {string}\n */\n\n\nfunction formatTplSimple(tpl, param, encode) {\n  zrUtil.each(param, function (value, key) {\n    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);\n  });\n  return tpl;\n}\n/**\n * @param {string} color\n * @param {string} [extraCssText]\n * @return {string}\n */\n\n\nfunction getTooltipMarker(color, extraCssText) {\n  return color ? '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>' : '';\n}\n/**\n * @param {string} str\n * @return {string}\n * @inner\n */\n\n\nvar s2d = function (str) {\n  return str < 10 ? '0' + str : str;\n};\n/**\n * ISO Date format\n * @param {string} tpl\n * @param {number} value\n * @param {boolean} [isUTC=false] Default in local time.\n *           see `module:echarts/scale/Time`\n *           and `module:echarts/util/number#parseDate`.\n * @inner\n */\n\n\nfunction formatTime(tpl, value, isUTC) {\n  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n    tpl = 'MM-dd\\nyyyy';\n  }\n\n  var date = numberUtil.parseDate(value);\n  var utc = isUTC ? 'UTC' : '';\n  var y = date['get' + utc + 'FullYear']();\n  var M = date['get' + utc + 'Month']() + 1;\n  var d = date['get' + utc + 'Date']();\n  var h = date['get' + utc + 'Hours']();\n  var m = date['get' + utc + 'Minutes']();\n  var s = date['get' + utc + 'Seconds']();\n  tpl = tpl.replace('MM', s2d(M)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n  return tpl;\n}\n/**\n * Capital first\n * @param {string} str\n * @return {string}\n */\n\n\nfunction capitalFirst(str) {\n  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n}\n\nvar truncateText = textContain.truncateText;\nvar getTextRect = textContain.getBoundingRect;\nexports.addCommas = addCommas;\nexports.toCamelCase = toCamelCase;\nexports.normalizeCssArray = normalizeCssArray;\nexports.encodeHTML = encodeHTML;\nexports.formatTpl = formatTpl;\nexports.formatTplSimple = formatTplSimple;\nexports.getTooltipMarker = getTooltipMarker;\nexports.formatTime = formatTime;\nexports.capitalFirst = capitalFirst;\nexports.truncateText = truncateText;\nexports.getTextRect = getTextRect;\n\n/***/ }),\n\n/***/ 823:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar env = __webpack_require__(819);\n\nvar clazzUtil = __webpack_require__(824);\n\nvar lineStyleMixin = __webpack_require__(955);\n\nvar areaStyleMixin = __webpack_require__(952);\n\nvar textStyleMixin = __webpack_require__(956);\n\nvar itemStyleMixin = __webpack_require__(954);\n\n/**\n * @module echarts/model/Model\n */\nvar mixin = zrUtil.mixin;\n/**\n * @alias module:echarts/model/Model\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} [parentModel]\n * @param {module:echarts/model/Global} [ecModel]\n */\n\nfunction Model(option, parentModel, ecModel) {\n  /**\n   * @type {module:echarts/model/Model}\n   * @readOnly\n   */\n  this.parentModel = parentModel;\n  /**\n   * @type {module:echarts/model/Global}\n   * @readOnly\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @type {Object}\n   * @protected\n   */\n\n  this.option = option; // Simple optimization\n  // if (this.init) {\n  //     if (arguments.length <= 4) {\n  //         this.init(option, parentModel, ecModel, extraOpt);\n  //     }\n  //     else {\n  //         this.init.apply(this, arguments);\n  //     }\n  // }\n}\n\nModel.prototype = {\n  constructor: Model,\n\n  /**\n   * Model \n   * @param {Object} option\n   */\n  init: null,\n\n  /**\n   *  Option merge\n   */\n  mergeOption: function (option) {\n    zrUtil.merge(this.option, option, true);\n  },\n\n  /**\n   * @param {string|Array.<string>} path\n   * @param {boolean} [ignoreParent=false]\n   * @return {*}\n   */\n  get: function (path, ignoreParent) {\n    if (path == null) {\n      return this.option;\n    }\n\n    return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));\n  },\n\n  /**\n   * @param {string} key\n   * @param {boolean} [ignoreParent=false]\n   * @return {*}\n   */\n  getShallow: function (key, ignoreParent) {\n    var option = this.option;\n    var val = option == null ? option : option[key];\n    var parentModel = !ignoreParent && getParent(this, key);\n\n    if (val == null && parentModel) {\n      val = parentModel.getShallow(key);\n    }\n\n    return val;\n  },\n\n  /**\n   * @param {string|Array.<string>} [path]\n   * @param {module:echarts/model/Model} [parentModel]\n   * @return {module:echarts/model/Model}\n   */\n  getModel: function (path, parentModel) {\n    var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));\n    var thisParentModel;\n    parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);\n    return new Model(obj, parentModel, this.ecModel);\n  },\n\n  /**\n   * If model has option\n   */\n  isEmpty: function () {\n    return this.option == null;\n  },\n  restoreData: function () {},\n  // Pending\n  clone: function () {\n    var Ctor = this.constructor;\n    return new Ctor(zrUtil.clone(this.option));\n  },\n  setReadOnly: function (properties) {\n    clazzUtil.setReadOnly(this, properties);\n  },\n  // If path is null/undefined, return null/undefined.\n  parsePath: function (path) {\n    if (typeof path === 'string') {\n      path = path.split('.');\n    }\n\n    return path;\n  },\n\n  /**\n   * @param {Function} getParentMethod\n   *        param {Array.<string>|string} path\n   *        return {module:echarts/model/Model}\n   */\n  customizeGetParent: function (getParentMethod) {\n    clazzUtil.set(this, 'getParent', getParentMethod);\n  },\n  isAnimationEnabled: function () {\n    if (!env.node) {\n      if (this.option.animation != null) {\n        return !!this.option.animation;\n      } else if (this.parentModel) {\n        return this.parentModel.isAnimationEnabled();\n      }\n    }\n  }\n};\n\nfunction doGet(obj, pathArr, parentModel) {\n  for (var i = 0; i < pathArr.length; i++) {\n    // Ignore empty\n    if (!pathArr[i]) {\n      continue;\n    } // obj could be number/string/... (like 0)\n\n\n    obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;\n\n    if (obj == null) {\n      break;\n    }\n  }\n\n  if (obj == null && parentModel) {\n    obj = parentModel.get(pathArr);\n  }\n\n  return obj;\n} // `path` can be null/undefined\n\n\nfunction getParent(model, path) {\n  var getParentMethod = clazzUtil.get(model, 'getParent');\n  return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n} // Enable Model.extend.\n\n\nclazzUtil.enableClassExtend(Model);\nmixin(Model, lineStyleMixin);\nmixin(Model, areaStyleMixin);\nmixin(Model, textStyleMixin);\nmixin(Model, itemStyleMixin);\nvar _default = Model;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 824:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar TYPE_DELIMITER = '.';\nvar IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\nvar MEMBER_PRIFIX = '\\0ec_\\0';\n/**\n * Hide private class member.\n * The same behavior as `host[name] = value;` (can be right-value)\n * @public\n */\n\nfunction set(host, name, value) {\n  return host[MEMBER_PRIFIX + name] = value;\n}\n/**\n * Hide private class member.\n * The same behavior as `host[name];`\n * @public\n */\n\n\nfunction get(host, name) {\n  return host[MEMBER_PRIFIX + name];\n}\n/**\n * For hidden private class member.\n * The same behavior as `host.hasOwnProperty(name);`\n * @public\n */\n\n\nfunction hasOwn(host, name) {\n  return host.hasOwnProperty(MEMBER_PRIFIX + name);\n}\n/**\n * Notice, parseClassType('') should returns {main: '', sub: ''}\n * @public\n */\n\n\nfunction parseClassType(componentType) {\n  var ret = {\n    main: '',\n    sub: ''\n  };\n\n  if (componentType) {\n    componentType = componentType.split(TYPE_DELIMITER);\n    ret.main = componentType[0] || '';\n    ret.sub = componentType[1] || '';\n  }\n\n  return ret;\n}\n/**\n * @public\n */\n\n\nfunction checkClassType(componentType) {\n  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType \"' + componentType + '\" illegal');\n}\n/**\n * @public\n */\n\n\nfunction enableClassExtend(RootClass, mandatoryMethods) {\n  RootClass.$constructor = RootClass;\n\n  RootClass.extend = function (proto) {\n    var superClass = this;\n\n    var ExtendedClass = function () {\n      if (!proto.$constructor) {\n        superClass.apply(this, arguments);\n      } else {\n        proto.$constructor.apply(this, arguments);\n      }\n    };\n\n    zrUtil.extend(ExtendedClass.prototype, proto);\n    ExtendedClass.extend = this.extend;\n    ExtendedClass.superCall = superCall;\n    ExtendedClass.superApply = superApply;\n    zrUtil.inherits(ExtendedClass, this);\n    ExtendedClass.superClass = superClass;\n    return ExtendedClass;\n  };\n} // superCall should have class info, which can not be fetch from 'this'.\n// Consider this case:\n// class A has method f,\n// class B inherits class A, overrides method f, f call superApply('f'),\n// class C inherits class B, do not overrides method f,\n// then when method of class C is called, dead loop occured.\n\n\nfunction superCall(context, methodName) {\n  var args = zrUtil.slice(arguments, 2);\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n\nfunction superApply(context, methodName, args) {\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n/**\n * @param {Object} entity\n * @param {Object} options\n * @param {boolean} [options.registerWhenExtend]\n * @public\n */\n\n\nfunction enableClassManagement(entity, options) {\n  options = options || {};\n  /**\n   * Component model classes\n   * key: componentType,\n   * value:\n   *     componentClass, when componentType is 'xxx'\n   *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n   * @type {Object}\n   */\n\n  var storage = {};\n\n  entity.registerClass = function (Clazz, componentType) {\n    if (componentType) {\n      checkClassType(componentType);\n      componentType = parseClassType(componentType);\n\n      if (!componentType.sub) {\n        storage[componentType.main] = Clazz;\n      } else if (componentType.sub !== IS_CONTAINER) {\n        var container = makeContainer(componentType);\n        container[componentType.sub] = Clazz;\n      }\n    }\n\n    return Clazz;\n  };\n\n  entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n    var Clazz = storage[componentMainType];\n\n    if (Clazz && Clazz[IS_CONTAINER]) {\n      Clazz = subType ? Clazz[subType] : null;\n    }\n\n    if (throwWhenNotFound && !Clazz) {\n      throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');\n    }\n\n    return Clazz;\n  };\n\n  entity.getClassesByMainType = function (componentType) {\n    componentType = parseClassType(componentType);\n    var result = [];\n    var obj = storage[componentType.main];\n\n    if (obj && obj[IS_CONTAINER]) {\n      zrUtil.each(obj, function (o, type) {\n        type !== IS_CONTAINER && result.push(o);\n      });\n    } else {\n      result.push(obj);\n    }\n\n    return result;\n  };\n\n  entity.hasClass = function (componentType) {\n    // Just consider componentType.main.\n    componentType = parseClassType(componentType);\n    return !!storage[componentType.main];\n  };\n  /**\n   * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n   */\n\n\n  entity.getAllClassMainTypes = function () {\n    var types = [];\n    zrUtil.each(storage, function (obj, type) {\n      types.push(type);\n    });\n    return types;\n  };\n  /**\n   * If a main type is container and has sub types\n   * @param  {string}  mainType\n   * @return {boolean}\n   */\n\n\n  entity.hasSubTypes = function (componentType) {\n    componentType = parseClassType(componentType);\n    var obj = storage[componentType.main];\n    return obj && obj[IS_CONTAINER];\n  };\n\n  entity.parseClassType = parseClassType;\n\n  function makeContainer(componentType) {\n    var container = storage[componentType.main];\n\n    if (!container || !container[IS_CONTAINER]) {\n      container = storage[componentType.main] = {};\n      container[IS_CONTAINER] = true;\n    }\n\n    return container;\n  }\n\n  if (options.registerWhenExtend) {\n    var originalExtend = entity.extend;\n\n    if (originalExtend) {\n      entity.extend = function (proto) {\n        var ExtendedClass = originalExtend.call(this, proto);\n        return entity.registerClass(ExtendedClass, proto.type);\n      };\n    }\n  }\n\n  return entity;\n}\n/**\n * @param {string|Array.<string>} properties\n */\n\n\nfunction setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11\n  // if (!zrUtil.isArray(properties)) {\n  //     properties = properties != null ? [properties] : [];\n  // }\n  // zrUtil.each(properties, function (prop) {\n  //     var value = obj[prop];\n  //     Object.defineProperty\n  //         && Object.defineProperty(obj, prop, {\n  //             value: value, writable: false\n  //         });\n  //     zrUtil.isArray(obj[prop])\n  //         && Object.freeze\n  //         && Object.freeze(obj[prop]);\n  // });\n}\n\nexports.set = set;\nexports.get = get;\nexports.hasOwn = hasOwn;\nexports.parseClassType = parseClassType;\nexports.enableClassExtend = enableClassExtend;\nexports.enableClassManagement = enableClassManagement;\nexports.setReadOnly = setReadOnly;\n\n/***/ }),\n\n/***/ 838:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Model = __webpack_require__(823);\n\nvar componentUtil = __webpack_require__(874);\n\nvar clazzUtil = __webpack_require__(824);\n\nvar layout = __webpack_require__(845);\n\nvar boxLayoutMixin = __webpack_require__(953);\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\nvar arrayPush = Array.prototype.push;\n/**\n * @alias module:echarts/model/Component\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {module:echarts/model/Model} ecModel\n */\n\nvar ComponentModel = Model.extend({\n  type: 'component',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  id: '',\n\n  /**\n   * @readOnly\n   */\n  name: '',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  mainType: '',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  subType: '',\n\n  /**\n   * @readOnly\n   * @type {number}\n   */\n  componentIndex: 0,\n\n  /**\n   * @type {Object}\n   * @protected\n   */\n  defaultOption: null,\n\n  /**\n   * @type {module:echarts/model/Global}\n   * @readOnly\n   */\n  ecModel: null,\n\n  /**\n   * key: componentType\n   * value:  Component model list, can not be null.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @readOnly\n   */\n  dependentModels: [],\n\n  /**\n   * @type {string}\n   * @readOnly\n   */\n  uid: null,\n\n  /**\n   * Support merge layout params.\n   * Only support 'box' now (left/right/top/bottom/width/height).\n   * @type {string|Object} Object can be {ignoreSize: true}\n   * @readOnly\n   */\n  layoutMode: null,\n  $constructor: function (option, parentModel, ecModel, extraOpt) {\n    Model.call(this, option, parentModel, ecModel, extraOpt);\n    this.uid = componentUtil.getUID('componentModel');\n  },\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n  },\n  mergeDefaultAndTheme: function (option, ecModel) {\n    var layoutMode = this.layoutMode;\n    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n    var themeModel = ecModel.getTheme();\n    zrUtil.merge(option, themeModel.get(this.mainType));\n    zrUtil.merge(option, this.getDefaultOption());\n\n    if (layoutMode) {\n      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  },\n  mergeOption: function (option, extraOpt) {\n    zrUtil.merge(this.option, option, true);\n    var layoutMode = this.layoutMode;\n\n    if (layoutMode) {\n      layout.mergeLayoutParam(this.option, option, layoutMode);\n    }\n  },\n  // Hooker after init or mergeOption\n  optionUpdated: function (newCptOption, isInit) {},\n  getDefaultOption: function () {\n    if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n      var optList = [];\n      var Class = this.constructor;\n\n      while (Class) {\n        var opt = Class.prototype.defaultOption;\n        opt && optList.push(opt);\n        Class = Class.superClass;\n      }\n\n      var defaultOption = {};\n\n      for (var i = optList.length - 1; i >= 0; i--) {\n        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n      }\n\n      clazzUtil.set(this, '__defaultOption', defaultOption);\n    }\n\n    return clazzUtil.get(this, '__defaultOption');\n  },\n  getReferringComponents: function (mainType) {\n    return this.ecModel.queryComponents({\n      mainType: mainType,\n      index: this.get(mainType + 'Index', true),\n      id: this.get(mainType + 'Id', true)\n    });\n  }\n}); // Reset ComponentModel.extend, add preConstruct.\n// clazzUtil.enableClassExtend(\n//     ComponentModel,\n//     function (option, parentModel, ecModel, extraOpt) {\n//         // Set dependentModels, componentIndex, name, id, mainType, subType.\n//         zrUtil.extend(this, extraOpt);\n//         this.uid = componentUtil.getUID('componentModel');\n//         // this.setReadOnly([\n//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n//         //     'dependentModels', 'componentIndex'\n//         // ]);\n//     }\n// );\n// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(ComponentModel, {\n  registerWhenExtend: true\n});\ncomponentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.\n\ncomponentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\nfunction getDependencies(componentType) {\n  var deps = [];\n  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n    arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n  }); // Ensure main type\n\n  return zrUtil.map(deps, function (type) {\n    return clazzUtil.parseClassType(type).main;\n  });\n}\n\nzrUtil.mixin(ComponentModel, boxLayoutMixin);\nvar _default = ComponentModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 844:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BoundingRect = __webpack_require__(821);\n\nvar imageHelper = __webpack_require__(880);\n\nvar _util = __webpack_require__(794);\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n\n/***/ }),\n\n/***/ 845:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar BoundingRect = __webpack_require__(821);\n\nvar _number = __webpack_require__(810);\n\nvar parsePercent = _number.parsePercent;\n\nvar formatUtil = __webpack_require__(822);\n\n// Layout helpers for each component positioning\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var position = child.position;\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    position[0] = x;\n    position[1] = y;\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nvar box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.x]\n * @param {number|string} [positionInfo.y]\n * @param {number|string} [positionInfo.x2]\n * @param {number|string} [positionInfo.y2]\n * @param {Object} containerRect {width, height}\n * @param {string|number} margin\n * @return {Object} {width, height}\n */\n\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.x, containerWidth);\n  var y = parsePercent(positionInfo.y, containerHeight);\n  var x2 = parsePercent(positionInfo.x2, containerWidth);\n  var y2 = parsePercent(positionInfo.y2, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width]\n * @param {number|string} [positionInfo.height]\n * @param {number|string} [positionInfo.aspect] Aspect is width / height\n * @param {Object} containerRect\n * @param {string|number} [margin]\n *\n * @return {module:zrender/core/BoundingRect}\n */\n\n\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n * @param {Object} containerRect\n * @param {string|number} margin\n * @param {Object} [opt]\n * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n * @param {Array.<number>} [opt.boundingMode='all']\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\n\nfunction positionElement(el, positionInfo, containerRect, margin, opt) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n\n  if (!h && !v) {\n    return;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  positionInfo = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransfrom),\n  // we can just only modify el.position to get final result.\n\n  var elPos = el.position;\n  var dx = h ? positionInfo.x - rect.x : 0;\n  var dy = v ? positionInfo.y - rect.y : 0;\n  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n}\n/**\n * @param {Object} option Contains some of the properties in HV_NAMES.\n * @param {number} hvIdx 0: horizontal; 1: vertical.\n */\n\n\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\n/**\n * Consider Case:\n * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         var inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param {Object} targetOption\n * @param {Object} newOption\n * @param {Object|string} [opt]\n * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n *  that width (or height) should not be calculated by left and right (or top and bottom).\n */\n\n\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  !zrUtil.isObject(opt) && (opt = {});\n  var ignoreSize = opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n        return newParams;\n      } else {\n        // Chose another param from targetOption by priority.\n        for (var i = 0; i < names.length; i++) {\n          var name = names[i];\n\n          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n            newParams[name] = targetOption[name];\n            break;\n          }\n        }\n\n        return newParams;\n      }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}\n\nexports.LOCATION_PARAMS = LOCATION_PARAMS;\nexports.HV_NAMES = HV_NAMES;\nexports.box = box;\nexports.vbox = vbox;\nexports.hbox = hbox;\nexports.getAvailableSize = getAvailableSize;\nexports.getLayoutRect = getLayoutRect;\nexports.positionElement = positionElement;\nexports.sizeCalculable = sizeCalculable;\nexports.mergeLayoutParam = mergeLayoutParam;\nexports.getLayoutParams = getLayoutParams;\nexports.copyLayoutParams = copyLayoutParams;\n\n/***/ }),\n\n/***/ 846:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar textContain = __webpack_require__(844);\n\nvar OrdinalScale = __webpack_require__(960);\n\nvar IntervalScale = __webpack_require__(873);\n\nvar Scale = __webpack_require__(856);\n\nvar numberUtil = __webpack_require__(810);\n\n__webpack_require__(961);\n\n__webpack_require__(959);\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = (model.get('data') || []).length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  }\n\n  return [min, max];\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {Array.<number>} tickCoords In axis self coordinate.\n * @param {Array.<string>} labels\n * @param {string} font\n * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.\n * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.\n * @return {number}\n */\n\n\nfunction getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {\n  var textSpaceTakenRect;\n  var autoLabelInterval = 0;\n  var accumulatedLabelInterval = 0;\n  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;\n  var step = 1;\n\n  if (labels.length > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.floor(labels.length / 40);\n  }\n\n  for (var i = 0; i < tickCoords.length; i += step) {\n    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n    rect.x += tickCoord * Math.cos(rotation);\n    rect.y += tickCoord * Math.sin(rotation); // Magic number\n\n    rect.width *= 1.3;\n    rect.height *= 1.3;\n\n    if (!textSpaceTakenRect) {\n      textSpaceTakenRect = rect.clone();\n    } // There is no space for current label;\n    else if (textSpaceTakenRect.intersect(rect)) {\n        accumulatedLabelInterval++;\n        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n      } else {\n        textSpaceTakenRect.union(rect); // Reset\n\n        accumulatedLabelInterval = 0;\n      }\n  }\n\n  if (autoLabelInterval === 0 && step > 1) {\n    return step;\n  }\n\n  return (autoLabelInterval + 1) * step - 1;\n}\n/**\n * @param {Object} axis\n * @param {Function} labelFormatter\n * @return {Array.<string>}\n */\n\n\nfunction getFormattedLabels(axis, labelFormatter) {\n  var scale = axis.scale;\n  var labels = scale.getTicksLabels();\n  var ticks = scale.getTicks();\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return zrUtil.map(labels, labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return zrUtil.map(ticks, function (tick, idx) {\n      return labelFormatter(getAxisRawValue(axis, tick), idx);\n    }, this);\n  } else {\n    return labels;\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.getAxisLabelInterval = getAxisLabelInterval;\nexports.getFormattedLabels = getFormattedLabels;\nexports.getAxisRawValue = getAxisRawValue;\n\n/***/ }),\n\n/***/ 847:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _vector = __webpack_require__(812);\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // \n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} \n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} \n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] \n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; //  t \n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} \n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out \n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; //  t \n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n\n/***/ }),\n\n/***/ 848:\n/***/ (function(module, exports) {\n\n/**\n * 3x2\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * \n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n\n/***/ }),\n\n/***/ 851:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Eventful = __webpack_require__(852);\n\nexports.Dispatcher = Eventful;\n\nvar env = __webpack_require__(819);\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * domtouch.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // \n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n\n/***/ }),\n\n/***/ 852:\n/***/ (function(module, exports) {\n\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * \n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * trigger\n   *\n   * @param {string} event \n   * @param {Function} handler \n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * \n   * @param {string} event \n   * @param {Function} handler \n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * \n   * @param {string} event \n   * @param {Function} [handler] \n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   *\n   * @param {string} type \n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * context, context\n   * @param {string} type \n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; //  onxxxx \n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 853:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar LRU = __webpack_require__(901);\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n\n/***/ }),\n\n/***/ 854:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Model = __webpack_require__(823);\n\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    labelOption.show = true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n/***/ }),\n\n/***/ 855:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar Model = __webpack_require__(823);\n\nvar DataDiffer = __webpack_require__(945);\n\nvar modelUtil = __webpack_require__(811);\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar globalObj = typeof window === UNDEFINED ? global : window;\nvar dataCtors = {\n  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,\n  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];\n\nfunction transferProperties(a, b) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n    if (b.hasOwnProperty(propName)) {\n      a[propName] = b[propName];\n    }\n  });\n  a.__wrappedMethods = b.__wrappedMethods;\n}\n\nfunction DefaultDataProvider(dataArray) {\n  this._array = dataArray || [];\n}\n\nDefaultDataProvider.prototype.pure = false;\n\nDefaultDataProvider.prototype.count = function () {\n  return this._array.length;\n};\n\nDefaultDataProvider.prototype.getItem = function (idx) {\n  return this._array[idx];\n};\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimensionName;\n    var dimensionInfo = {};\n\n    if (typeof dimensions[i] === 'string') {\n      dimensionName = dimensions[i];\n      dimensionInfo = {\n        name: dimensionName,\n        coordDim: dimensionName,\n        coordDimIndex: 0,\n        stackable: false,\n        // Type can be 'float', 'int', 'number'\n        // Default is number, Precision of float may not enough\n        type: 'number'\n      };\n    } else {\n      dimensionInfo = dimensions[i];\n      dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'number';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this.indices = [];\n  /**\n   * Data storage\n   * @type {Object.<key, TypedArray|Array>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * @param {module:echarts/data/List}\n   */\n\n  this.stackedOn = null;\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and stackable info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data\n * @param {Array.<string>} [nameList]\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  data = data || [];\n  var isDataArray = zrUtil.isArray(data);\n\n  if (isDataArray) {\n    data = new DefaultDataProvider(data);\n  }\n\n  this._rawData = data; // Clear\n\n  var storage = this._storage = {};\n  var indices = this.indices = [];\n  var dimensions = this.dimensions;\n  var dimensionInfoMap = this._dimensionInfos;\n  var size = data.count();\n  var idList = [];\n  var nameRepeatCount = {};\n  var nameDimIdx;\n  nameList = nameList || []; // Init storage\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = dimensionInfoMap[dimensions[i]];\n    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n    var DataCtor = dataCtors[dimInfo.type];\n    storage[dimensions[i]] = new DataCtor(size);\n  }\n\n  var self = this;\n\n  if (!dimValueGetter) {\n    self.hasItemOption = false;\n  } // Default dim value getter\n\n\n  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }\n\n    if (modelUtil.isDataItemOption(dataItem)) {\n      self.hasItemOption = true;\n    }\n\n    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n    : value, dimensionInfoMap[dimName]);\n  };\n\n  for (var i = 0; i < size; i++) {\n    // NOTICE: Try not to write things into dataItem\n    var dataItem = data.getItem(i); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of cateogry\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // Store the data by dimensions\n\n    for (var k = 0; k < dimensions.length; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim]; // PENDING NULL is empty or zero\n\n      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n    }\n\n    indices.push(i);\n  } // Use the name in option and create id\n\n\n  for (var i = 0; i < size; i++) {\n    var dataItem = data.getItem(i);\n\n    if (!nameList[i] && dataItem) {\n      if (dataItem.name != null) {\n        nameList[i] = dataItem.name;\n      } else if (nameDimIdx != null) {\n        nameList[i] = storage[dimensions[nameDimIdx]][i];\n      }\n    }\n\n    var name = nameList[i] || ''; // Try using the id in option\n\n    var id = dataItem && dataItem.id;\n\n    if (!id && name) {\n      // Use name as id and add counter to avoid same name\n      nameRepeatCount[name] = nameRepeatCount[name] || 0;\n      id = name;\n\n      if (nameRepeatCount[name] > 0) {\n        id += '__ec__' + nameRepeatCount[name];\n      }\n\n      nameRepeatCount[name]++;\n    }\n\n    id && (idList[i] = id);\n  }\n\n  this._nameList = nameList;\n  this._idList = idList;\n};\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this.indices.length;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx, stack) {\n  var storage = this._storage;\n  var dataIndex = this.indices[idx]; // If value not exists\n\n  if (dataIndex == null || !storage[dim]) {\n    return NaN;\n  }\n\n  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable\n\n  if (stack) {\n    var dimensionInfo = this._dimensionInfos[dim];\n\n    if (dimensionInfo && dimensionInfo.stackable) {\n      var stackedOn = this.stackedOn;\n\n      while (stackedOn) {\n        // Get no stacked data of stacked on\n        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data\n\n        if (value >= 0 && stackedValue > 0 || // Positive stack\n        value <= 0 && stackedValue < 0 // Negative stack\n        ) {\n            value += stackedValue;\n          }\n\n        stackedOn = stackedOn.stackedOn;\n      }\n    }\n  }\n\n  return value;\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx, stack) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx, stack));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dimensions = this.dimensions;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n * @param {Function} filter\n */\n\n\nlistProto.getDataExtent = function (dim, stack, filter) {\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var dimInfo = this.getDimensionInfo(dim);\n  stack = dimInfo && dimInfo.stackable && stack;\n  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n  var value;\n\n  if (dimExtent) {\n    return dimExtent;\n  } // var dimInfo = this._dimensionInfos[dim];\n\n\n  if (dimData) {\n    var min = Infinity;\n    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      value = this.get(dim, i, stack); // FIXME\n      // if (isOrdinal && typeof value === 'string') {\n      //     value = zrUtil.indexOf(dimData, value);\n      // }\n\n      if (!filter || filter(value, dim, i)) {\n        value < min && (min = value);\n        value > max && (max = value);\n      }\n    }\n\n    return this._extent[dim + !!stack] = [min, max];\n  } else {\n    return [Infinity, -Infinity];\n  }\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getSum = function (dim, stack) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i, stack);\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Retreive the index with given value\n * @param {number} idx\n * @param {number} value\n * @return {number}\n */\n// FIXME Precision of float value\n\n\nlistProto.indexOf = function (dim, value) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var indices = this.indices;\n\n  if (dimData) {\n    for (var i = 0, len = indices.length; i < len; i++) {\n      var rawIndex = indices[i];\n\n      if (dimData[rawIndex] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  var indices = this.indices;\n  var nameList = this._nameList;\n\n  for (var i = 0, len = indices.length; i < len; i++) {\n    var rawIndex = indices[i];\n\n    if (nameList[rawIndex] === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  // Indices are ascending\n  var indices = this.indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = indices.length - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {boolean} stack If given value is after stacked\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i, stack);\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = function (idx) {\n  var rawIdx = this.indices[idx];\n  return rawIdx == null ? -1 : rawIdx;\n};\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  return this._rawData.getItem(this.getRawIndex(idx));\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  return this._nameList[this.indices[idx]] || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n};\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, stack, context) {\n  if (typeof dims === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dims;\n    dims = [];\n  }\n\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var value = [];\n  var dimSize = dims.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i, stack), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n        break;\n\n      default:\n        for (var k = 0; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i, stack);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var newIndices = [];\n  var value = [];\n  var dimSize = dimensions.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    var keep; // Simple optimization\n\n    if (!dimSize) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this.get(dimensions[k], i, stack);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices.push(indices[i]);\n    }\n  }\n\n  this.indices = newIndices; // Reset data extent\n\n  this._extent = {};\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, stack, context);\n  return result;\n};\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n    var dimStore = originalStorage[dim];\n\n    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n      storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n    } else {\n      // Direct reference for other dimensions\n      storage[dim] = originalStorage[dim];\n    }\n  }\n\n  return list;\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, stack, context) {\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  var indices = list.indices = this.indices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  this.each(dimensions, function () {\n    var idx = arguments[arguments.length - 1];\n    var retValue = cb && cb.apply(this, arguments);\n\n    if (retValue != null) {\n      // a number\n      if (typeof retValue === 'number') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var dimStore = storage[dim];\n        var rawIdx = indices[idx];\n\n        if (dimStore) {\n          dimStore[rawIdx] = retValue[i];\n        }\n      }\n    }\n  }, stack, context);\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var storage = this._storage;\n  var targetStorage = list._storage;\n  var originalIndices = this.indices;\n  var indices = list.indices = [];\n  var frameValues = [];\n  var frameIndices = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count(); // Copy data from original data\n\n  for (var i = 0; i < storage[dimension].length; i++) {\n    targetStorage[dimension][i] = storage[dimension][i];\n  }\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var idx = originalIndices[i + k];\n      frameValues[k] = dimStore[idx];\n      frameIndices[k] = idx;\n    }\n\n    var value = sampleValue(frameValues);\n    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data\n\n    dimStore[idx] = value;\n    indices.push(idx);\n  }\n\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  idx = this.indices[idx];\n  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var idList = this._idList;\n  var otherIdList = otherList && otherList._idList;\n  var val; // Use prefix to avoid index to be the same as otherIdList[idx],\n  // which will cause weird udpate animation.\n\n  var prefix = 'e\\0\\0';\n  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n    return (val = otherIdList[idx]) != null ? val : prefix + idx;\n  }, function (idx) {\n    return (val = idList[idx]) != null ? val : prefix + idx;\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function () {\n  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n  var list = new List(dimensionInfoList, this.hostModel); // FIXME\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  list.indices = this.indices.slice();\n\n  if (this._extent) {\n    list._extent = zrUtil.extend({}, this._extent);\n  }\n\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf'];\nvar _default = List;\nmodule.exports = _default;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n\n/***/ 856:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar clazzUtil = __webpack_require__(824);\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n/**\n * @param {Object} [setting]\n */\nfunction Scale(setting) {\n  this._setting = setting || {};\n  /**\n   * Extent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._extent = [Infinity, -Infinity];\n  /**\n   * Step is calculated in adjustExtent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._interval = 0;\n  this.init && this.init.apply(this, arguments);\n}\n/**\n * Parse input val to valid inner number.\n * @param {*} val\n * @return {number}\n */\n\n\nScale.prototype.parse = function (val) {\n  // Notice: This would be a trap here, If the implementation\n  // of this method depends on extent, and this method is used\n  // before extent set (like in dataZoom), it would be wrong.\n  // Nevertheless, parse does not depend on extent generally.\n  return val;\n};\n\nScale.prototype.getSetting = function (name) {\n  return this._setting[name];\n};\n\nScale.prototype.contain = function (val) {\n  var extent = this._extent;\n  return val >= extent[0] && val <= extent[1];\n};\n/**\n * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.normalize = function (val) {\n  var extent = this._extent;\n\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n\n  return (val - extent[0]) / (extent[1] - extent[0]);\n};\n/**\n * Scale normalized value\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.scale = function (val) {\n  var extent = this._extent;\n  return val * (extent[1] - extent[0]) + extent[0];\n};\n/**\n * Set extent from data\n * @param {Array.<number>} other\n */\n\n\nScale.prototype.unionExtent = function (other) {\n  var extent = this._extent;\n  other[0] < extent[0] && (extent[0] = other[0]);\n  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power\n  // this.setExtent(extent[0], extent[1]);\n};\n/**\n * Set extent from data\n * @param {module:echarts/data/List} data\n * @param {string} dim\n */\n\n\nScale.prototype.unionExtentFromData = function (data, dim) {\n  this.unionExtent(data.getDataExtent(dim, true));\n};\n/**\n * Get extent\n * @return {Array.<number>}\n */\n\n\nScale.prototype.getExtent = function () {\n  return this._extent.slice();\n};\n/**\n * Set extent\n * @param {number} start\n * @param {number} end\n */\n\n\nScale.prototype.setExtent = function (start, end) {\n  var thisExtent = this._extent;\n\n  if (!isNaN(start)) {\n    thisExtent[0] = start;\n  }\n\n  if (!isNaN(end)) {\n    thisExtent[1] = end;\n  }\n};\n/**\n * @return {Array.<string>}\n */\n\n\nScale.prototype.getTicksLabels = function () {\n  var labels = [];\n  var ticks = this.getTicks();\n\n  for (var i = 0; i < ticks.length; i++) {\n    labels.push(this.getLabel(ticks[i]));\n  }\n\n  return labels;\n};\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\n\n\nScale.prototype.isBlank = function () {\n  return this._isBlank;\n},\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.setBlank = function (isBlank) {\n  this._isBlank = isBlank;\n};\nclazzUtil.enableClassExtend(Scale);\nclazzUtil.enableClassManagement(Scale, {\n  registerWhenExtend: true\n});\nvar _default = Scale;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 857:\n/***/ (function(module, exports) {\n\nvar dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config\n * @exports zrender/config\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n/**\n * debugcatchBrushExceptiontrue\n * 0 : debug\n * 1 : \n * 2 : \n */\n\n\nvar debugMode = 0; // retina \n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n\n/***/ }),\n\n/***/ 858:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Element = __webpack_require__(896);\n\nvar BoundingRect = __webpack_require__(821);\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * \n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   *  index \n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * \n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * \n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   *  nextSibling \n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * \n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * \n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 859:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar curve = __webpack_require__(847);\n\nvar vec2 = __webpack_require__(812);\n\nvar bbox = __webpack_require__(902);\n\nvar BoundingRect = __webpack_require__(821);\n\nvar _config = __webpack_require__(857);\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * Path\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi  _dashedXXXXTo \n    // xi, yi , x0, y0  closePath \n    //  beginPath  lineTo x0, y0 \n    //  lineTo dashed line  IE10- \n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context  rebuildPath  fill\n   * stroke \n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * \n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   *  Path \n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * \n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   *  Path \n   * \n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      //  Float32Array\n      // \n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   *  Float32Array \n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        //  L, C, Q\n        //  previous point  point\n        //\n        //  Arc \n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo  subpath, \n          //  closePath \n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc \n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc \n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            //  arc \n            // \n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        //  L, C, Q\n        //  previous point  point\n        //\n        //  Arc \n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            //  arc \n            // \n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 860:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\n// TODO Parse shadow style\n// TODO Only shallow path support\nfunction _default(properties) {\n  // Normalize\n  for (var i = 0; i < properties.length; i++) {\n    if (!properties[i][1]) {\n      properties[i][1] = properties[i][0];\n    }\n  }\n\n  return function (model, excludes, includes) {\n    var style = {};\n\n    for (var i = 0; i < properties.length; i++) {\n      var propName = properties[i][1];\n\n      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {\n        continue;\n      }\n\n      var val = model.getShallow(propName);\n\n      if (val != null) {\n        style[properties[i][0]] = val;\n      }\n    }\n\n    return style;\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 868:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar env = __webpack_require__(819);\n\nvar _format = __webpack_require__(822);\n\nvar formatTime = _format.formatTime;\nvar encodeHTML = _format.encodeHTML;\nvar addCommas = _format.addCommas;\nvar getTooltipMarker = _format.getTooltipMarker;\n\nvar _clazz = __webpack_require__(824);\n\nvar set = _clazz.set;\nvar get = _clazz.get;\n\nvar modelUtil = __webpack_require__(811);\n\nvar ComponentModel = __webpack_require__(838);\n\nvar colorPaletteMixin = __webpack_require__(894);\n\nvar _layout = __webpack_require__(845);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar SeriesModel = ComponentModel.extend({\n  type: 'series.__base__',\n\n  /**\n   * @readOnly\n   */\n  seriesIndex: 0,\n  // coodinateSystem will be injected in the echarts/CoordinateSystem\n  coordinateSystem: null,\n\n  /**\n   * @type {Object}\n   * @protected\n   */\n  defaultOption: null,\n\n  /**\n   * Data provided for legend\n   * @type {Function}\n   */\n  // PENDING\n  legendDataProvider: null,\n\n  /**\n   * Access path of color for visual\n   */\n  visualColorAccessPath: 'itemStyle.normal.color',\n\n  /**\n   * Support merge layout params.\n   * Only support 'box' now (left/right/top/bottom/width/height).\n   * @type {string|Object} Object can be {ignoreSize: true}\n   * @readOnly\n   */\n  layoutMode: null,\n  init: function (option, parentModel, ecModel, extraOpt) {\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.seriesIndex = this.componentIndex;\n    this.mergeDefaultAndTheme(option, ecModel);\n    var data = this.getInitialData(option, ecModel);\n\n    /**\n     * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n     * @private\n     */\n    set(this, 'dataBeforeProcessed', data); // If we reverse the order (make data firstly, and then make\n    // dataBeforeProcessed by cloneShallow), cloneShallow will\n    // cause data.graph.data !== data when using\n    // module:echarts/data/Graph or module:echarts/data/Tree.\n    // See module:echarts/data/helper/linkList\n\n    this.restoreData();\n  },\n\n  /**\n   * Util for merge default and theme to option\n   * @param  {Object} option\n   * @param  {module:echarts/model/Global} ecModel\n   */\n  mergeDefaultAndTheme: function (option, ecModel) {\n    var layoutMode = this.layoutMode;\n    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.\n    // But if name duplicate between series subType\n    // (for example: parallel) add component mainType,\n    // add suffix 'Series'.\n\n    var themeSubType = this.subType;\n\n    if (ComponentModel.hasClass(themeSubType)) {\n      themeSubType += 'Series';\n    }\n\n    zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`\n\n    modelUtil.defaultEmphasis(option.label, ['show']);\n    this.fillDataTextStyle(option.data);\n\n    if (layoutMode) {\n      mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  },\n  mergeOption: function (newSeriesOption, ecModel) {\n    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n    this.fillDataTextStyle(newSeriesOption.data);\n    var layoutMode = this.layoutMode;\n\n    if (layoutMode) {\n      mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n    }\n\n    var data = this.getInitialData(newSeriesOption, ecModel); // TODO Merge data?\n\n    if (data) {\n      set(this, 'data', data);\n      set(this, 'dataBeforeProcessed', data.cloneShallow());\n    }\n  },\n  fillDataTextStyle: function (data) {\n    // Default data label emphasis `show`\n    // FIXME Tree structure data ?\n    // FIXME Performance ?\n    if (data) {\n      var props = ['show'];\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] && data[i].label) {\n          modelUtil.defaultEmphasis(data[i].label, props);\n        }\n      }\n    }\n  },\n\n  /**\n   * Init a data structure from data related option in series\n   * Must be overwritten\n   */\n  getInitialData: function () {},\n\n  /**\n   * @param {string} [dataType]\n   * @return {module:echarts/data/List}\n   */\n  getData: function (dataType) {\n    var data = get(this, 'data');\n    return dataType == null ? data : data.getLinkedData(dataType);\n  },\n\n  /**\n   * @param {module:echarts/data/List} data\n   */\n  setData: function (data) {\n    set(this, 'data', data);\n  },\n\n  /**\n   * Get data before processed\n   * @return {module:echarts/data/List}\n   */\n  getRawData: function () {\n    return get(this, 'dataBeforeProcessed');\n  },\n\n  /**\n   * Coord dimension to data dimension.\n   *\n   * By default the result is the same as dimensions of series data.\n   * But in some series data dimensions are different from coord dimensions (i.e.\n   * candlestick and boxplot). Override this method to handle those cases.\n   *\n   * Coord dimension to data dimension can be one-to-many\n   *\n   * @param {string} coordDim\n   * @return {Array.<string>} dimensions on the axis.\n   */\n  coordDimToDataDim: function (coordDim) {\n    return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n  },\n\n  /**\n   * Convert data dimension to coord dimension.\n   *\n   * @param {string|number} dataDim\n   * @return {string}\n   */\n  dataDimToCoordDim: function (dataDim) {\n    return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n  },\n\n  /**\n   * Get base axis if has coordinate system and has axis.\n   * By default use coordSys.getBaseAxis();\n   * Can be overrided for some chart.\n   * @return {type} description\n   */\n  getBaseAxis: function () {\n    var coordSys = this.coordinateSystem;\n    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n  },\n  // FIXME\n\n  /**\n   * Default tooltip formatter\n   *\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   */\n  formatTooltip: function (dataIndex, multipleSeries, dataType) {\n    function formatArrayValue(value) {\n      var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n        var dimItem = data.getDimensionInfo(idx);\n        return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n      }, 0);\n      var result = [];\n      var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n      tooltipDims.length ? zrUtil.each(tooltipDims, function (dimIdx) {\n        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n      }) // By default, all dims is used on tooltip.\n      : zrUtil.each(value, setEachItem);\n\n      function setEachItem(val, dimIdx) {\n        var dimInfo = data.getDimensionInfo(dimIdx); // If `dimInfo.tooltip` is not set, show tooltip.\n\n        if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n          return;\n        }\n\n        var dimType = dimInfo.type;\n        var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '') + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val) : addCommas(val));\n        valStr && result.push(encodeHTML(valStr));\n      }\n\n      return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n    }\n\n    var data = get(this, 'data');\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : encodeHTML(addCommas(value));\n    var name = data.getName(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n\n    if (zrUtil.isObject(color) && color.colorStops) {\n      color = (color.colorStops[0] || {}).color;\n    }\n\n    color = color || 'transparent';\n    var colorEl = getTooltipMarker(color);\n    var seriesName = this.name; // FIXME\n\n    if (seriesName === '\\0-') {\n      // Not show '-'\n      seriesName = '';\n    }\n\n    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';\n    return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var animationEnabled = this.getShallow('animation');\n\n    if (animationEnabled) {\n      if (this.getData().count() > this.getShallow('animationThreshold')) {\n        animationEnabled = false;\n      }\n    }\n\n    return animationEnabled;\n  },\n  restoreData: function () {\n    set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n  },\n  getColorFromPalette: function (name, scope) {\n    var ecModel = this.ecModel; // PENDING\n\n    var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\n    if (!color) {\n      color = ecModel.getColorFromPalette(name, scope);\n    }\n\n    return color;\n  },\n\n  /**\n   * Get data indices for show tooltip content. See tooltip.\n   * @abstract\n   * @param {Array.<string>|string} dim\n   * @param {Array.<number>} value\n   * @param {module:echarts/coord/single/SingleAxis} baseAxis\n   * @return {Object} {dataIndices, nestestValue}.\n   */\n  getAxisTooltipData: null,\n\n  /**\n   * See tooltip.\n   * @abstract\n   * @param {number} dataIndex\n   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n   */\n  getTooltipPosition: null\n});\nzrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\nzrUtil.mixin(SeriesModel, colorPaletteMixin);\nvar _default = SeriesModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 869:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Group = __webpack_require__(858);\n\nvar componentUtil = __webpack_require__(874);\n\nvar clazzUtil = __webpack_require__(824);\n\nvar modelUtil = __webpack_require__(811);\n\nfunction Chart() {\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n  this.group = new Group();\n  /**\n   * @type {string}\n   * @readOnly\n   */\n\n  this.uid = componentUtil.getUID('viewChart');\n}\n\nChart.prototype = {\n  type: 'chart',\n\n  /**\n   * Init the chart\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  init: function (ecModel, api) {},\n\n  /**\n   * Render the chart\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  render: function (seriesModel, ecModel, api, payload) {},\n\n  /**\n   * Highlight series or specified data item\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  highlight: function (seriesModel, ecModel, api, payload) {\n    toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n  },\n\n  /**\n   * Downplay series or specified data item\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  downplay: function (seriesModel, ecModel, api, payload) {\n    toggleHighlight(seriesModel.getData(), payload, 'normal');\n  },\n\n  /**\n   * Remove self\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  remove: function (ecModel, api) {\n    this.group.removeAll();\n  },\n\n  /**\n   * Dispose self\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  dispose: function () {}\n  /**\n   * The view contains the given point.\n   * @interface\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  // containPoint: function () {}\n\n};\nvar chartProto = Chart.prototype;\n\nchartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n  this.render(seriesModel, ecModel, api, payload);\n};\n/**\n * Set state of single element\n * @param  {module:zrender/Element} el\n * @param  {string} state\n */\n\n\nfunction elSetState(el, state) {\n  if (el) {\n    el.trigger(state);\n\n    if (el.type === 'group') {\n      for (var i = 0; i < el.childCount(); i++) {\n        elSetState(el.childAt(i), state);\n      }\n    }\n  }\n}\n/**\n * @param  {module:echarts/data/List} data\n * @param  {Object} payload\n * @param  {string} state 'normal'|'emphasis'\n * @inner\n */\n\n\nfunction toggleHighlight(data, payload, state) {\n  var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n  if (dataIndex != null) {\n    zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n      elSetState(data.getItemGraphicEl(dataIdx), state);\n    });\n  } else {\n    data.eachItemGraphicEl(function (el) {\n      elSetState(el, state);\n    });\n  }\n} // Enable Chart.extend.\n\n\nclazzUtil.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(Chart, {\n  registerWhenExtend: true\n});\nvar _default = Chart;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 872:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar coordinateSystemCreators = {};\n\nfunction CoordinateSystemManager() {\n  this._coordinateSystems = [];\n}\n\nCoordinateSystemManager.prototype = {\n  constructor: CoordinateSystemManager,\n  create: function (ecModel, api) {\n    var coordinateSystems = [];\n    zrUtil.each(coordinateSystemCreators, function (creater, type) {\n      var list = creater.create(ecModel, api);\n      coordinateSystems = coordinateSystems.concat(list || []);\n    });\n    this._coordinateSystems = coordinateSystems;\n  },\n  update: function (ecModel, api) {\n    zrUtil.each(this._coordinateSystems, function (coordSys) {\n      // FIXME MUST have\n      coordSys.update && coordSys.update(ecModel, api);\n    });\n  },\n  getCoordinateSystems: function () {\n    return this._coordinateSystems.slice();\n  }\n};\n\nCoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n  coordinateSystemCreators[type] = coordinateSystemCreator;\n};\n\nCoordinateSystemManager.get = function (type) {\n  return coordinateSystemCreators[type];\n};\n\nvar _default = CoordinateSystemManager;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 873:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar numberUtil = __webpack_require__(810);\n\nvar formatUtil = __webpack_require__(822);\n\nvar Scale = __webpack_require__(856);\n\nvar helper = __webpack_require__(895);\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getTicksLabels: function () {\n    var labels = [];\n    var ticks = this.getTicks();\n\n    for (var i = 0; i < ticks.length; i++) {\n      labels.push(this.getLabel(ticks[i]));\n    }\n\n    return labels;\n  },\n\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 874:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar _clazz = __webpack_require__(824);\n\nvar parseClassType = _clazz.parseClassType;\nvar base = 0;\nvar DELIMITER = '_';\n/**\n * @public\n * @param {string} type\n * @return {string}\n */\n\nfunction getUID(type) {\n  // Considering the case of crossing js context,\n  // use Math.random to make id as unique as possible.\n  return [type || '', base++, Math.random()].join(DELIMITER);\n}\n/**\n * @inner\n */\n\n\nfunction enableSubTypeDefaulter(entity) {\n  var subTypeDefaulters = {};\n\n  entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n    componentType = parseClassType(componentType);\n    subTypeDefaulters[componentType.main] = defaulter;\n  };\n\n  entity.determineSubType = function (componentType, option) {\n    var type = option.type;\n\n    if (!type) {\n      var componentTypeMain = parseClassType(componentType).main;\n\n      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n        type = subTypeDefaulters[componentTypeMain](option);\n      }\n    }\n\n    return type;\n  };\n\n  return entity;\n}\n/**\n * Topological travel on Activity Network (Activity On Vertices).\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n *\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n *\n * If there is circle dependencey, Error will be thrown.\n *\n */\n\n\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n  /**\n   * @public\n   * @param {Array.<string>} targetNameList Target Component type list.\n   *                                           Can be ['aa', 'bb', 'aa.xx']\n   * @param {Array.<string>} fullNameList By which we can build dependency graph.\n   * @param {Function} callback Params: componentType, dependencies.\n   * @param {Object} context Scope of callback.\n   */\n  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n    if (!targetNameList.length) {\n      return;\n    }\n\n    var result = makeDepndencyGraph(fullNameList);\n    var graph = result.graph;\n    var stack = result.noEntryList;\n    var targetNameSet = {};\n    zrUtil.each(targetNameList, function (name) {\n      targetNameSet[name] = true;\n    });\n\n    while (stack.length) {\n      var currComponentType = stack.pop();\n      var currVertex = graph[currComponentType];\n      var isInTargetNameSet = !!targetNameSet[currComponentType];\n\n      if (isInTargetNameSet) {\n        callback.call(context, currComponentType, currVertex.originalDeps.slice());\n        delete targetNameSet[currComponentType];\n      }\n\n      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n    }\n\n    zrUtil.each(targetNameSet, function () {\n      throw new Error('Circle dependency may exists');\n    });\n\n    function removeEdge(succComponentType) {\n      graph[succComponentType].entryCount--;\n\n      if (graph[succComponentType].entryCount === 0) {\n        stack.push(succComponentType);\n      }\n    } // Consider this case: legend depends on series, and we call\n    // chart.setOption({series: [...]}), where only series is in option.\n    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n    // not be called, but only sereis.mergeOption is called. Thus legend\n    // have no chance to update its local record about series (like which\n    // name of series is available in legend).\n\n\n    function removeEdgeAndAdd(succComponentType) {\n      targetNameSet[succComponentType] = true;\n      removeEdge(succComponentType);\n    }\n  };\n  /**\n   * DepndencyGraph: {Object}\n   * key: conponentType,\n   * value: {\n   *     successor: [conponentTypes...],\n   *     originalDeps: [conponentTypes...],\n   *     entryCount: {number}\n   * }\n   */\n\n\n  function makeDepndencyGraph(fullNameList) {\n    var graph = {};\n    var noEntryList = [];\n    zrUtil.each(fullNameList, function (name) {\n      var thisItem = createDependencyGraphItem(graph, name);\n      var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n      thisItem.entryCount = availableDeps.length;\n\n      if (thisItem.entryCount === 0) {\n        noEntryList.push(name);\n      }\n\n      zrUtil.each(availableDeps, function (dependentName) {\n        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n          thisItem.predecessor.push(dependentName);\n        }\n\n        var thatItem = createDependencyGraphItem(graph, dependentName);\n\n        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n          thatItem.successor.push(name);\n        }\n      });\n    });\n    return {\n      graph: graph,\n      noEntryList: noEntryList\n    };\n  }\n\n  function createDependencyGraphItem(graph, name) {\n    if (!graph[name]) {\n      graph[name] = {\n        predecessor: [],\n        successor: []\n      };\n    }\n\n    return graph[name];\n  }\n\n  function getAvailableDependencies(originalDeps, fullNameList) {\n    var availableDeps = [];\n    zrUtil.each(originalDeps, function (dep) {\n      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n    });\n    return availableDeps;\n  }\n}\n\nexports.getUID = getUID;\nexports.enableSubTypeDefaulter = enableSubTypeDefaulter;\nexports.enableTopologicalTravel = enableTopologicalTravel;\n\n/***/ }),\n\n/***/ 875:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar graphic = __webpack_require__(808);\n\nvar BoundingRect = __webpack_require__(821);\n\n// Symbol factory\n\n/**\n * Triangle shape\n * @inner\n */\nvar Triangle = graphic.extendShape({\n  type: 'triangle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy + height);\n    path.lineTo(cx - width, cy + height);\n    path.closePath();\n  }\n});\n/**\n * Diamond shape\n * @inner\n */\n\nvar Diamond = graphic.extendShape({\n  type: 'diamond',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy);\n    path.lineTo(cx, cy + height);\n    path.lineTo(cx - width, cy);\n    path.closePath();\n  }\n});\n/**\n * Pin shape\n * @inner\n */\n\nvar Pin = graphic.extendShape({\n  type: 'pin',\n  shape: {\n    // x, y on the cusp\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var w = shape.width / 5 * 3; // Height must be larger than width\n\n    var h = Math.max(w, shape.height);\n    var r = w / 2; // Dist on y with tangent point and circle center\n\n    var dy = r * r / (h - r);\n    var cy = y - h + r + dy;\n    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center\n\n    var dx = Math.cos(angle) * r;\n    var tanX = Math.sin(angle);\n    var tanY = Math.cos(angle);\n    var cpLen = r * 0.6;\n    var cpLen2 = r * 0.7;\n    path.moveTo(x - dx, cy + dy);\n    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);\n    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);\n    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);\n    path.closePath();\n  }\n});\n/**\n * Arrow shape\n * @inner\n */\n\nvar Arrow = graphic.extendShape({\n  type: 'arrow',\n  shape: {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var height = shape.height;\n    var width = shape.width;\n    var x = shape.x;\n    var y = shape.y;\n    var dx = width / 3 * 2;\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + dx, y + height);\n    ctx.lineTo(x, y + height / 4 * 3);\n    ctx.lineTo(x - dx, y + height);\n    ctx.lineTo(x, y);\n    ctx.closePath();\n  }\n});\n/**\n * Map of path contructors\n * @type {Object.<string, module:zrender/graphic/Path>}\n */\n\nvar symbolCtors = {\n  line: graphic.Line,\n  rect: graphic.Rect,\n  roundRect: graphic.Rect,\n  square: graphic.Rect,\n  circle: graphic.Circle,\n  diamond: Diamond,\n  pin: Pin,\n  arrow: Arrow,\n  triangle: Triangle\n};\nvar symbolShapeMakers = {\n  line: function (x, y, w, h, shape) {\n    // FIXME\n    shape.x1 = x;\n    shape.y1 = y + h / 2;\n    shape.x2 = x + w;\n    shape.y2 = y + h / 2;\n  },\n  rect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n  },\n  roundRect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n    shape.r = Math.min(w, h) / 4;\n  },\n  square: function (x, y, w, h, shape) {\n    var size = Math.min(w, h);\n    shape.x = x;\n    shape.y = y;\n    shape.width = size;\n    shape.height = size;\n  },\n  circle: function (x, y, w, h, shape) {\n    // Put circle in the center of square\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.r = Math.min(w, h) / 2;\n  },\n  diamond: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  pin: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  arrow: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  triangle: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  }\n};\nvar symbolBuildProxies = {};\nzrUtil.each(symbolCtors, function (Ctor, name) {\n  symbolBuildProxies[name] = new Ctor();\n});\nvar SymbolClz = graphic.extendShape({\n  type: 'symbol',\n  shape: {\n    symbolType: '',\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  beforeBrush: function () {\n    var style = this.style;\n    var shape = this.shape; // FIXME\n\n    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n      style.textPosition = ['50%', '40%'];\n      style.textAlign = 'center';\n      style.textVerticalAlign = 'middle';\n    }\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    var symbolType = shape.symbolType;\n    var proxySymbol = symbolBuildProxies[symbolType];\n\n    if (shape.symbolType !== 'none') {\n      if (!proxySymbol) {\n        // Default rect\n        symbolType = 'rect';\n        proxySymbol = symbolBuildProxies[symbolType];\n      }\n\n      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);\n      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n    }\n  }\n}); // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\nfunction symbolPathSetColor(color, innerColor) {\n  if (this.type !== 'image') {\n    var symbolStyle = this.style;\n    var symbolShape = this.shape;\n\n    if (symbolShape && symbolShape.symbolType === 'line') {\n      symbolStyle.stroke = color;\n    } else if (this.__isEmptyBrush) {\n      symbolStyle.stroke = color;\n      symbolStyle.fill = innerColor || '#fff';\n    } else {\n      // FIXME  onlyStroke ?\n      symbolStyle.fill && (symbolStyle.fill = color);\n      symbolStyle.stroke && (symbolStyle.stroke = color);\n    }\n\n    this.dirty(false);\n  }\n}\n/**\n * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n * @param {string} symbolType\n * @param {number} x\n * @param {number} y\n * @param {number} w\n * @param {number} h\n * @param {string} color\n * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,\n *                            for path and image only.\n */\n\n\nfunction createSymbol(symbolType, x, y, w, h, color, keepAspect) {\n  // TODO Support image object, DynamicImage.\n  var isEmpty = symbolType.indexOf('empty') === 0;\n\n  if (isEmpty) {\n    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n  }\n\n  var symbolPath;\n\n  if (symbolType.indexOf('image://') === 0) {\n    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else if (symbolType.indexOf('path://') === 0) {\n    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else {\n    symbolPath = new SymbolClz({\n      shape: {\n        symbolType: symbolType,\n        x: x,\n        y: y,\n        width: w,\n        height: h\n      }\n    });\n  }\n\n  symbolPath.__isEmptyBrush = isEmpty;\n  symbolPath.setColor = symbolPathSetColor;\n  symbolPath.setColor(color);\n  return symbolPath;\n}\n\nexports.createSymbol = createSymbol;\n\n/***/ }),\n\n/***/ 876:\n/***/ (function(module, exports) {\n\nvar ORIGIN_METHOD = '\\0__throttleOriginMethod';\nvar RATE = '\\0__throttleRate';\nvar THROTTLE_TYPE = '\\0__throttleType';\n/**\n * @public\n * @param {(Function)} fn\n * @param {number} [delay=0] Unit: ms.\n * @param {boolean} [debounce=false]\n *        true: If call interval less than `delay`, only the last call works.\n *        false: If call interval less than `delay, call works on fixed rate.\n * @return {(Function)} throttled fn.\n */\n\nfunction throttle(fn, delay, debounce) {\n  var currCall;\n  var lastCall = 0;\n  var lastExec = 0;\n  var timer = null;\n  var diff;\n  var scope;\n  var args;\n  var debounceNextCall;\n  delay = delay || 0;\n\n  function exec() {\n    lastExec = new Date().getTime();\n    timer = null;\n    fn.apply(scope, args || []);\n  }\n\n  var cb = function () {\n    currCall = new Date().getTime();\n    scope = this;\n    args = arguments;\n    var thisDelay = debounceNextCall || delay;\n    var thisDebounce = debounceNextCall || debounce;\n    debounceNextCall = null;\n    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n    clearTimeout(timer);\n\n    if (thisDebounce) {\n      timer = setTimeout(exec, thisDelay);\n    } else {\n      if (diff >= 0) {\n        exec();\n      } else {\n        timer = setTimeout(exec, -diff);\n      }\n    }\n\n    lastCall = currCall;\n  };\n  /**\n   * Clear throttle.\n   * @public\n   */\n\n\n  cb.clear = function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  };\n  /**\n   * Enable debounce once.\n   */\n\n\n  cb.debounceNextCall = function (debounceDelay) {\n    debounceNextCall = debounceDelay;\n  };\n\n  return cb;\n}\n/**\n * Create throttle method or update throttle rate.\n *\n * @example\n * ComponentView.prototype.render = function () {\n *     ...\n *     throttle.createOrUpdate(\n *         this,\n *         '_dispatchAction',\n *         this.model.get('throttle'),\n *         'fixRate'\n *     );\n * };\n * ComponentView.prototype.remove = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n * ComponentView.prototype.dispose = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n * @param {number} [rate]\n * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n * @return {Function} throttled function.\n */\n\n\nfunction createOrUpdate(obj, fnAttr, rate, throttleType) {\n  var fn = obj[fnAttr];\n\n  if (!fn) {\n    return;\n  }\n\n  var originFn = fn[ORIGIN_METHOD] || fn;\n  var lastThrottleType = fn[THROTTLE_TYPE];\n  var lastRate = fn[RATE];\n\n  if (lastRate !== rate || lastThrottleType !== throttleType) {\n    if (rate == null || !throttleType) {\n      return obj[fnAttr] = originFn;\n    }\n\n    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');\n    fn[ORIGIN_METHOD] = originFn;\n    fn[THROTTLE_TYPE] = throttleType;\n    fn[RATE] = rate;\n  }\n\n  return fn;\n}\n/**\n * Clear throttle. Example see throttle.createOrUpdate.\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n */\n\n\nfunction clear(obj, fnAttr) {\n  var fn = obj[fnAttr];\n\n  if (fn && fn[ORIGIN_METHOD]) {\n    obj[fnAttr] = fn[ORIGIN_METHOD];\n  }\n}\n\nexports.throttle = throttle;\nexports.createOrUpdate = createOrUpdate;\nexports.clear = clear;\n\n/***/ }),\n\n/***/ 877:\n/***/ (function(module, exports) {\n\n// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n\n/***/ }),\n\n/***/ 878:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Style = __webpack_require__(907);\n\nvar Element = __webpack_require__(896);\n\nvar RectText = __webpack_require__(990);\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable Painter \n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * true\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * zlevelcanvas\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * \n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * \n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   *  x, y \n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   *  x, y \n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * \n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * \n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO,  bind \n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 879:\n/***/ (function(module, exports) {\n\n/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 880:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar LRU = __webpack_require__(901);\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n\n/***/ }),\n\n/***/ 881:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\n__webpack_require__(927);\n\n__webpack_require__(935);\n\n__webpack_require__(936);\n\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n/***/ }),\n\n/***/ 882:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar _model = __webpack_require__(811);\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/**\n * Complete dimensions by data (guess dimension).\n */\nvar each = zrUtil.each;\nvar isString = zrUtil.isString;\nvar defaults = zrUtil.defaults;\nvar OTHER_DIMS = {\n  tooltip: 1,\n  label: 1,\n  itemName: 1\n};\n/**\n * Complete the dimensions array, by user defined `dimension` and `encode`,\n * and guessing from the data structure.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: []}, ...] can be specified to give names.\n * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n *                      If not specified, extra dim names will be:\n *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<Object>} [{\n *      name: string mandatory,\n *      coordDim: string mandatory,\n *      coordDimIndex: number mandatory,\n *      type: string optional,\n *      tooltipName: string optional,\n *      otherDims: {\n *          tooltip: number optional,\n *          label: number optional\n *      },\n *      isExtraCoord: boolean true or undefined.\n *      other props ...\n * }]\n */\n\nfunction completeDimensions(sysDims, data, opt) {\n  data = data || [];\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n  var dataDimNameMap = zrUtil.createHashMap();\n  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;\n\n  var result = [];\n  var dimCount = opt.dimCount;\n\n  if (dimCount == null) {\n    var value0 = retrieveValue(data[0]);\n    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);\n    each(sysDims, function (sysDimItem) {\n      var sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n    });\n  } // Apply user defined dims (`name` and `type`) and init result.\n\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItem = isString(dimsDef[i]) ? {\n      name: dimsDef[i]\n    } : dimsDef[i] || {};\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = {\n      otherDims: {}\n    }; // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option, tooltipName\n      // will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.tooltipName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n\n\n  encodeDef.each(function (dataDims, coordDim) {\n    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      // The input resultDimIdx can be dim name or index.\n      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        dataDims[coordDimIndex] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItem, sysDimIndex) {\n    var coordDim;\n    var sysDimItem;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n\n    if (isString(sysDimItem)) {\n      coordDim = sysDimItem;\n      sysDimItem = {};\n    } else {\n      coordDim = sysDimItem.name;\n      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n      }\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  }); // Make sure the first extra dim is 'value'.\n\n  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n    var coordDim = resultItem.coordDim;\n    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));\n    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');\n  }\n\n  return result;\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (OTHER_DIMS[coordDim]) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n\n  function genName(name, map, fromZero) {\n    if (fromZero || map.get(name) != null) {\n      var i = 0;\n\n      while (map.get(name + i) != null) {\n        i++;\n      }\n\n      name += i;\n    }\n\n    map.set(name, true);\n    return name;\n  }\n} // The rule should not be complex, otherwise user might not\n// be able to known where the data is wrong.\n\n\nvar guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n  for (var i = 0, len = data.length; i < len; i++) {\n    var value = retrieveValue(data[i]);\n\n    if (!zrUtil.isArray(value)) {\n      return false;\n    }\n\n    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (value != null && isFinite(value) && value !== '') {\n      return false;\n    } else if (isString(value) && value !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction retrieveValue(o) {\n  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n}\n\nvar _default = completeDimensions;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 883:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar List = __webpack_require__(855);\n\nvar completeDimensions = __webpack_require__(882);\n\nvar _model = __webpack_require__(811);\n\nvar getDataItemValue = _model.getDataItemValue;\nvar converDataValue = _model.converDataValue;\nvar isDataItemOption = _model.isDataItemOption;\n\nvar CoordinateSystem = __webpack_require__(872);\n\nfunction firstDataNotNull(data) {\n  var i = 0;\n\n  while (i < data.length && data[i] == null) {\n    i++;\n  }\n\n  return data[i];\n}\n\nfunction ifNeedCompleteOrdinalData(data) {\n  var sampleItem = firstDataNotNull(data);\n  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n}\n/**\n * Helper function to create a list from option data\n */\n\n\nfunction createListFromArray(data, seriesModel, ecModel) {\n  // If data is undefined\n  data = data || [];\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var creator = creators[coordSysName];\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var completeDimOpt = {\n    encodeDef: seriesModel.get('encode'),\n    dimsDef: seriesModel.get('dimensions')\n  }; // FIXME\n\n  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n  var dimensions = axesInfo && axesInfo.dimensions;\n\n  if (!dimensions) {\n    // Get dimensions from registered coordinate system\n    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n  }\n\n  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n  var list = new List(dimensions, seriesModel);\n  var nameList = createNameList(axesInfo, data);\n  var categories = {};\n  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // If any dataItem is like { value: 10 }\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    } // Use dataIndex as ordinal value in categoryAxis\n\n\n    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n  } : function (itemOpt, dimName, dataIndex, dimIndex) {\n    var value = getDataItemValue(itemOpt);\n    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }\n\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    }\n\n    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\n    if (categoryAxesModels && categoryAxesModels[dimName]) {\n      // If given value is a category string\n      if (typeof val === 'string') {\n        // Lazy get categories\n        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n        val = zrUtil.indexOf(categories[dimName], val);\n\n        if (val < 0 && !isNaN(val)) {\n          // In case some one write '1', '2' istead of 1, 2\n          val = +val;\n        }\n      }\n    }\n\n    return val;\n  };\n  list.hasItemOption = false;\n  list.initData(data, nameList, dimValueGetter);\n  return list;\n}\n\nfunction isStackable(axisType) {\n  return axisType !== 'category' && axisType !== 'time';\n}\n\nfunction getDimTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\n/**\n * Creaters for each coord system.\n */\n\n\nvar creators = {\n  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n      return ecModel.queryComponents({\n        mainType: name,\n        index: seriesModel.get(name + 'Index'),\n        id: seriesModel.get(name + 'Id')\n      })[0];\n    });\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var dimensions = [{\n      name: 'x',\n      type: getDimTypeByAxis(xAxisType),\n      stackable: isStackable(xAxisType)\n    }, {\n      name: 'y',\n      // If two category axes\n      type: getDimTypeByAxis(yAxisType),\n      stackable: isStackable(yAxisType)\n    }];\n    var isXAxisCateogry = xAxisType === 'category';\n    var isYAxisCategory = yAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isXAxisCateogry) {\n      categoryAxesModels.x = xAxisModel;\n    }\n\n    if (isYAxisCategory) {\n      categoryAxesModels.y = yAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: seriesModel.get('singleAxisIndex'),\n      id: seriesModel.get('singleAxisId')\n    })[0];\n    var singleAxisType = singleAxisModel.get('type');\n    var isCategory = singleAxisType === 'category';\n    var dimensions = [{\n      name: 'single',\n      type: getDimTypeByAxis(singleAxisType),\n      stackable: isStackable(singleAxisType)\n    }];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isCategory) {\n      categoryAxesModels.single = singleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isCategory ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  polar: function (data, seriesModel, ecModel, completeDimOpt) {\n    var polarModel = ecModel.queryComponents({\n      mainType: 'polar',\n      index: seriesModel.get('polarIndex'),\n      id: seriesModel.get('polarId')\n    })[0];\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var radiusAxisType = radiusAxisModel.get('type');\n    var angleAxisType = angleAxisModel.get('type');\n    var dimensions = [{\n      name: 'radius',\n      type: getDimTypeByAxis(radiusAxisType),\n      stackable: isStackable(radiusAxisType)\n    }, {\n      name: 'angle',\n      type: getDimTypeByAxis(angleAxisType),\n      stackable: isStackable(angleAxisType)\n    }];\n    var isAngleAxisCateogry = angleAxisType === 'category';\n    var isRadiusAxisCateogry = radiusAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isRadiusAxisCateogry) {\n      categoryAxesModels.radius = radiusAxisModel;\n    }\n\n    if (isAngleAxisCateogry) {\n      categoryAxesModels.angle = angleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  geo: function (data, seriesModel, ecModel, completeDimOpt) {\n    // TODO Region\n    // \n    return {\n      dimensions: completeDimensions([{\n        name: 'lng'\n      }, {\n        name: 'lat'\n      }], data, completeDimOpt)\n    };\n  }\n};\n\nfunction createNameList(result, data) {\n  var nameList = [];\n  var categoryDim = result && result.dimensions[result.categoryIndex];\n  var categoryAxisModel;\n\n  if (categoryDim) {\n    categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n  }\n\n  if (categoryAxisModel) {\n    // FIXME Two category axis\n    var categories = categoryAxisModel.getCategories();\n\n    if (categories) {\n      var dataLen = data.length; // Ordered data is given explicitly like\n      // [[3, 0.2], [1, 0.3], [2, 0.15]]\n      // or given scatter data,\n      // pick the category\n\n      if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n        nameList = [];\n\n        for (var i = 0; i < dataLen; i++) {\n          nameList[i] = categories[data[i][result.categoryIndex || 0]];\n        }\n      } else {\n        nameList = categories.slice(0);\n      }\n    }\n  }\n\n  return nameList;\n}\n\nvar _default = createListFromArray;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 884:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar barLayoutGrid = __webpack_require__(1016);\n\n__webpack_require__(915);\n\n__webpack_require__(1005);\n\n__webpack_require__(1006);\n\n__webpack_require__(917);\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n/***/ }),\n\n/***/ 885:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar modelUtil = __webpack_require__(811);\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return seriesModel.coordDimToDataDim(dim)[0];\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 886:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar env = __webpack_require__(819);\n\nvar modelUtil = __webpack_require__(811);\n\nvar get = modelUtil.makeGetter();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  get(zr).records || (get(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = get(zr).records[key] || (get(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (get(zr).initialized) {\n    return;\n  }\n\n  get(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(get(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (get(zr).records || {})[key];\n\n  if (record) {\n    get(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n/***/ }),\n\n/***/ 887:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar graphic = __webpack_require__(808);\n\nvar textContain = __webpack_require__(844);\n\nvar formatUtil = __webpack_require__(822);\n\nvar matrix = __webpack_require__(848);\n\nvar axisHelper = __webpack_require__(846);\n\nvar AxisBuilder = __webpack_require__(888);\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n/***/ }),\n\n/***/ 888:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(794);\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = __webpack_require__(822);\n\nvar graphic = __webpack_require__(808);\n\nvar Model = __webpack_require__(823);\n\nvar _number = __webpack_require__(810);\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = __webpack_require__(875);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = __webpack_require__(848);\n\nvar _vector = __webpack_require__(812);\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.labelInterval] Default label interval when label\n *                                     interval from model is null or 'auto'.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);\n          symbol.attr({\n            rotation: item[0],\n            position: item[1],\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n/**\n * @static\n */\n\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {\n  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n    return false;\n  } // FIXME\n  // Have not consider label overlap (if label is too long) yet.\n\n\n  var rawTick;\n  var scale = axis.scale;\n  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n};\n/**\n * @static\n */\n\n\nvar getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n  var interval = model.get('interval');\n\n  if (interval == null || interval == 'auto') {\n    interval = labelInterval;\n  }\n\n  return interval;\n};\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var tickInterval = getInterval(tickModel, opt.labelInterval);\n  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME\n  // Corresponds to ticksCoords ?\n\n  var ticks = axis.scale.getTicks();\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n  var ticksCnt = ticksCoords.length;\n\n  for (var i = 0; i < ticksCnt; i++) {\n    // Only ordinal scale support tick interval\n    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {\n      continue;\n    }\n\n    var tickCoord = ticksCoords[i];\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticks[i],\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var ticks = axis.scale.getTicks();\n  var labels = axisModel.getFormattedLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var categoryData = axisModel.get('data');\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  each(ticks, function (tickVal, index) {\n    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {\n      return;\n    }\n\n    var itemLabelModel = labelModel;\n\n    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickVal);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var labelStr = axis.scale.getLabel(tickVal);\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickVal,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: labels[index],\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always returns labelStr.\n      // But in interval scale labelStr is like '223,445', which maked\n      // user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = labelStr;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 889:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(809);\n\nvar axisPointerModelHelper = __webpack_require__(854);\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 890:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\n/**\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, labelInterval, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var rawAxisPosition = axis.position;\n  var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (axis.onZero) {\n    var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);\n    var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // label interval when auto mode.\n\n  layout.labelInterval = axis.getLabelInterval(); // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n/***/ }),\n\n/***/ 891:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar numberUtil = __webpack_require__(810);\n\nvar axisHelper = __webpack_require__(846);\n\nvar linearMap = numberUtil.linearMap;\n\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n\nvar normalizedExtent = [0, 1];\n/**\n * @name module:echarts/coord/CartesianAxis\n * @constructor\n */\n\nvar Axis = function (dim, scale, extent) {\n  /**\n   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n   * @type {string}\n   */\n  this.dim = dim;\n  /**\n   * Axis scale\n   * @type {module:echarts/coord/scale/*}\n   */\n\n  this.scale = scale;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this._extent = extent || [0, 0];\n  /**\n   * @type {boolean}\n   */\n\n  this.inverse = false;\n  /**\n   * Usually true when axis has a ordinal scale\n   * @type {boolean}\n   */\n\n  this.onBand = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._labelInterval;\n};\n\nAxis.prototype = {\n  constructor: Axis,\n\n  /**\n   * If axis extent contain given coord\n   * @param {number} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  },\n\n  /**\n   * If axis extent contain given data\n   * @param {number} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.contain(this.dataToCoord(data));\n  },\n\n  /**\n   * Get coord extent.\n   * @return {Array.<number>}\n   */\n  getExtent: function () {\n    return this._extent.slice();\n  },\n\n  /**\n   * Get precision used for formatting\n   * @param {Array.<number>} [dataExtent]\n   * @return {number}\n   */\n  getPixelPrecision: function (dataExtent) {\n    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n  },\n\n  /**\n   * Set coord extent\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  },\n\n  /**\n   * Convert data to coord. Data is the rank if it has a ordinal scale\n   * @param {number} data\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  dataToCoord: function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    return linearMap(data, normalizedExtent, extent, clamp);\n  },\n\n  /**\n   * Convert coord to data. Data is the rank if it has a ordinal scale\n   * @param {number} coord\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  coordToData: function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    var t = linearMap(coord, extent, normalizedExtent, clamp);\n    return this.scale.scale(t);\n  },\n\n  /**\n   * Convert pixel point to data in axis\n   * @param {Array.<number>} point\n   * @param  {boolean} clamp\n   * @return {number} data\n   */\n  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicksCoords: function (alignWithLabel) {\n    if (this.onBand && !alignWithLabel) {\n      var bands = this.getBands();\n      var coords = [];\n\n      for (var i = 0; i < bands.length; i++) {\n        coords.push(bands[i][0]);\n      }\n\n      if (bands[i - 1]) {\n        coords.push(bands[i - 1][1]);\n      }\n\n      return coords;\n    } else {\n      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n    }\n  },\n\n  /**\n   * Coords of labels are on the ticks or on the middle of bands\n   * @return {Array.<number>}\n   */\n  getLabelsCoords: function () {\n    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n  },\n\n  /**\n   * Get bands.\n   *\n   * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n   * |---1---|---2---|---3---|---4---|.\n   *\n   * @return {Array}\n   */\n  // FIXME Situation when labels is on ticks\n  getBands: function () {\n    var extent = this.getExtent();\n    var bands = [];\n    var len = this.scale.count();\n    var start = extent[0];\n    var end = extent[1];\n    var span = end - start;\n\n    for (var i = 0; i < len; i++) {\n      bands.push([span * i / len + start, span * (i + 1) / len + start]);\n    }\n\n    return bands;\n  },\n\n  /**\n   * Get width of band\n   * @return {number}\n   */\n  getBandWidth: function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\n\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  },\n\n  /**\n   * @abstract\n   * @return {boolean} Is horizontal\n   */\n  isHorizontal: null,\n\n  /**\n   * @abstract\n   * @return {number} Get axis rotate, by degree.\n   */\n  getRotate: null,\n\n  /**\n   * Get interval of the axis label.\n   * To get precise result, at least one of `getRotate` and `isHorizontal`\n   * should be implemented.\n   * @return {number}\n   */\n  getLabelInterval: function () {\n    var labelInterval = this._labelInterval;\n\n    if (!labelInterval) {\n      var axisModel = this.model;\n      var labelModel = axisModel.getModel('axisLabel');\n      labelInterval = labelModel.get('interval');\n\n      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {\n        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));\n      }\n\n      this._labelInterval = labelInterval;\n    }\n\n    return labelInterval;\n  }\n};\nvar _default = Axis;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 892:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar axisHelper = __webpack_require__(846);\n\nfunction getName(obj) {\n  if (zrUtil.isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nvar _default = {\n  /**\n   * Format labels\n   * @return {Array.<string>}\n   */\n  getFormattedLabels: function () {\n    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n  },\n\n  /**\n   * Get categories\n   */\n  getCategories: function () {\n    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n   */\n  getMin: function (origin) {\n    var option = this.option;\n    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;\n\n    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {\n      min = this.axis.scale.parse(min);\n    }\n\n    return min;\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n   */\n  getMax: function (origin) {\n    var option = this.option;\n    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;\n\n    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {\n      max = this.axis.scale.parse(max);\n    }\n\n    return max;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  getNeedCrossZero: function () {\n    var option = this.option;\n    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n  },\n\n  /**\n   * Should be implemented by each axis model if necessary.\n   * @return {module:echarts/model/Component} coordinate system model\n   */\n  getCoordSysModel: zrUtil.noop,\n\n  /**\n   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n   */\n  setRange: function (rangeStart, rangeEnd) {\n    this.option.rangeStart = rangeStart;\n    this.option.rangeEnd = rangeEnd;\n  },\n\n  /**\n   * Reset range\n   */\n  resetRange: function () {\n    // rangeStart and rangeEnd is readonly.\n    this.option.rangeStart = this.option.rangeEnd = null;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 893:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar ComponentModel = __webpack_require__(838);\n\nvar axisModelCreator = __webpack_require__(938);\n\nvar axisModelCommonMixin = __webpack_require__(892);\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 894:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _clazz = __webpack_require__(824);\n\nvar set = _clazz.set;\nvar get = _clazz.get;\nvar _default = {\n  clearColorPalette: function () {\n    set(this, 'colorIdx', 0);\n    set(this, 'colorNameMap', {});\n  },\n  getColorFromPalette: function (name, scope) {\n    scope = scope || this;\n    var colorIdx = get(scope, 'colorIdx') || 0;\n    var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {}); // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n\n    if (colorNameMap.hasOwnProperty(name)) {\n      return colorNameMap[name];\n    }\n\n    var colorPalette = this.get('color', true) || [];\n\n    if (!colorPalette.length) {\n      return;\n    }\n\n    var color = colorPalette[colorIdx];\n\n    if (name) {\n      colorNameMap[name] = color;\n    }\n\n    set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n    return color;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 895:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar numberUtil = __webpack_require__(810);\n\n/**\n * For testable.\n */\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nfunction intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {\n  var ticks = []; // If interval is 0, return [];\n\n  if (!interval) {\n    return ticks;\n  } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n  var safeLimit = 10000;\n\n  if (extent[0] < niceTickExtent[0]) {\n    ticks.push(extent[0]);\n  }\n\n  var tick = niceTickExtent[0];\n\n  while (tick <= niceTickExtent[1]) {\n    ticks.push(tick); // Avoid rounding error\n\n    tick = roundNumber(tick + interval, intervalPrecision);\n\n    if (tick === ticks[ticks.length - 1]) {\n      // Consider out of safe float point, e.g.,\n      // -3711126.9907707 + 2e-10 === -3711126.9907707\n      break;\n    }\n\n    if (ticks.length > safeLimit) {\n      return [];\n    }\n  } // Consider this case: the last item of ticks is smaller\n  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n    ticks.push(extent[1]);\n  }\n\n  return ticks;\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;\nexports.intervalScaleGetTicks = intervalScaleGetTicks;\n\n/***/ }),\n\n/***/ 896:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar guid = __webpack_require__(903);\n\nvar Eventful = __webpack_require__(852);\n\nvar Transformable = __webpack_require__(911);\n\nvar Animatable = __webpack_require__(1000);\n\nvar zrUtil = __webpack_require__(794);\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * \n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * \n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender  element  zrender \n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * true\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * (shape) Group \n   * \n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // \n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // \n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 897:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Clip = __webpack_require__(974);\n\nvar color = __webpack_require__(853);\n\nvar _util = __webpack_require__(794);\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * \n   * @param  {number} time ms\n   * @param  {Object} props key-value\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * \n   * @param  {string|Function} [easing]\n   *         {@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * \n   * @param  {number} time ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 898:\n/***/ (function(module, exports) {\n\nvar _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 899:\n/***/ (function(module, exports) {\n\nvar PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n\n/***/ }),\n\n/***/ 900:\n/***/ (function(module, exports) {\n\nfunction windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n\n/***/ }),\n\n/***/ 901:\n/***/ (function(module, exports) {\n\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 902:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar vec2 = __webpack_require__(812);\n\nvar curve = __webpack_require__(847);\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * `min``max`\n * @module zrender/core/bbox\n * @param {Array<Object>} points \n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * (p0, p1, p2, p3)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * (p0, p1, p2)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * `min``max`\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n\n/***/ }),\n\n/***/ 903:\n/***/ (function(module, exports) {\n\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 904:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(857);\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 905:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Displayable = __webpack_require__(878);\n\nvar BoundingRect = __webpack_require__(821);\n\nvar zrUtil = __webpack_require__(794);\n\nvar imageHelper = __webpack_require__(880);\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // \n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 906:\n/***/ (function(module, exports) {\n\nvar Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 907:\n/***/ (function(module, exports) {\n\nvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 908:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar smoothSpline = __webpack_require__(989);\n\nvar smoothBezier = __webpack_require__(988);\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n\n/***/ }),\n\n/***/ 909:\n/***/ (function(module, exports) {\n\nfunction buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n\n/***/ }),\n\n/***/ 910:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(794);\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = __webpack_require__(844);\n\nvar roundRectHelper = __webpack_require__(909);\n\nvar imageHelper = __webpack_require__(880);\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n\n/***/ }),\n\n/***/ 911:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar matrix = __webpack_require__(848);\n\nvar vector = __webpack_require__(812);\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * \n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * \n * , position, rotation, scaletransformtransform\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // \n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // \n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * transformcontext\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * `transform``position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n *  shape \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 912:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar guid = __webpack_require__(903);\n\nvar env = __webpack_require__(819);\n\nvar zrUtil = __webpack_require__(794);\n\nvar Handler = __webpack_require__(969);\n\nvar Storage = __webpack_require__(972);\n\nvar Painter = __webpack_require__(971);\n\nvar Animation = __webpack_require__(973);\n\nvar HandlerProxy = __webpack_require__(983);\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRendermap\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; //  storage.delFromStorage, \n  // FIXME ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * \n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * \n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * \n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default']  crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n\n/***/ }),\n\n/***/ 914:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\n__webpack_require__(1042);\n\n__webpack_require__(1044);\n\n__webpack_require__(1043);\n\nvar legendFilter = __webpack_require__(1045);\n\nvar Component = __webpack_require__(838);\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n/***/ }),\n\n/***/ 915:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar BoundingRect = __webpack_require__(821);\n\nvar _layout = __webpack_require__(845);\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = __webpack_require__(846);\n\nvar Cartesian2D = __webpack_require__(941);\n\nvar Axis2D = __webpack_require__(939);\n\nvar CoordinateSystem = __webpack_require__(872);\n\n__webpack_require__(942);\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar env = __webpack_require__(819);\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 917:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar graphic = __webpack_require__(808);\n\n__webpack_require__(915);\n\n__webpack_require__(926);\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n/***/ }),\n\n/***/ 922:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        multi: {\n            type: String\n        },\n        fields: Array,\n        paramVersion: {\n            type: String,\n            default: function _default() {\n                return \"v2\";\n            }\n        },\n        isWithExts: {\n            type: Boolean,\n            default: function _default() {\n                return true;\n            }\n        }\n\n    },\n    mounted: function mounted() {\n        if (this.$store.state.resolution === 'low') {\n            this.conditionWdith = '80px';\n        }\n        this.getDivHeight();\n    },\n    data: function data() {\n        var _this = this;\n        return {\n            conditionWdith: '85px',\n            a_type: 1,\n            a_val: null,\n            fieldValues: !this.fields ? [] : _.map(this.fields, function (e) {\n                return _.extend({ value: null }, e);\n            }),\n            pickerOptions: {\n                shortcuts: [{\n                    text: '',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(0);\n                        var end = _this.recentDate(0);\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(1);\n                        var end = _this.recentDate(1);\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '1',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(-1);\n                        var end = _this.recentDate(1);\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '2',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(-2);\n                        var end = _this.recentDate(2);\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '',\n                    onClick: function onClick(picker) {\n                        var start = _this.formatDate(new Date().getTime() - 3600 * 1000 * 24 * (new Date().getDate() - 1), 'yy-mm-dd');\n                        var end = _this.formatDate(new Date().getTime() - 3600 * 1000 * 24 * (new Date().getDate() - 1) + 3600 * 1000 * 24 * (_this.$store.state.daycount - 1), 'yy-mm-dd');\n                        picker.$emit('pick', [start, end]);\n                    }\n                }]\n            },\n            pickerOptionsI: {\n                shortcuts: [{\n                    text: '',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(0) + ' 00:00:00';\n                        var end = _this.recentDate(0) + ' 23:59:59';\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(1) + ' 00:00:00';\n                        var end = _this.recentDate(1) + ' 23:59:59';\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '1',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(-1) + ' 00:00:00';\n                        var end = _this.recentDate(1) + ' 23:59:59';\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '2',\n                    onClick: function onClick(picker) {\n                        var start = _this.recentDate(-2) + ' 00:00:00';\n                        var end = _this.recentDate(2) + ' 23:59:59';\n                        picker.$emit('pick', [start, end]);\n                    }\n                }, {\n                    text: '',\n                    onClick: function onClick(picker) {\n                        var start = _this.formatDate(new Date().getTime() - 3600 * 1000 * 24 * (new Date().getDate() - 1), 'yy-mm-dd') + ' 00:00:00';\n                        var end = _this.formatDate(new Date().getTime() - 3600 * 1000 * 24 * (new Date().getDate() - 1) + 3600 * 1000 * 24 * (_this.$store.state.daycount - 1), 'yy-mm-dd') + ' 23:59:59';\n                        picker.$emit('pick', [start, end]);\n                    }\n                }]\n            }\n        };\n    },\n\n    methods: {\n        //\n        init: function init() {\n            this.onSearchButtonClick();\n        },\n        getDivHeight: function getDivHeight() {\n            return this.$refs.formHeight.offsetHeight;\n        },\n\n        //\n        onSearchButtonClick: function onSearchButtonClick() {\n            var _this = this;\n            var tmpParmas = {};\n            var tmpParmasII = \"\";\n            var a = '',\n                b = '',\n                temp = '',\n                c = '';\n            //this.$emit('toggleSearch');\n            //search Object\n            _.each(_this.fieldValues, function (node, index) {\n                if (node.fieldName) {\n                    tmpParmas[node.fieldName] = node.value instanceof Date ? _this.formatDate(node.value, 'hms') : node.value;\n                }\n                if (node.fieldName === 'dateRange' || 'forbidden_daterange') {\n                    if (tmpParmas['dateRange']) {\n                        tmpParmas['builddate_ge_date'] = _this.formatDate(tmpParmas['dateRange'][0], 'yy-mm-dd');\n                        tmpParmas['builddate_le_date'] = _this.formatDate(tmpParmas['dateRange'][1], 'yy-mm-dd');\n                    }\n                    if (node.fieldName === 'forbidden_daterange') {\n                        if (tmpParmas['forbidden_daterange']) {\n                            tmpParmas['builddate_ge_date'] = _this.formatDate(tmpParmas['forbidden_daterange'][0], 'yy-mm-dd');\n                            tmpParmas['builddate_le_date'] = _this.formatDate(tmpParmas['forbidden_daterange'][1], 'yy-mm-dd');\n                        }\n                    }\n                }\n            });\n            this.$emit('search', this.isWithExts ? { exts: tmpParmas } : tmpParmas);\n\n            //searchII String\n            if (this.fieldValues[0].type === 'daterange') {\n                if (this.a_val) {\n                    if (this.a_type === 2) {\n                        c += 'balanceprice_ne=' + this.a_val;\n                    } else {\n                        c += 'balanceprice=' + this.a_val;\n                    }\n                }\n                for (var index = 1; index < this.fieldValues.length; index++) {\n                    if (tmpParmas['datehandle'] && this.fieldValues[0].value) {\n                        temp = this.fieldValues[index].value || '';\n                        a += this.fieldValues[index].fieldName + '=' + temp + '&';\n                        b = this.fieldValues[0].label + '_ge_date' + '=' + _this.formatDate(tmpParmas['datehandle'][0], 'yy-mm-dd') + '&' + this.fieldValues[0].label + '_le_date' + '=' + _this.formatDate(tmpParmas['datehandle'][1], 'yy-mm-dd') + '&';\n                        if (tmpParmas['datehandle'][0] === null) {\n                            temp = this.fieldValues[index].value || '';\n                            a += this.fieldValues[index].fieldName + '=' + temp + '&';\n                            b = '';\n                        }\n                    }\n                }\n                b ? tmpParmasII = a + b + c : tmpParmasII = a + c;\n            }\n            if (this.fieldValues[0].type === 'select') {\n                for (var _index = 2; _index < this.fieldValues.length; _index++) {\n                    temp = this.fieldValues[_index].value || '';\n                    a += this.fieldValues[_index].fieldName + '=' + temp + '&';\n                    if (tmpParmas['datehandle'] && this.fieldValues[0].value) {\n                        b = this.fieldValues[0].value + '_ge_date' + '=' + _this.formatDate(tmpParmas['datehandle'][0], 'ymdhM') + '&' + this.fieldValues[0].value + '_le_date' + '=' + _this.formatDate(tmpParmas['datehandle'][1], 'ymdhM') + '&';\n                    }\n                }\n                tmpParmasII = a + b;\n            }\n            tmpParmasII = tmpParmasII.substring(tmpParmasII.length - 1) === '&' ? tmpParmasII.substring(0, tmpParmasII.length - 1) : tmpParmasII;\n            this.$emit('searchII', tmpParmasII);\n        },\n\n\n        //\n        onRestButtonClick: function onRestButtonClick() {\n            for (var i = 0; i < this.fieldValues.length; i++) {\n                if (this.fieldValues[i].fieldName === 'forbidden_daterange') {} else {\n                    this.fieldValues[i].value = '';\n                }\n            }\n            this.a_val = '';\n            this.$emit('reset');\n            this.sdate = null;\n            this.edate = null;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ 923:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    props: {\n        tableData: Array,\n        itemValues: Array,\n        tabHeight: Number,\n        isLoading: Boolean\n    },\n    data: function data() {\n        return {\n            isbutton: false,\n            buttontype: null,\n            arrValues: this.itemValues || [],\n            //tabHeight:610,\n            inboxcdData: [],\n            tagSearch: [],\n            checkList: ['0', '1']\n        };\n    },\n\n    watch: {\n        'tableData': 'getTableData'\n    },\n\n    mounted: function mounted() {\n        this.jungleHeight();\n        this.getHeight();\n    },\n\n    methods: {\n        //\n        buttonClick: function buttonClick(type, index, data) {\n            if (type === 'edit') {\n                this.$emit('show', type, index, data);\n            } else if (type === 'delete') {\n                this.$emit('delete', index, data);\n            } else if (type === 'editRoute') {\n                this.$emit('editRoute', index, data);\n            } else if (type === 'detail') {\n                this.$emit('detail', index, data);\n            } else {\n                console.log(type);\n            }\n        },\n        buttonClickI: function buttonClickI(type, index, data) {\n            if (type === 'edit') {\n                this.$emit('show', type, index, data);\n            } else if (type === 'delete') {\n                this.$emit('delete', index, data);\n            } else if (type === 'editRoute') {\n                this.$emit('editRoute', index, data);\n            } else {\n                console.log(type);\n            }\n        },\n        checkChange: function checkChange(row) {\n            //this.$emit('ischeckbox',row)\n        },\n\n\n        //\n        getHeight: function getHeight(val) {\n            //this.tabHeight = val;\n        },\n\n\n        //\n        filterTag: function filterTag(value, row) {\n            return row.clientname === value;\n        },\n\n\n        //tagSearch\n        getTableData: function getTableData() {\n            var _this = this;\n            this.tagSearch = [];\n            for (var i = 0; i < this.tableData.length; i++) {\n                this.tagSearch.push({ text: this.tableData[i].clientname, value: this.tableData[i].clientname });\n            }\n            this.tagSearch = _this.reduceObj(this.tagSearch, 'text');\n        },\n\n\n        //\n        ischeckbox: function ischeckbox(row) {\n            this.inboxcdData = [];\n            if (row.length) {\n                for (var i = 0; i < row.length; i++) {\n                    this.inboxcdData.push(row[i].inboxcd);\n                }\n            }\n            this.$emit('getcheckbox', this.inboxcdData);\n        },\n\n\n        //\n        getIsbutton: function getIsbutton() {\n            var tempData = this.tableData;\n            // this.isbutton =true;\n            // if(this.arrValues[6].buttons.label === ''){\n            //     this.isbutton = true;\n            // }\n            // for(let index in tempData) {\n            //     if (tempData[index].status === '') {\n            //         this.isbutton =true;\n            //         console.log(222)\n            //     }else if(tempData[index].status === ''){\n            //         //this.tableData[index].status = ''\n            //     }else if(tempData[index].status === ''){\n            //         //this.tableData[index].status = ''\n            //     }\n            // }\n        },\n        handleSelectionChange: function handleSelectionChange(val) {\n            console.log(val);\n        },\n        jungleHeight: function jungleHeight() {\n            if (this.$store.state.resolution === 'high') {\n                //this.tabHeight = 610;\n            } else if (this.$store.state.resolution === 'low') {\n                // this.tabHeight = 460;\n            }\n        },\n\n\n        //-- \n        format: function format(row, column, cellValue) {\n            return this.formatDate(cellValue, 'ymdhM');\n        }\n    }\n});\n\n/***/ }),\n\n/***/ 924:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(656)(true);\n// imports\n\n\n// module\nexports.push([module.i, \".inputwidth[data-v-39b0517a]{width:220px}.selectwidth[data-v-39b0517a]{width:91px}.framewidth[data-v-39b0517a]{width:220px}\", \"\", {\"version\":3,\"sources\":[\"F:/pc_project/erp-aluminium/yunerp/src/components/ZLCommonSearch.vue\"],\"names\":[],\"mappings\":\"AACA,6BACE,WAAa,CACd,AACD,8BACE,UAAY,CACb,AACD,6BACE,WAAa,CACd\",\"file\":\"ZLCommonSearch.vue\",\"sourcesContent\":[\"\\n.inputwidth[data-v-39b0517a] {\\n  width: 220px;\\n}\\n.selectwidth[data-v-39b0517a] {\\n  width: 91px;\\n}\\n.framewidth[data-v-39b0517a] {\\n  width: 220px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 925:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\nfunction ExtensionAPI(chartInstance) {\n  zrUtil.each(echartsAPIList, function (name) {\n    this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n  }, this);\n}\n\nvar _default = ExtensionAPI;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 926:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(893);\n\n__webpack_require__(933);\n\n/***/ }),\n\n/***/ 927:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar axisPointerModelHelper = __webpack_require__(854);\n\nvar axisTrigger = __webpack_require__(932);\n\n__webpack_require__(928);\n\n__webpack_require__(929);\n\n__webpack_require__(931);\n\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 929:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar globalListener = __webpack_require__(886);\n\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 930:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar clazzUtil = __webpack_require__(824);\n\nvar graphic = __webpack_require__(808);\n\nvar axisPointerModelHelper = __webpack_require__(854);\n\nvar eventTool = __webpack_require__(851);\n\nvar throttleUtil = __webpack_require__(876);\n\nvar modelUtil = __webpack_require__(811);\n\nvar get = modelUtil.makeGetter();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = get(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = get(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = get(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    get(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(get(el).lastProp, props)) {\n    get(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 931:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(808);\n\nvar BaseAxisPointer = __webpack_require__(930);\n\nvar viewHelper = __webpack_require__(887);\n\nvar cartesianAxisHelper = __webpack_require__(890);\n\nvar AxisView = __webpack_require__(889);\n\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = axis.getBandWidth();\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 932:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar modelUtil = __webpack_require__(811);\n\nvar modelHelper = __webpack_require__(854);\n\nvar findPointFromSeries = __webpack_require__(885);\n\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar get = modelUtil.makeGetter();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.coordDimToDataDim(dim);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      false, axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = get(zr)[highDownKey] || {};\n  var newHighlights = get(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 933:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar graphic = __webpack_require__(808);\n\nvar AxisBuilder = __webpack_require__(888);\n\nvar AxisView = __webpack_require__(889);\n\nvar cartesianAxisHelper = __webpack_require__(890);\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n/***/ }),\n\n/***/ 934:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar zrColor = __webpack_require__(853);\n\nvar eventUtil = __webpack_require__(851);\n\nvar env = __webpack_require__(819);\n\nvar formatUtil = __webpack_require__(822);\n\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 935:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    //  {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    //  content  viewRect  false \n    confine: false,\n    // {string}Template  {Function}\n    // formatter: null\n    showDelay: 0,\n    // ms\n    hideDelay: 100,\n    // s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 0.7\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // \n    borderColor: '#333',\n    // px4\n    borderRadius: 4,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // \n    axisPointer: {\n      // \n      // 'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type  line  tooltip line \n      //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n      //  'auto' cateogry  x \n      //  angle \n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 936:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(809);\n\nvar zrUtil = __webpack_require__(794);\n\nvar env = __webpack_require__(819);\n\nvar TooltipContent = __webpack_require__(934);\n\nvar formatUtil = __webpack_require__(822);\n\nvar numberUtil = __webpack_require__(810);\n\nvar graphic = __webpack_require__(808);\n\nvar findPointFromSeries = __webpack_require__(885);\n\nvar layoutUtil = __webpack_require__(845);\n\nvar Model = __webpack_require__(823);\n\nvar globalListener = __webpack_require__(886);\n\nvar axisHelper = __webpack_require__(846);\n\nvar axisPointerViewHelper = __webpack_require__(887);\n\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (tooltipOpt instanceof Model) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 937:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // \n  z: 0,\n  // \n  // \n  inverse: false,\n  // \n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // degree\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // \n  nameTextStyle: {},\n  // \n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // \n  axisLine: {\n    // show\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // lineStyle\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // \n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // \n  axisTick: {\n    // show\n    show: true,\n    // grid\n    inside: false,\n    // length\n    length: 5,\n    // lineStyle\n    lineStyle: {\n      width: 1\n    }\n  },\n  // axis.axisLabel\n  axisLabel: {\n    show: true,\n    // grid\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // TEXTSTYLE\n    fontSize: 12\n  },\n  // \n  splitLine: {\n    // show\n    show: true,\n    // lineStylelineStyle\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // \n  splitArea: {\n    // show\n    show: false,\n    // areaStyleareaStyle\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // \n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // \n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // \n  boundaryGap: [0, 0],\n  // ,  'dataMin' \n  // min: null,\n  //  'dataMax' \n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 0_min_max\n  // scale: false,\n  // 5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 938:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar axisDefault = __webpack_require__(937);\n\nvar ComponentModel = __webpack_require__(838);\n\nvar _layout = __webpack_require__(845);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 939:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Axis = __webpack_require__(891);\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 940:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 941:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Cartesian = __webpack_require__(940);\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 942:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(893);\n\nvar ComponentModel = __webpack_require__(838);\n\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 943:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BoundingRect = __webpack_require__(821);\n\nvar bbox = __webpack_require__(902);\n\nvar vec2 = __webpack_require__(812);\n\nvar polygonContain = __webpack_require__(980);\n\n/**\n * @module echarts/coord/geo/Region\n */\n\n/**\n * @param {string} name\n * @param {Array} geometries\n * @param {Array.<number>} cp\n */\nfunction Region(name, geometries, cp) {\n  /**\n   * @type {string}\n   * @readOnly\n   */\n  this.name = name;\n  /**\n   * @type {Array.<Array>}\n   * @readOnly\n   */\n\n  this.geometries = geometries;\n\n  if (!cp) {\n    var rect = this.getBoundingRect();\n    cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  } else {\n    cp = [cp[0], cp[1]];\n  }\n  /**\n   * @type {Array.<number>}\n   */\n\n\n  this.center = cp;\n}\n\nRegion.prototype = {\n  constructor: Region,\n  properties: null,\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    var rect = this._rect;\n\n    if (rect) {\n      return rect;\n    }\n\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * @param {<Array.<number>} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n  transformTo: function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n};\nvar _default = Region;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 944:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Region = __webpack_require__(943);\n\n/**\n * Parse and decode geo json\n * @module echarts/coord/geo/parseGeoJson\n */\nfunction decode(json) {\n  if (!json.UTF8Encoding) {\n    return json;\n  }\n\n  var encodeScale = json.UTF8Scale;\n\n  if (encodeScale == null) {\n    encodeScale = 1024;\n  }\n\n  var features = json.features;\n\n  for (var f = 0; f < features.length; f++) {\n    var feature = features[f];\n    var geometry = feature.geometry;\n    var coordinates = geometry.coordinates;\n    var encodeOffsets = geometry.encodeOffsets;\n\n    for (var c = 0; c < coordinates.length; c++) {\n      var coordinate = coordinates[c];\n\n      if (geometry.type === 'Polygon') {\n        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (var c2 = 0; c2 < coordinate.length; c2++) {\n          var polygon = coordinate[c2];\n          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);\n        }\n      }\n    }\n  } // Has been decoded\n\n\n  json.UTF8Encoding = false;\n  return json;\n}\n\nfunction decodePolygon(coordinate, encodeOffsets, encodeScale) {\n  var result = [];\n  var prevX = encodeOffsets[0];\n  var prevY = encodeOffsets[1];\n\n  for (var i = 0; i < coordinate.length; i += 2) {\n    var x = coordinate.charCodeAt(i) - 64;\n    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding\n\n    x = x >> 1 ^ -(x & 1);\n    y = y >> 1 ^ -(y & 1); // Delta deocding\n\n    x += prevX;\n    y += prevY;\n    prevX = x;\n    prevY = y; // Dequantize\n\n    result.push([x / encodeScale, y / encodeScale]);\n  }\n\n  return result;\n}\n/**\n * @alias module:echarts/coord/geo/parseGeoJson\n * @param {Object} geoJson\n * @return {module:zrender/container/Group}\n */\n\n\nfunction _default(geoJson) {\n  decode(geoJson);\n  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {\n    // Output of mapshaper may have geometry null\n    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;\n  }), function (featureObj) {\n    var properties = featureObj.properties;\n    var geo = featureObj.geometry;\n    var coordinates = geo.coordinates;\n    var geometries = [];\n\n    if (geo.type === 'Polygon') {\n      geometries.push({\n        type: 'polygon',\n        // According to the GeoJSON specification.\n        // First must be exterior, and the rest are all interior(holes).\n        exterior: coordinates[0],\n        interiors: coordinates.slice(1)\n      });\n    }\n\n    if (geo.type === 'MultiPolygon') {\n      zrUtil.each(coordinates, function (item) {\n        if (item[0]) {\n          geometries.push({\n            type: 'polygon',\n            exterior: item[0],\n            interiors: item.slice(1)\n          });\n        }\n      });\n    }\n\n    var region = new Region(properties.name, geometries, properties.cp);\n    region.properties = properties;\n    return region;\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 945:\n/***/ (function(module, exports) {\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n/**\n * @param {Array} oldArr\n * @param {Array} newArr\n * @param {Function} oldKeyGetter\n * @param {Function} newKeyGetter\n * @param {Object} [context] Can be visited by this.context in callback.\n */\n\n\nfunction DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {\n  this._old = oldArr;\n  this._new = newArr;\n  this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n  this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n  this.context = context;\n}\n\nDataDiffer.prototype = {\n  constructor: DataDiffer,\n\n  /**\n   * Callback function when add a data\n   */\n  add: function (func) {\n    this._add = func;\n    return this;\n  },\n\n  /**\n   * Callback function when update a data\n   */\n  update: function (func) {\n    this._update = func;\n    return this;\n  },\n\n  /**\n   * Callback function when remove a data\n   */\n  remove: function (func) {\n    this._remove = func;\n    return this;\n  },\n  execute: function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    var i;\n    initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);\n    initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this); // Travel by inverted order to make sure order consistency\n    // when duplicate keys exists (consider newDataIndex.pop() below).\n    // For performance consideration, these code below do not look neat.\n\n    for (i = 0; i < oldArr.length; i++) {\n      var key = oldDataKeyArr[i];\n      var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.\n\n      if (idx != null) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var len = idx.length;\n\n        if (len) {\n          len === 1 && (newDataIndexMap[key] = null);\n          idx = idx.unshift();\n        } else {\n          newDataIndexMap[key] = null;\n        }\n\n        this._update && this._update(idx, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var key = newDataKeyArr[i];\n\n      if (newDataIndexMap.hasOwnProperty(key)) {\n        var idx = newDataIndexMap[key];\n\n        if (idx == null) {\n          continue;\n        } // idx can never be empty array here. see 'set null' logic above.\n\n\n        if (!idx.length) {\n          this._add && this._add(idx);\n        } else {\n          for (var j = 0, len = idx.length; j < len; j++) {\n            this._add && this._add(idx[j]);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {\n  for (var i = 0; i < arr.length; i++) {\n    // Add prefix to avoid conflict with Object.prototype.\n    var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);\n    var existence = map[key];\n\n    if (existence == null) {\n      keyArr.push(key);\n      map[key] = i;\n    } else {\n      if (!existence.length) {\n        map[key] = existence = [existence];\n      }\n\n      existence.push(i);\n    }\n  }\n}\n\nvar _default = DataDiffer;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 946:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrender = __webpack_require__(912);\n\nexports.zrender = zrender;\n\nvar matrix = __webpack_require__(848);\n\nexports.matrix = matrix;\n\nvar vector = __webpack_require__(812);\n\nexports.vector = vector;\n\nvar zrUtil = __webpack_require__(794);\n\nvar colorTool = __webpack_require__(853);\n\nexports.color = colorTool;\n\nvar graphic = __webpack_require__(808);\n\nexports.graphic = graphic;\n\nvar numberUtil = __webpack_require__(810);\n\nexports.number = numberUtil;\n\nvar formatUtil = __webpack_require__(822);\n\nexports.format = formatUtil;\n\nvar _throttle = __webpack_require__(876);\n\nvar throttle = _throttle.throttle;\nexports.throttle = _throttle.throttle;\n\nvar ecHelper = __webpack_require__(947);\n\nexports.helper = ecHelper;\n\nvar _List = __webpack_require__(855);\n\nexports.List = _List;\n\nvar _Model = __webpack_require__(823);\n\nexports.Model = _Model;\n\nvar _Axis = __webpack_require__(891);\n\nexports.Axis = _Axis;\n\nvar _env = __webpack_require__(819);\n\nexports.env = _env;\n\nvar _parseGeoJson = __webpack_require__(944);\n\nexports.parseGeoJson = _parseGeoJson;\n\n/**\n * Do not mount those modules on 'src/echarts' for better tree shaking.\n */\nvar ecUtil = {};\nzrUtil.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {\n  ecUtil[name] = zrUtil[name];\n});\nexports.util = ecUtil;\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar createListFromArray = __webpack_require__(883);\n\nvar axisHelper = __webpack_require__(846);\n\nvar axisModelCommonMixin = __webpack_require__(892);\n\nvar Model = __webpack_require__(823);\n\nvar _completeDimensions = __webpack_require__(882);\n\nexports.completeDimensions = _completeDimensions;\n\nvar _symbol = __webpack_require__(875);\n\nexports.createSymbol = _symbol.createSymbol;\n\n/**\n * Create a muti dimension List structure from seriesModel.\n * @param  {module:echarts/model/Model} seriesModel\n * @return {module:echarts/data/List} list\n */\nfunction createList(seriesModel) {\n  var data = seriesModel.get('data');\n  return createListFromArray(data, seriesModel, seriesModel.ecModel);\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n */\n\n\n/**\n * Create scale\n * @param {Array.<number>} dataExtent\n * @param {Object|module:echarts/Model} option\n */\nfunction createScale(dataExtent, option) {\n  var axisModel = option;\n\n  if (!(option instanceof Model)) {\n    axisModel = new Model(option);\n    zrUtil.mixin(axisModel, axisModelCommonMixin);\n  }\n\n  var scale = axisHelper.createScaleByModel(axisModel);\n  scale.setExtent(dataExtent[0], dataExtent[1]);\n  axisHelper.niceScaleExtent(scale, axisModel);\n  return scale;\n}\n/**\n * Mixin common methods to axis model,\n *\n * Inlcude methods\n * `getFormattedLabels() => Array.<string>`\n * `getCategories() => Array.<string>`\n * `getMin(origin: boolean) => number`\n * `getMax(origin: boolean) => number`\n * `getNeedCrossZero() => boolean`\n * `setRange(start: number, end: number)`\n * `resetRange()`\n */\n\n\nfunction mixinAxisModelCommonMethods(Model) {\n  zrUtil.mixin(Model, axisModelCommonMixin);\n}\n\nexports.createList = createList;\nexports.createScale = createScale;\nexports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;\n\n/***/ }),\n\n/***/ 948:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar graphic = __webpack_require__(808);\n\nvar PI = Math.PI;\n/**\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} [opts]\n * @param {string} [opts.text]\n * @param {string} [opts.color]\n * @param {string} [opts.textColor]\n * @return {module:zrender/Element}\n */\n\nfunction _default(api, opts) {\n  opts = opts || {};\n  zrUtil.defaults(opts, {\n    text: 'loading',\n    color: '#c23531',\n    textColor: '#000',\n    maskColor: 'rgba(255, 255, 255, 0.8)',\n    zlevel: 0\n  });\n  var mask = new graphic.Rect({\n    style: {\n      fill: opts.maskColor\n    },\n    zlevel: opts.zlevel,\n    z: 10000\n  });\n  var arc = new graphic.Arc({\n    shape: {\n      startAngle: -PI / 2,\n      endAngle: -PI / 2 + 0.1,\n      r: 10\n    },\n    style: {\n      stroke: opts.color,\n      lineCap: 'round',\n      lineWidth: 5\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  var labelRect = new graphic.Rect({\n    style: {\n      fill: 'none',\n      text: opts.text,\n      textPosition: 'right',\n      textDistance: 10,\n      textFill: opts.textColor\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  arc.animateShape(true).when(1000, {\n    endAngle: PI * 3 / 2\n  }).start('circularInOut');\n  arc.animateShape(true).when(1000, {\n    startAngle: PI * 3 / 2\n  }).delay(300).start('circularInOut');\n  var group = new graphic.Group();\n  group.add(arc);\n  group.add(labelRect);\n  group.add(mask); // Inject resize\n\n  group.resize = function () {\n    var cx = api.getWidth() / 2;\n    var cy = api.getHeight() / 2;\n    arc.setShape({\n      cx: cx,\n      cy: cy\n    });\n    var r = arc.shape.r;\n    labelRect.setShape({\n      x: cx - r,\n      y: cy - r,\n      width: r * 2,\n      height: r * 2\n    });\n    mask.setShape({\n      x: 0,\n      y: 0,\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  };\n\n  group.resize();\n  return group;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 949:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(820);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(794);\n\nvar modelUtil = __webpack_require__(811);\n\nvar Model = __webpack_require__(823);\n\nvar ComponentModel = __webpack_require__(838);\n\nvar globalDefault = __webpack_require__(951);\n\nvar colorPaletteMinin = __webpack_require__(894);\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar each = zrUtil.each;\nvar filter = zrUtil.filter;\nvar map = zrUtil.map;\nvar isArray = zrUtil.isArray;\nvar indexOf = zrUtil.indexOf;\nvar isObject = zrUtil.isObject;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  constructor: GlobalModel,\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = []; //  component model  merge\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n      } else {\n        newCptTypes.push(mainType);\n      }\n    }); // FIXME OPTION \n\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n    this._seriesIndices = this._seriesIndices || [];\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel instanceof ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name;\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = zrUtil.extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            zrUtil.extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n      }\n    }\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = zrUtil.clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series'},\n   *     function (model, index) {...}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (zrUtil.isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    this._seriesIndices = createSeriesIndices(filteredSeries);\n  },\n  restoreData: function () {\n    var componentsMap = this._componentsMap;\n    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        component.restoreData();\n      });\n    });\n  }\n});\n/**\n * @inner\n */\n\nfunction mergeTheme(option, theme) {\n  zrUtil.each(theme, function (themeItem, name) {\n    //  component model  merge  model \n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = zrUtil.createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices = null;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  zrUtil.merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!zrUtil.isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(seriesModels) {\n  return map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || [];\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nzrUtil.mixin(GlobalModel, colorPaletteMinin);\nvar _default = GlobalModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 950:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar modelUtil = __webpack_require__(811);\n\nvar ComponentModel = __webpack_require__(838);\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\n * TERM EXPLANATIONS:\n *\n * [option]:\n *\n *     An object that contains definitions of components. For example:\n *     var option = {\n *         title: {...},\n *         legend: {...},\n *         visualMap: {...},\n *         series: [\n *             {data: [...]},\n *             {data: [...]},\n *             ...\n *         ]\n *     };\n *\n * [rawOption]:\n *\n *     An object input to echarts.setOption. 'rawOption' may be an\n *     'option', or may be an object contains multi-options. For example:\n *     var option = {\n *         baseOption: {\n *             title: {...},\n *             legend: {...},\n *             series: [\n *                 {data: [...]},\n *                 {data: [...]},\n *                 ...\n *             ]\n *         },\n *         timeline: {...},\n *         options: [\n *             {title: {...}, series: {data: [...]}},\n *             {title: {...}, series: {data: [...]}},\n *             ...\n *         ],\n *         media: [\n *             {\n *                 query: {maxWidth: 320},\n *                 option: {series: {x: 20}, visualMap: {show: false}}\n *             },\n *             {\n *                 query: {minWidth: 320, maxWidth: 720},\n *                 option: {series: {x: 500}, visualMap: {show: true}}\n *             },\n *             {\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\n *             }\n *         ]\n *     };\n *\n * @alias module:echarts/model/OptionManager\n * @param {module:echarts/ExtensionAPI} api\n */\n\nfunction OptionManager(api) {\n  /**\n   * @private\n   * @type {module:echarts/ExtensionAPI}\n   */\n  this._api = api;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._timelineOptions = [];\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n\n  this._mediaList = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._mediaDefault;\n  /**\n   * -1, means default.\n   * empty means no media.\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._currentMediaIndices = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._optionBackup;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\n   * @public\n   * @param {Object} rawOption Raw option.\n   * @param {module:echarts/model/Global} ecModel\n   * @param {Array.<Function>} optionPreprocessorFuncs\n   * @return {Object} Init option\n   */\n  setOption: function (rawOption, optionPreprocessorFuncs) {\n    rawOption = clone(rawOption, true); // FIXME\n    //  timeline options  media baseOption\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\n   * @param {boolean} isRecreate\n   * @return {Object}\n   */\n  mountOption: function (isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // resetclone\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Object}\n   */\n  getTimelineOption: function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Array.<Object>}\n   */\n  getMediaOption: function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // mediaDefault\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 951:\n/***/ (function(module, exports) {\n\nvar platform = ''; // Navigator not exists in node\n\nif (typeof navigator !== 'undefined') {\n  platform = navigator.platform || '';\n}\n\nvar _default = {\n  // \n  // backgroundColor: 'rgba(0,0,0,0)',\n  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n  // \n  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n  // \n  color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],\n  //  Grid \n  // grid: {},\n  // \n  textStyle: {\n    // color: '#000',\n    // decoration: 'none',\n    // PENDING\n    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n    // fontFamily: 'Arial, Verdana, sans-serif',\n    fontSize: 12,\n    fontStyle: 'normal',\n    fontWeight: 'normal'\n  },\n  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n  // Default is source-over\n  blendMode: null,\n  animation: 'auto',\n  animationDuration: 1000,\n  animationDurationUpdate: 300,\n  animationEasing: 'exponentialOut',\n  animationEasingUpdate: 'cubicOut',\n  animationThreshold: 2000,\n  // Configuration for progressive/incremental rendering\n  progressiveThreshold: 3000,\n  progressive: 400,\n  // Threshold of if use single hover layer to optimize.\n  // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n  // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n  // which is unexpected.\n  // see example <echarts/test/heatmap-large.html>.\n  hoverLayerThreshold: 3000,\n  // See: module:echarts/scale/Time\n  useUTC: false\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 952:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(860);\n\nvar getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);\nvar _default = {\n  getAreaStyle: function (excludes, includes) {\n    return getAreaStyle(this, excludes, includes);\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 953:\n/***/ (function(module, exports) {\n\nvar _default = {\n  getBoxLayoutParams: function () {\n    return {\n      left: this.get('left'),\n      top: this.get('top'),\n      right: this.get('right'),\n      bottom: this.get('bottom'),\n      width: this.get('width'),\n      height: this.get('height')\n    };\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 954:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(860);\n\nvar getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);\nvar _default = {\n  getItemStyle: function (excludes, includes) {\n    var style = getItemStyle(this, excludes, includes);\n    var lineDash = this.getBorderLineDash();\n    lineDash && (style.lineDash = lineDash);\n    return style;\n  },\n  getBorderLineDash: function () {\n    var lineType = this.get('borderType');\n    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 955:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(860);\n\nvar getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getLineStyle: function (excludes) {\n    var style = getLineStyle(this, excludes);\n    var lineDash = this.getLineDash(style.lineWidth);\n    lineDash && (style.lineDash = lineDash);\n    return style;\n  },\n  getLineDash: function (lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n\n    var lineType = this.get('type');\n    var dotSize = Math.max(lineWidth, 2);\n    var dashSize = lineWidth * 4;\n    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 956:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(844);\n\nvar graphicUtil = __webpack_require__(808);\n\nvar PATH_COLOR = ['textStyle', 'color'];\nvar _default = {\n  /**\n   * Get color property or get color from option.textStyle.color\n   * @param {boolean} [isEmphasis]\n   * @return {string}\n   */\n  getTextColor: function (isEmphasis) {\n    var ecModel = this.ecModel;\n    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);\n  },\n\n  /**\n   * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n   * @return {string}\n   */\n  getFont: function () {\n    return graphicUtil.getFont({\n      fontStyle: this.getShallow('fontStyle'),\n      fontWeight: this.getShallow('fontWeight'),\n      fontSize: this.getShallow('fontSize'),\n      fontFamily: this.getShallow('fontFamily')\n    }, this.ecModel);\n  },\n  getTextRect: function (text) {\n    return textContain.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 957:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(794);\n\nvar each = _util.each;\nvar isArray = _util.isArray;\nvar isObject = _util.isObject;\n\nvar compatStyle = __webpack_require__(958);\n\nvar _model = __webpack_require__(811);\n\nvar normalizeToArray = _model.normalizeToArray;\n\n// Compatitable with 2.0\nfunction get(opt, path) {\n  path = path.split(',');\n  var obj = opt;\n\n  for (var i = 0; i < path.length; i++) {\n    obj = obj && obj[path[i]];\n\n    if (obj == null) {\n      break;\n    }\n  }\n\n  return obj;\n}\n\nfunction set(opt, path, val, overwrite) {\n  path = path.split(',');\n  var obj = opt;\n  var key;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    key = path[i];\n\n    if (obj[key] == null) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  if (overwrite || obj[path[i]] == null) {\n    obj[path[i]] = val;\n  }\n}\n\nfunction compatLayoutProperties(option) {\n  each(LAYOUT_PROPERTIES, function (prop) {\n    if (prop[0] in option && !(prop[1] in option)) {\n      option[prop[1]] = option[prop[0]];\n    }\n  });\n}\n\nvar LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];\nvar COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];\nvar COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];\n\nfunction _default(option, isTheme) {\n  compatStyle(option, isTheme); // Make sure series array for model initialization.\n\n  option.series = normalizeToArray(option.series);\n  each(option.series, function (seriesOpt) {\n    if (!isObject(seriesOpt)) {\n      return;\n    }\n\n    var seriesType = seriesOpt.type;\n\n    if (seriesType === 'pie' || seriesType === 'gauge') {\n      if (seriesOpt.clockWise != null) {\n        seriesOpt.clockwise = seriesOpt.clockWise;\n      }\n    }\n\n    if (seriesType === 'gauge') {\n      var pointerColor = get(seriesOpt, 'pointer.color');\n      pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n    }\n\n    for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n      if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n        compatLayoutProperties(seriesOpt);\n        break;\n      }\n    }\n  }); // dataRange has changed to visualMap\n\n  if (option.dataRange) {\n    option.visualMap = option.dataRange;\n  }\n\n  each(COMPATITABLE_COMPONENTS, function (componentName) {\n    var options = option[componentName];\n\n    if (options) {\n      if (!isArray(options)) {\n        options = [options];\n      }\n\n      each(options, function (option) {\n        compatLayoutProperties(option);\n      });\n    }\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 958:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar modelUtil = __webpack_require__(811);\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];\n\nfunction compatItemStyle(opt) {\n  var itemStyleOpt = opt && opt.itemStyle;\n\n  if (!itemStyleOpt) {\n    return;\n  }\n\n  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n    var styleName = POSSIBLE_STYLES[i];\n    var normalItemStyleOpt = itemStyleOpt.normal;\n    var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\n    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n      opt[styleName] = opt[styleName] || {};\n\n      if (!opt[styleName].normal) {\n        opt[styleName].normal = normalItemStyleOpt[styleName];\n      } else {\n        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n      }\n\n      normalItemStyleOpt[styleName] = null;\n    }\n\n    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n      opt[styleName] = opt[styleName] || {};\n\n      if (!opt[styleName].emphasis) {\n        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n      } else {\n        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n      }\n\n      emphasisItemStyleOpt[styleName] = null;\n    }\n  }\n}\n\nfunction compatTextStyle(opt, propName) {\n  var labelOptSingle = isObject(opt) && opt[propName];\n  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;\n\n  if (textStyle) {\n    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {\n      var propName = modelUtil.TEXT_STYLE_OPTIONS[i];\n\n      if (textStyle.hasOwnProperty(propName)) {\n        labelOptSingle[propName] = textStyle[propName];\n      }\n    }\n  }\n}\n\nfunction compatLabelTextStyle(labelOpt) {\n  if (isObject(labelOpt)) {\n    compatTextStyle(labelOpt, 'normal');\n    compatTextStyle(labelOpt, 'emphasis');\n  }\n}\n\nfunction processSeries(seriesOpt) {\n  if (!isObject(seriesOpt)) {\n    return;\n  }\n\n  compatItemStyle(seriesOpt);\n  compatLabelTextStyle(seriesOpt.label); // treemap\n\n  compatLabelTextStyle(seriesOpt.upperLabel); // graph\n\n  compatLabelTextStyle(seriesOpt.edgeLabel);\n  var markPoint = seriesOpt.markPoint;\n  compatItemStyle(markPoint);\n  compatLabelTextStyle(markPoint && markPoint.label);\n  var markLine = seriesOpt.markLine;\n  compatItemStyle(seriesOpt.markLine);\n  compatLabelTextStyle(markLine && markLine.label);\n  var markArea = seriesOpt.markArea;\n  compatLabelTextStyle(markArea && markArea.label); // For gauge\n\n  compatTextStyle(seriesOpt, 'axisLabel');\n  compatTextStyle(seriesOpt, 'title');\n  compatTextStyle(seriesOpt, 'detail');\n  var data = seriesOpt.data;\n\n  if (data) {\n    for (var i = 0; i < data.length; i++) {\n      compatItemStyle(data[i]);\n      compatLabelTextStyle(data[i] && data[i].label);\n    }\n  } // mark point data\n\n\n  var markPoint = seriesOpt.markPoint;\n\n  if (markPoint && markPoint.data) {\n    var mpData = markPoint.data;\n\n    for (var i = 0; i < mpData.length; i++) {\n      compatItemStyle(mpData[i]);\n      compatLabelTextStyle(mpData[i] && mpData[i].label);\n    }\n  } // mark line data\n\n\n  var markLine = seriesOpt.markLine;\n\n  if (markLine && markLine.data) {\n    var mlData = markLine.data;\n\n    for (var i = 0; i < mlData.length; i++) {\n      if (zrUtil.isArray(mlData[i])) {\n        compatItemStyle(mlData[i][0]);\n        compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);\n        compatItemStyle(mlData[i][1]);\n        compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);\n      } else {\n        compatItemStyle(mlData[i]);\n        compatLabelTextStyle(mlData[i] && mlData[i].label);\n      }\n    }\n  }\n}\n\nfunction toArr(o) {\n  return zrUtil.isArray(o) ? o : o ? [o] : [];\n}\n\nfunction toObj(o) {\n  return (zrUtil.isArray(o) ? o[0] : o) || {};\n}\n\nfunction _default(option, isTheme) {\n  each(toArr(option.series), function (seriesOpt) {\n    isObject(seriesOpt) && processSeries(seriesOpt);\n  });\n  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n  each(axes, function (axisName) {\n    each(toArr(option[axisName]), function (axisOpt) {\n      if (axisOpt) {\n        compatTextStyle(axisOpt, 'axisLabel');\n        compatTextStyle(axisOpt.axisPointer, 'label');\n      }\n    });\n  });\n  each(toArr(option.parallel), function (parallelOpt) {\n    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n    compatTextStyle(parallelAxisDefault, 'axisLabel');\n    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n  });\n  each(toArr(option.calendar), function (calendarOpt) {\n    compatTextStyle(calendarOpt, 'dayLabel');\n    compatTextStyle(calendarOpt, 'monthLabel');\n    compatTextStyle(calendarOpt, 'yearLabel');\n  }); // radar.name.textStyle\n\n  each(toArr(option.radar), function (radarOpt) {\n    compatTextStyle(radarOpt, 'name');\n  });\n  each(toArr(option.geo), function (geoOpt) {\n    if (isObject(geoOpt)) {\n      compatLabelTextStyle(geoOpt.label);\n      each(toArr(geoOpt.regions), function (regionObj) {\n        compatLabelTextStyle(regionObj.label);\n      });\n    }\n  });\n  compatLabelTextStyle(toObj(option.timeline).label);\n  compatTextStyle(toObj(option.axisPointer), 'label');\n  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 959:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Scale = __webpack_require__(856);\n\nvar numberUtil = __webpack_require__(810);\n\nvar IntervalScale = __webpack_require__(873);\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, true, function (val) {\n      return val > 0;\n    }));\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\n\nLogScale.create = function () {\n  return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\n\nvar _default = LogScale;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 960:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Scale = __webpack_require__(856);\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n  init: function (data, extent) {\n    this._data = data;\n    this._extent = extent || [0, data.length - 1];\n  },\n  parse: function (val) {\n    return typeof val === 'string' ? zrUtil.indexOf(this._data, val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function (rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n  },\n\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function (val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function (val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n\n  /**\n   * @return {Array}\n   */\n  getTicks: function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n\n    return ticks;\n  },\n\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function (n) {\n    return this._data[n];\n  },\n\n  /**\n   * @return {number}\n   */\n  count: function () {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, false));\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\n\nvar _default = OrdinalScale;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 961:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar numberUtil = __webpack_require__(810);\n\nvar formatUtil = __webpack_require__(822);\n\nvar scaleHelper = __webpack_require__(895);\n\nvar IntervalScale = __webpack_require__(873);\n\n// [About UTC and local time zone]:\n// In most cases, `number.parseDate` will treat input data string as local time\n// (except time zone is specified in time string). And `format.formateTime` returns\n// local time by default. option.useUTC is false by default. This design have\n// concidered these common case:\n// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n// in local time by default.\n// (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n// as its original time, without any time difference.\nvar intervalScaleProto = IntervalScale.prototype;\nvar mathCeil = Math.ceil;\nvar mathFloor = Math.floor;\nvar ONE_SECOND = 1000;\nvar ONE_MINUTE = ONE_SECOND * 60;\nvar ONE_HOUR = ONE_MINUTE * 60;\nvar ONE_DAY = ONE_HOUR * 24; // FIXME \n\nvar bisect = function (a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (a[mid][1] < x) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return lo;\n};\n/**\n * @alias module:echarts/coord/scale/Time\n * @constructor\n */\n\n\nvar TimeScale = IntervalScale.extend({\n  type: 'time',\n\n  /**\n   * @override\n   */\n  getLabel: function (val) {\n    var stepLvl = this._stepLvl;\n    var date = new Date(val);\n    return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n  },\n\n  /**\n   * @override\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      // Expand extent\n      extent[0] -= ONE_DAY;\n      extent[1] += ONE_DAY;\n    } // If there are no data and extent are [Infinity, -Infinity]\n\n\n    if (extent[1] === -Infinity && extent[0] === Infinity) {\n      var d = new Date();\n      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      extent[0] = extent[1] - ONE_DAY;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n    }\n  },\n\n  /**\n   * @override\n   */\n  niceTicks: function (approxTickNum, minInterval, maxInterval) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    var approxInterval = span / approxTickNum;\n\n    if (minInterval != null && approxInterval < minInterval) {\n      approxInterval = minInterval;\n    }\n\n    if (maxInterval != null && approxInterval > maxInterval) {\n      approxInterval = maxInterval;\n    }\n\n    var scaleLevelsLen = scaleLevels.length;\n    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n    var interval = level[1]; // Same with interval scale if span is much larger than 1 year\n\n    if (level[0] === 'year') {\n      var yearSpan = span / interval; // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n      // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\n      var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n      interval *= yearStep;\n    }\n\n    var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;\n    var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];\n    scaleHelper.fixExtent(niceExtent, extent);\n    this._stepLvl = level; // Interval will be used in getTicks\n\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n  parse: function (val) {\n    // val might be float.\n    return +numberUtil.parseDate(val);\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  TimeScale.prototype[methodName] = function (val) {\n    return intervalScaleProto[methodName].call(this, this.parse(val));\n  };\n}); // Steps from d3\n\nvar scaleLevels = [// Format              interval\n['hh:mm:ss', ONE_SECOND], // 1s\n['hh:mm:ss', ONE_SECOND * 5], // 5s\n['hh:mm:ss', ONE_SECOND * 10], // 10s\n['hh:mm:ss', ONE_SECOND * 15], // 15s\n['hh:mm:ss', ONE_SECOND * 30], // 30s\n['hh:mm\\nMM-dd', ONE_MINUTE], // 1m\n['hh:mm\\nMM-dd', ONE_MINUTE * 5], // 5m\n['hh:mm\\nMM-dd', ONE_MINUTE * 10], // 10m\n['hh:mm\\nMM-dd', ONE_MINUTE * 15], // 15m\n['hh:mm\\nMM-dd', ONE_MINUTE * 30], // 30m\n['hh:mm\\nMM-dd', ONE_HOUR], // 1h\n['hh:mm\\nMM-dd', ONE_HOUR * 2], // 2h\n['hh:mm\\nMM-dd', ONE_HOUR * 6], // 6h\n['hh:mm\\nMM-dd', ONE_HOUR * 12], // 12h\n['MM-dd\\nyyyy', ONE_DAY], // 1d\n['MM-dd\\nyyyy', ONE_DAY * 2], // 2d\n['MM-dd\\nyyyy', ONE_DAY * 3], // 3d\n['MM-dd\\nyyyy', ONE_DAY * 4], // 4d\n['MM-dd\\nyyyy', ONE_DAY * 5], // 5d\n['MM-dd\\nyyyy', ONE_DAY * 6], // 6d\n['week', ONE_DAY * 7], // 7d\n['MM-dd\\nyyyy', ONE_DAY * 10], // 10d\n['week', ONE_DAY * 14], // 2w\n['week', ONE_DAY * 21], // 3w\n['month', ONE_DAY * 31], // 1M\n['week', ONE_DAY * 42], // 6w\n['month', ONE_DAY * 62], // 2M\n['week', ONE_DAY * 42], // 10w\n['quarter', ONE_DAY * 380 / 4], // 3M\n['month', ONE_DAY * 31 * 4], // 4M\n['month', ONE_DAY * 31 * 5], // 5M\n['half-year', ONE_DAY * 380 / 2], // 6M\n['month', ONE_DAY * 31 * 8], // 8M\n['month', ONE_DAY * 31 * 10], // 10M\n['year', ONE_DAY * 380] // 1Y\n];\n/**\n * @param {module:echarts/model/Model}\n * @return {module:echarts/scale/Time}\n */\n\nTimeScale.create = function (model) {\n  return new TimeScale({\n    useUTC: model.ecModel.get('useUTC')\n  });\n};\n\nvar _default = TimeScale;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 962:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Group = __webpack_require__(858);\n\nvar componentUtil = __webpack_require__(874);\n\nvar clazzUtil = __webpack_require__(824);\n\nvar Component = function () {\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n  this.group = new Group();\n  /**\n   * @type {string}\n   * @readOnly\n   */\n\n  this.uid = componentUtil.getUID('viewComponent');\n};\n\nComponent.prototype = {\n  constructor: Component,\n  init: function (ecModel, api) {},\n  render: function (componentModel, ecModel, api, payload) {},\n  dispose: function () {}\n};\nvar componentProto = Component.prototype;\n\ncomponentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;\n}; // Enable Component.extend.\n\n\nclazzUtil.enableClassExtend(Component); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(Component, {\n  registerWhenExtend: true\n});\nvar _default = Component;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 963:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Gradient = __webpack_require__(879);\n\nfunction _default(ecModel) {\n  function encodeColor(seriesModel) {\n    var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n    var data = seriesModel.getData();\n    var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n    || seriesModel.getColorFromPalette(seriesModel.get('name')); // Default color\n    // FIXME Set color function or use the platte color\n\n    data.setVisual('color', color); // Only visible series has each data be visual encoded\n\n    if (!ecModel.isSeriesFiltered(seriesModel)) {\n      if (typeof color === 'function' && !(color instanceof Gradient)) {\n        data.each(function (idx) {\n          data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n        });\n      } // itemStyle in each data item\n\n\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var color = itemModel.get(colorAccessPath, true);\n\n        if (color != null) {\n          data.setItemVisual(idx, 'color', color);\n        }\n      });\n    }\n  }\n\n  ecModel.eachRawSeries(encodeColor);\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 964:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(924);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(657)(\"7f807ae8\", content, true, {});\n\n/***/ }),\n\n/***/ 965:\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction injectStyle (ssrContext) {\n  __webpack_require__(964)\n}\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(922),\n  /* template */\n  __webpack_require__(967),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  \"data-v-39b0517a\",\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 966:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(1)(\n  /* script */\n  __webpack_require__(923),\n  /* template */\n  __webpack_require__(968),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 967:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"formHeight\"\n  }, [_c('el-card', {\n    staticClass: \"box-card__form console-width-12\"\n  }, [_c('el-form', {\n    staticClass: \"filterform cf\",\n    attrs: {\n      \"label-width\": _vm.conditionWdith\n    },\n    nativeOn: {\n      \"keyup\": function($event) {\n        if (!('button' in $event) && _vm._k($event.keyCode, \"enter\", 13, $event.key, \"Enter\")) { return null; }\n        return _vm.onSearchButtonClick($event)\n      }\n    }\n  }, [_vm._l((_vm.fieldValues), function(field, index) {\n    return _c('el-form-item', {\n      key: index,\n      attrs: {\n        \"label\": field.name\n      }\n    }, [(field.type === 'date') ? _c('el-date-picker', {\n      attrs: {\n        \"align\": \"right\",\n        \"type\": \"date\",\n        \"format\": \"yyyy-MM-dd\"\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'daterange') ? _c('el-date-picker', {\n      attrs: {\n        \"type\": \"daterange\",\n        \"align\": \"right\",\n        \"picker-options\": _vm.pickerOptions\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'datetimerange') ? _c('el-date-picker', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"type\": \"datetimerange\",\n        \"align\": \"right\",\n        \"format\": \"yyyy-MM-dd HH:mm\",\n        \"picker-options\": _vm.pickerOptionsI\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'forbidden_daterange') ? _c('el-date-picker', {\n      attrs: {\n        \"type\": \"forbidden_daterange\",\n        \"align\": \"right\",\n        \"readonly\": true,\n        \"picker-options\": _vm.pickerOptions\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'select') ? _c('el-select', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"clearable\": \"\"\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }, _vm._l((field.label), function(item) {\n      return _c('el-option', {\n        key: item.value,\n        attrs: {\n          \"label\": item.label,\n          \"value\": item.value\n        }\n      })\n    }), 1) : _vm._e(), _vm._v(\" \"), (field.type === 'select-many') ? _c('el-select', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"multiple\": \"\",\n        \"collapse-tags\": \"\",\n        \"placeholder\": \"\",\n        \"clearable\": \"\"\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }, _vm._l((field.label), function(item) {\n      return _c('el-option', {\n        key: item.value,\n        attrs: {\n          \"label\": item.label,\n          \"value\": item.value\n        }\n      })\n    }), 1) : _vm._e(), _vm._v(\" \"), (field.type === null || field.type === 'string') ? _c('el-input', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"placeholder\": field.name\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'checkbox') ? _c('el-checkbox', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"label\": field.label,\n        \"true-label\": 1\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e()], 1)\n  }), _vm._v(\" \"), (_vm.multi === 'A') ? _c('el-form-item', {\n    attrs: {\n      \"label\": \"\"\n    }\n  }, [(_vm.multi === 'A') ? _c('el-input', {\n    staticClass: \"inputwidth\",\n    model: {\n      value: (_vm.a_val),\n      callback: function($$v) {\n        _vm.a_val = $$v\n      },\n      expression: \"a_val\"\n    }\n  }, [_c('el-select', {\n    staticClass: \"selectwidth\",\n    attrs: {\n      \"slot\": \"prepend\"\n    },\n    slot: \"prepend\",\n    model: {\n      value: (_vm.a_type),\n      callback: function($$v) {\n        _vm.a_type = $$v\n      },\n      expression: \"a_type\"\n    }\n  }, [_c('el-option', {\n    attrs: {\n      \"label\": \"\",\n      \"value\": 1\n    }\n  }), _vm._v(\" \"), _c('el-option', {\n    attrs: {\n      \"label\": \"\",\n      \"value\": 2\n    }\n  })], 1)], 1) : _vm._e()], 1) : _vm._e(), _vm._v(\" \"), _c('el-form-item', [_c('el-button', {\n    staticClass: \"ui-color3\",\n    on: {\n      \"click\": _vm.onSearchButtonClick\n    }\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"ui-color2\",\n    on: {\n      \"click\": _vm.onRestButtonClick\n    }\n  }, [_vm._v(\"\")])], 1)], 2)], 1)], 1)\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 968:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"percent-table\"\n  }, [(_vm.$store.state.resolution === 'high') ? _c('el-table', {\n    directives: [{\n      name: \"loading\",\n      rawName: \"v-loading\",\n      value: (_vm.isLoading),\n      expression: \"isLoading\"\n    }],\n    staticClass: \"adjust-table ui-color4\",\n    attrs: {\n      \"border\": \"\",\n      \"highlight-current-row\": \"\",\n      \"data\": _vm.tableData,\n      \"height\": _vm.tabHeight\n    },\n    on: {\n      \"select\": _vm.ischeckbox,\n      \"select-all\": _vm.ischeckbox\n    }\n  }, [_vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'select') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"type\": \"selection\",\n        \"width\": \"35\",\n        \"align\": \"center\"\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'checkbox') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": \"55\",\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_c('el-checkbox', {\n            attrs: {\n              \"disabled\": scope.$index === 0 ? false : true\n            },\n            on: {\n              \"change\": function($event) {\n                _vm.checkChange(item.value)\n              }\n            },\n            model: {\n              value: (item.value),\n              callback: function($$v) {\n                _vm.$set(item, \"value\", $$v)\n              },\n              expression: \"item.value\"\n            }\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'normal') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"prop\": item.name,\n        \"label\": item.label,\n        \"formatter\": item.formatter ? _vm.format : null,\n        \"align\": \"center\",\n        \"sortable\": \"\",\n        \"filters\": item.tagFilter ? _vm.tagSearch : null,\n        \"filter-method\": item.tagFilter ? _vm.filterTag : null\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'hovernormal') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"prop\": item.name,\n        \"label\": item.label,\n        \"formatter\": item.formatter ? _vm.format : null,\n        \"align\": \"center\",\n        \"filters\": item.tagFilter ? _vm.tagSearch : null,\n        \"filter-method\": item.tagFilter ? _vm.filterTag : null\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_c('el-tooltip', {\n            attrs: {\n              \"trigger\": \"hover\",\n              \"placement\": \"top\",\n              \"effect\": \"dark\"\n            }\n          }, [_c('div', {\n            staticClass: \"name-wrapper\",\n            attrs: {\n              \"slot\": \"content\"\n            },\n            slot: \"content\"\n          }, [_vm._v(\"\\n                        \" + _vm._s(scope.row.item) + \"\\n                    \")]), _vm._v(\" \"), _c('el-tag', {\n            staticClass: \"custom-tag\"\n          }, [_vm._v(_vm._s(scope.row.item))])], 1)]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'button') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\"\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClick(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'isbutton') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\",\n                \"disabled\": _vm.isbutton\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClickI(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'choose') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._t(\"default\", [_c('el-checkbox-group', {\n            model: {\n              value: (scope.row.checkList),\n              callback: function($$v) {\n                _vm.$set(scope.row, \"checkList\", $$v)\n              },\n              expression: \"scope.row.checkList\"\n            }\n          }, _vm._l((item.chooses), function(c) {\n            return _c('el-checkbox', {\n              key: c.name,\n              attrs: {\n                \"label\": c.code\n              }\n            }, [_vm._v(_vm._s(c.label))])\n          }), 1)])]\n        }\n      }])\n    }) : _vm._e()\n  })], 2) : _c('el-table', {\n    directives: [{\n      name: \"loading\",\n      rawName: \"v-loading\",\n      value: (_vm.isLoading),\n      expression: \"isLoading\"\n    }],\n    staticClass: \"ui-color4 adjust-table\",\n    attrs: {\n      \"border\": \"\",\n      \"highlight-current-row\": \"\",\n      \"data\": _vm.tableData,\n      \"height\": _vm.tabHeight\n    },\n    on: {\n      \"select-all\": _vm.ischeckbox,\n      \"select\": _vm.ischeckbox\n    }\n  }, [_vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'select') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"type\": \"selection\",\n        \"width\": \"35\",\n        \"align\": \"center\"\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'checkbox') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": \"55\",\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_c('el-checkbox', {\n            attrs: {\n              \"disabled\": scope.$index === 0 ? false : true\n            },\n            on: {\n              \"change\": function($event) {\n                _vm.checkChange(item.value)\n              }\n            },\n            model: {\n              value: (item.value),\n              callback: function($$v) {\n                _vm.$set(item, \"value\", $$v)\n              },\n              expression: \"item.value\"\n            }\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'normal') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"prop\": item.name,\n        \"label\": item.label,\n        \"formatter\": item.formatter ? _vm.format : null,\n        \"align\": \"center\",\n        \"sortable\": \"\",\n        \"filters\": item.tagFilter ? _vm.tagSearch : null,\n        \"filter-method\": item.tagFilter ? _vm.filterTag : null\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'button') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\"\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClick(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'isbutton') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\"\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClick(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'choose') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.chooses), function(c) {\n            return _vm._t(\"default\", [_c('el-checkbox', [_vm._v(_vm._s(c.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  })], 2)], 1)\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 969:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(794);\n\nvar vec2 = __webpack_require__(812);\n\nvar Draggable = __webpack_require__(1001);\n\nvar Eventful = __webpack_require__(852);\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * cursor style\n   * @param {string} [cursorStyle='default']  crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * \n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} \n   * @param {string} eventName \n   * @param {Object} event \n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      //  zrender \n      this.trigger(eventName, eventPacket); // \n      //  click  dispose painter \n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 970:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(794);\n\nvar _config = __webpack_require__(857);\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = __webpack_require__(907);\n\nvar Pattern = __webpack_require__(906);\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * dom\n *\n * @inner\n * @param {string} id dom id \n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // append~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // \n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * \n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * \n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * alpha\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 971:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(857);\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = __webpack_require__(794);\n\nvar log = __webpack_require__(904);\n\nvar BoundingRect = __webpack_require__(821);\n\nvar timsort = __webpack_require__(877);\n\nvar Layer = __webpack_require__(970);\n\nvar requestAnimationFrame = __webpack_require__(898);\n\nvar Image = __webpack_require__(905);\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // \n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root \n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * \n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} [paintAll=false] displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   *  zlevel \n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // \n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * hover\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * zlevel\n   *\n   * @param {string} zlevel\n   * @param {Object} config \n   * @param {string} [config.clearColor=0] \n   * @param {string} [config.motionBlur=false] \n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 alpha\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {number} zlevel zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * \n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * \n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * \n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * \n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * \n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 972:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(794);\n\nvar env = __webpack_require__(819);\n\nvar Group = __webpack_require__(858);\n\nvar timsort = __webpack_require__(877);\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n *  (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} [update=false] \n   * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n   *\n   * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * \n   * GroupShapeShape\n   * zlevel > z > \n   * @param {boolean} [includeIgnore=false]  ignore \n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME \n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath  clipPath \n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * (Shape)(Group)\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * (Shape)(Group)\n   * @param {string|Array.<string>} [el] Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // el\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 973:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(794);\n\nvar _event = __webpack_require__(851);\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = __webpack_require__(898);\n\nvar Animator = __webpack_require__(897);\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   *  clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   *  animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * \n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * \n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * \n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * \n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * \n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * animator\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] \n   * @param  {Function} [options.getter=null]\n   *         gettergetter\n   * @param  {Function} [options.setter=null]\n   *         settersetter\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 974:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar easingFuncs = __webpack_require__(975);\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // \n\n  this._life = options.life || 1000; // \n\n  this._delay = options.delay || 0; // \n  // this._startTime = new Date().getTime() + this._delay;// \n\n  this._initialized = false; // \n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // \n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // \n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // \n        //  stage.update \n\n        return 'restart';\n      } // \n      // Animation.update\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 975:\n/***/ (function(module, exports) {\n\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // t^3\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // t^4\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // t^5\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // sin(t)\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 2^t\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // sqrt(1-t^2)\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 976:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(899);\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * \n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n\n/***/ }),\n\n/***/ 977:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar curve = __webpack_require__(847);\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n/***/ }),\n\n/***/ 978:\n/***/ (function(module, exports) {\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n/***/ }),\n\n/***/ 979:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar PathProxy = __webpack_require__(859);\n\nvar line = __webpack_require__(978);\n\nvar cubic = __webpack_require__(977);\n\nvar quadratic = __webpack_require__(981);\n\nvar arc = __webpack_require__(976);\n\nvar _util = __webpack_require__(899);\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = __webpack_require__(847);\n\nvar windingLine = __webpack_require__(900);\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // \n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // \n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // \n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc \n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } //  subpath \n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      //  L, C, Q\n      //  previous point  point\n      //\n      //  Arc \n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo  subpath, \n        //  closePath \n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE  L, C, Q  NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc \n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc \n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; //  arc \n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // \n          x0 = x1;\n          y0 = y1;\n        } // zr scale, x\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); //  subpath \n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n\n/***/ }),\n\n/***/ 980:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar windingLine = __webpack_require__(900);\n\nvar EPSILON = 1e-8;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n}\n\nfunction contain(points, x, y) {\n  var w = 0;\n  var p = points[0];\n\n  if (!p) {\n    return false;\n  }\n\n  for (var i = 1; i < points.length; i++) {\n    var p2 = points[i];\n    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\n    p = p2;\n  } // Close polygon\n\n\n  var p0 = points[0];\n\n  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {\n    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\n  }\n\n  return w !== 0;\n}\n\nexports.contain = contain;\n\n/***/ }),\n\n/***/ 981:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _curve = __webpack_require__(847);\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n/***/ }),\n\n/***/ 982:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eventUtil = __webpack_require__(851);\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 983:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _event = __webpack_require__(851);\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = __webpack_require__(794);\n\nvar Eventful = __webpack_require__(852);\n\nvar env = __webpack_require__(819);\n\nvar GestureMgr = __webpack_require__(982);\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // rootdommouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * dom \n *\n * @inner\n * @param {module:zrender/Handler} instance \n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 984:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\n// CompoundPath to improve performance\nvar _default = Path.extend({\n  type: 'compound',\n  shape: {\n    paths: null\n  },\n  _updatePathDirty: function () {\n    var dirtyPath = this.__dirtyPath;\n    var paths = this.shape.paths;\n\n    for (var i = 0; i < paths.length; i++) {\n      // Mark as dirty if any subpath is dirty\n      dirtyPath = dirtyPath || paths[i].__dirtyPath;\n    }\n\n    this.__dirtyPath = dirtyPath;\n    this.__dirty = this.__dirty || dirtyPath;\n  },\n  beforeBrush: function () {\n    this._updatePathDirty();\n\n    var paths = this.shape.paths || [];\n    var scale = this.getGlobalScale(); // Update path scale\n\n    for (var i = 0; i < paths.length; i++) {\n      if (!paths[i].path) {\n        paths[i].createPathProxy();\n      }\n\n      paths[i].path.setScale(scale[0], scale[1]);\n    }\n  },\n  buildPath: function (ctx, shape) {\n    var paths = shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].buildPath(ctx, paths[i].shape, true);\n    }\n  },\n  afterBrush: function () {\n    var paths = this.shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].__dirtyPath = false;\n    }\n  },\n  getBoundingRect: function () {\n    this._updatePathDirty();\n\n    return Path.prototype.getBoundingRect.call(this);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 985:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Gradient = __webpack_require__(879);\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 986:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(794);\n\nvar Gradient = __webpack_require__(879);\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 987:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Displayable = __webpack_require__(878);\n\nvar zrUtil = __webpack_require__(794);\n\nvar textContain = __webpack_require__(844);\n\nvar textHelper = __webpack_require__(910);\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 988:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _vector = __webpack_require__(812);\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * \n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points \n * @param {number} smooth , 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint \n *                            [[0, 0], [100, 100]], \n *                           \n * @param {Array} \n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // \n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 989:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _vector = __webpack_require__(812);\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points \n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 990:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textHelper = __webpack_require__(910);\n\nvar BoundingRect = __webpack_require__(821);\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 991:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 992:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\nvar vec2 = __webpack_require__(812);\n\nvar _curve = __webpack_require__(847);\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\n/**\n * \n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 994:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 995:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\nvar polyHelper = __webpack_require__(908);\n\n/**\n * \n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 996:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\nvar polyHelper = __webpack_require__(908);\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 997:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\nvar roundRectHelper = __webpack_require__(909);\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // r1r2r3r4\n    // r1          [1, 1, 1, 1]\n    // r[1]        [1, 1, 1, 1]\n    // r[1, 2]     [1, 2, 1, 2]\n    // r[1, 2, 3]  [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 998:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 999:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(813);\n\nvar fixClipWithShadow = __webpack_require__(916);\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/2.9a5b3ca9fb1e9a0cb4a8.js","var Animator = require(\"../animation/Animator\");\n\nvar log = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * \n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      log('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * \n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    // animateTo(target, time, easing, callback);\n    if (isString(delay)) {\n      callback = easing;\n      easing = delay;\n      delay = 0;\n    } // animateTo(target, time, delay, callback);\n    else if (isFunction(easing)) {\n        callback = easing;\n        easing = 'linear';\n        delay = 0;\n      } // animateTo(target, time, callback);\n      else if (isFunction(delay)) {\n          callback = delay;\n          delay = 0;\n        } // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n          } // animateTo(target)\n          else if (!time) {\n              time = 500;\n            } // Stop all previous animations\n\n\n    this.stopAnimation();\n\n    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start\n    // if there is nothing to animate\n\n\n    var animators = this.animators.slice();\n    var count = animators.length;\n\n    function done() {\n      count--;\n\n      if (!count) {\n        callback && callback();\n      }\n    } // No animators. This should be checked before animators[i].start(),\n    // because 'done' may be executed immediately if no need to animate.\n\n\n    if (!count) {\n      callback && callback();\n    } // Start after all animators created\n    // Incase any animator is done immediately when all animation properties are not changed\n\n\n    for (var i = 0; i < animators.length; i++) {\n      animators[i].done(done).start(easing, forceAnimate);\n    }\n  },\n\n  /**\n   * @private\n   * @param {string} path=''\n   * @param {Object} source=this\n   * @param {Object} target\n   * @param {number} [time=500]\n   * @param {number} [delay=0]\n   *\n   * @example\n   *  // Animate position\n   *  el._animateToShallow({\n   *      position: [10, 10]\n   *  })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms\n   *  el._animateToShallow({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100)\n   */\n  _animateToShallow: function (path, source, target, time, delay) {\n    var objShallow = {};\n    var propertyCount = 0;\n\n    for (var name in target) {\n      if (!target.hasOwnProperty(name)) {\n        continue;\n      }\n\n      if (source[name] != null) {\n        if (isObject(target[name]) && !isArrayLike(target[name])) {\n          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);\n        } else {\n          objShallow[name] = target[name];\n          propertyCount++;\n        }\n      } else if (target[name] != null) {\n        // Attr directly if not has property\n        // FIXME, if some property not needed for element ?\n        if (!path) {\n          this.attr(name, target[name]);\n        } else {\n          // Shape or style\n          var props = {};\n          props[path] = {};\n          props[path][name] = target[name];\n          this.attr(props);\n        }\n      }\n    }\n\n    if (propertyCount > 0) {\n      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n    }\n\n    return this;\n  }\n};\nvar _default = Animatable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 1000\n// module chunks = 1 2 3 141 142 143 144 145","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this);\n  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target;\n\n    if (draggingTarget && draggingTarget.draggable) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 1001\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar transformPath = require(\"./transformPath\");\n\n// command chars\nvar cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return [];\n  } // command string\n\n\n  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');\n  var n; // create pipes so that we can split the data\n\n  for (n = 0; n < cc.length; n++) {\n    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  } // create array\n\n\n  var arr = cs.split('|'); // init context point\n\n  var cpx = 0;\n  var cpy = 0;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD;\n  var prevCmd;\n\n  for (n = 1; n < arr.length; n++) {\n    var str = arr[n];\n    var c = str.charAt(0);\n    var off = 0;\n    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n    var cmd;\n\n    if (p.length > 0 && p[0] === '') {\n      p.shift();\n    }\n\n    for (var i = 0; i < p.length; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    while (off < p.length && !isNaN(p[off])) {\n      if (isNaN(p[0])) {\n        break;\n      }\n\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (c) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          c = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (c === 'z' || c === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd);\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 1002\n// module chunks = 1 2 3 141 142 143 144 145","var PathProxy = require(\"../core/PathProxy\");\n\nvar _vector = require(\"../core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 1003\n// module chunks = 1 2 3 141 142 143 144 145","var BaseBarSeries = require(\"./BaseBarSeries\");\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarSeries.js\n// module id = 1005\n// module chunks = 1 2 141 142 143 144 145","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _helper = require(\"./helper\");\n\nvar setLabel = _helper.setLabel;\n\nvar Model = require(\"../../model/Model\");\n\nvar barItemStyle = require(\"./barItemStyle\");\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarView.js\n// module id = 1006\n// module chunks = 1 2 141 142 143 144 145","var SeriesModel = require(\"../../model/Series\");\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 0\n    barMinHeight: 0,\n    // 0\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // \n    // barWidth: null,\n    // 30%\n    // barGap: '30%',\n    // 20%\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: ''\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 1007\n// module chunks = 1 2 141 142 143 144 145","var makeStyleMapper = require(\"../../model/mixin/makeStyleMapper\");\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/barItemStyle.js\n// module id = 1008\n// module chunks = 1 2 141 142 143 144 145","var graphic = require(\"../../util/graphic\");\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/helper.js\n// module id = 1009\n// module chunks = 1 2 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/barGrid.js\n// module id = 1016\n// module chunks = 1 2 141 142 143 144 145","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/listComponent.js\n// module id = 1041\n// module chunks = 1 2 3 141","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    this._data = legendData;\n    var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n      return series.name;\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        availableNames = availableNames.concat(data.mapArray(data.getName));\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendModel.js\n// module id = 1042\n// module chunks = 1 2 3 141","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _listComponent = require(\"../helper/listComponent\");\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendView.js\n// module id = 1043\n// module chunks = 1 2 3 141","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendAction.js\n// module id = 1044\n// module chunks = 1 2 3 141","function _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendFilter.js\n// module id = 1045\n// module chunks = 1 2 3 141","<template>\r\n    <div class=\"page-secondnav page-commonnav\" ref=\"pageHeight\">\r\n        <div class=\"f-content\">\r\n            <div class=\"console-pt4 console-pb4\" ref=\"btnHeight\">\r\n                <el-button type=\"text\">&nbsp;</el-button>\r\n                <div class=\"pull-right\">\r\n                    <el-button class=\"ui-color2 console-mr2\" @click=\"initials\" title=\"\"><i class=\"fa fa-refresh\"></i></el-button>\r\n                    <span class=\"color-1 margin-2 fm-query\" @click=\"toggleSearch\" v-if=\"arrowBot\"><i class=\"el-icon-arrow-down margin-2\"/></span>\r\n                    <span class=\"color-1 margin-2 fm-query\" @click=\"toggleSearch\" v-if=\"arrowTop\"><i class=\"el-icon-arrow-up margin-2\"/></span>\r\n                </div>\r\n            </div>\r\n\r\n            <div v-show=\"searchVisible\" class=\"console-pb4\" ref=\"formHeight\">\r\n                <ZLCommonSearch :fields=\"searchFields\" @searchII=\"search\" ref=\"ZLCommonSearch\"></ZLCommonSearch>\r\n            </div>\r\n            <!---->\r\n            <ZLCommonTable :tableData=\"deliveryData\" @detail=\"showDetail\" :tabHeight=\"tabHeight\" :itemValues=\"itemValues\" :isLoading =\"isLoading\"></ZLCommonTable>\r\n            <el-pagination\r\n                    class=\"console-mt5\"\r\n                    @size-change=\"handleSizeChange\"\r\n                    @current-change=\"handleCurrentChange\"\r\n                    :current-page=\"cPage\"\r\n                    :page-sizes=\"cpageSizes\"\r\n                    :page-size=\"cSize\"\r\n                    layout=\"total, sizes, prev, pager, next\"\r\n                    :total=\"cTotal\">\r\n            </el-pagination>\r\n            <!---->\r\n            <el-dialog\r\n                    class=\"dialogDiv dialogDivII\"\r\n                    :show-close=\"false\"\r\n                    size=\"tiny\"\r\n                    :top=\"dialog_top\"\r\n                    :visible.sync=\"detailVisible\"\r\n                    :width='dialogW'\r\n                    :modal=\"true\">\r\n                <div class=\"slideContent leftOffsetIII\" :style='{width:dialogW}'>\r\n                    <div class=\"slideTop\" v-drag1></div>\r\n                    <div class=\"slideMid\">\r\n                        <sequence_chart ref=\"sequence\" :detailVisible=\"detailVisible\"></sequence_chart>\r\n                    </div>\r\n                </div>\r\n            </el-dialog>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    import ZLCommonSearch from '../../../components/ZLCommonSearch'\r\n    import ZLCommonTable from '../../../components/ZLCommonTable'\r\n    import sequence_chart from './report_block/sequence_chart'\r\n    export default {\r\n        data() {\r\n            const _this = this;\r\n            return {\r\n                tabHeight: null,\r\n                isLoading: false,\r\n                deliveryData:[],\r\n                searchFields:[\r\n                    {\r\n                        name: '',\r\n                        type: 'daterange',\r\n                        fieldName: 'datehandle',\r\n                        label:'senddate',\r\n                        value: [_this.recentDate(1), _this.recentDate(1)]\r\n                    },{\r\n                        name: '',\r\n                        type: 'select',\r\n                        fieldName: 'contracttype',\r\n                        label: [{label:'',value:'0'},{label:'',value:'1'},{label:'',value:'2'}]\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'ordernum_like'\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'clientname_like'\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'buildsite_like'\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'goodsname_like'\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'buildpartname_like'\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'empname_like'\r\n                    },\r\n//                    {\r\n//                        name: '',//todo\r\n//                        type: 'select',\r\n//                        fieldName: 'clientcode_like'\r\n//                    },\r\n//                    {\r\n//                        name: '',//todo\r\n//                        type: 'string',\r\n//                        fieldName: 'clientcode_like'\r\n//                    },\r\n                    {\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'senddriver_like'\r\n                    },{\r\n                        name: '',\r\n                        type: 'string',\r\n                        fieldName: 'senddrivername_like'\r\n                    },\r\n//                    {\r\n//                        name: '',//todo\r\n//                        type: 'string',\r\n//                        fieldName: 'clientcode_like'\r\n//                    },\r\n//                    {\r\n//                        name: '',//todo\r\n//                        type: 'string',\r\n//                        fieldName: 'clientcode_like'\r\n//                    }\r\n                ],\r\n                itemValues: [\r\n                    {\r\n                        name:'contracttypename',\r\n                        label:'',\r\n                        width:80,\r\n                        widthI:70,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'sendnum',\r\n                        label:'',\r\n                        width:90,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'senddate',\r\n                        label:'',\r\n                        width:80,\r\n                        widthI:70,\r\n                        type:'normal',\r\n                        formatter:true\r\n                    },{\r\n                        name:'empname',\r\n                        label:'',\r\n                        width:60,\r\n                        widthI:45,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'clientname',\r\n                        label:'',\r\n                        width:'',\r\n                        type: 'normal'\r\n                    },{\r\n                        name:'buildsite',\r\n                        label:'',\r\n                        width:'',\r\n                        type:'normal'\r\n                    },{\r\n                        name:'goodsname',\r\n                        label:'',\r\n                        width:100,\r\n                        widthI:90,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'buildpartname',\r\n                        label:'',\r\n                        width:100,\r\n                        widthI:90,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'buildwayname',\r\n                        label:'',\r\n                        width:65,\r\n                        widthI:40,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'buildslumpname',\r\n                        label:'',\r\n                        width:60,\r\n                        widthI:45,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'sendqty',\r\n                        label:'',\r\n                        width:65,\r\n                        widthI:40,\r\n                        type:'normal'\r\n                    },{\r\n                        name:'senddriver',\r\n                        label:'',\r\n                        width:'',\r\n                        type:'normal'\r\n                    },{\r\n                        name:'senddrivername',\r\n                        label:'',\r\n                        width:65,\r\n                        widthI:45,\r\n                        type:'normal'\r\n                    },\r\n//                    {\r\n//                        name:'remark',//todo\r\n//                        label:'',\r\n//                        width:60,\r\n//                        widthI:45,\r\n//                        type:'normal'\r\n//                    },\r\n//                    {\r\n//                        name:'remark',//todo\r\n//                        label:'',\r\n//                        width:65,\r\n//                        widthI:45,\r\n//                        type:'normal'\r\n//                    },\r\n//                    {\r\n//                        name:'remark',//todo\r\n//                        label:'',\r\n//                        width:60,\r\n//                        widthI:50,\r\n//                        type:'normal'\r\n//                    },\r\n//                    {\r\n//                        name:'remark',//todo\r\n//                        label:'',\r\n//                        width:'',\r\n//                        type:'normal'\r\n//                    },\r\n                    {\r\n                        name:'warnmark',\r\n                        label:'',\r\n                        width:'',\r\n                        type:'normal'\r\n                    }, {\r\n                        type:'button',\r\n                        label:'',\r\n                        width: 120,\r\n                        buttons: [\r\n                            {name:'detail',label:''}\r\n                        ]\r\n                    }\r\n                ],\r\n                content:'senddate_ge_date='+_this.recentDate(1)+'&senddate_le_date='+_this.recentDate(1)+'&sendstatus_gt=-1',\r\n                arrowBot: true,\r\n                arrowTop: false,\r\n                searchVisible: true,\r\n                height: null,\r\n                formHeight: null,\r\n                detailVisible: false,\r\n                dialogW: \"850px\",\r\n                dialog_top: \"100px\"\r\n            }\r\n        },\r\n        components:{\r\n            ZLCommonSearch,ZLCommonTable,sequence_chart\r\n        },\r\n        mounted() {\r\n            this.init();\r\n            setTimeout(()=>{\r\n                this.getDivHeight();\r\n            },20)\r\n        },\r\n        methods: {\r\n            init(){\r\n                this.getlist();\r\n            },\r\n            getDivHeight(){\r\n                const pageHeight = this.$refs.pageHeight.offsetHeight;\r\n                const btnHeight = this.$refs.btnHeight.offsetHeight;\r\n                this.formHeight = this.$refs.formHeight.offsetHeight;\r\n                this.height = pageHeight-btnHeight-this.$store.state.pageHeight;\r\n                this.tabHeight = this.height-this.formHeight;\r\n            },\r\n\r\n            //\r\n            toggleSearch(){\r\n                this.arrowBot = !this.arrowBot;\r\n                this.arrowTop = !this.arrowTop;\r\n                this.searchVisible = !this.searchVisible;\r\n                if (this.searchVisible) {\r\n                    setTimeout(() => {\r\n                        this.tabHeight = this.height - this.formHeight;\r\n                    },20)\r\n                } else {\r\n                    this.tabHeight = this.height;\r\n                }\r\n            },\r\n\r\n            //\r\n            initials(){\r\n                this.$refs.ZLCommonSearch.init();\r\n            },\r\n\r\n            //\r\n            search(params){\r\n                this.content = params +'&sendstatus_gt=-1';\r\n                this.cPage=1;\r\n                this.getlist();\r\n            },\r\n\r\n            //\r\n            getlist() {\r\n                this.isLoading = true;\r\n                this.getAjax('/finance/erpMes/erp-prod-send?pageNo='+this.cPage+'&pageSize='+this.cSize+'&'+this.content)\r\n                    .then(result => {\r\n                        if(result.status === 200) {\r\n                            if(result.data.list[0] === null){\r\n                                this.deliveryData = [];\r\n                                this.isLoading = false;\r\n                            }else{\r\n                                result.data.list.forEach((item,index) => {\r\n                                    if(item.contracttype === 0) {\r\n                                        item.contracttypename = ''\r\n                                    }else if(item.contracttype === 1) {\r\n                                        item.contracttypename = ''\r\n                                    }else if(item.contracttype === 2) {\r\n                                        item.contracttypename = ''\r\n                                    }else {\r\n                                        item.contracttypename = null\r\n                                    }\r\n                                });\r\n                                this.deliveryData = result.data.list;\r\n                                this.cTotal = result.data.total;\r\n                                this.isLoading = false;\r\n                            }\r\n                        }else {\r\n                            this.$message({\r\n                                message:result.message||'',\r\n                                type:'error'\r\n                            });\r\n                            this.isLoading = false;\r\n                        }\r\n                    })\r\n            },\r\n\r\n            //\r\n            showDetail(index,rows) {\r\n                this.detailVisible = true;\r\n                this.$nextTick(() => {\r\n                    this.$refs.sequence.initEchart(rows[index].sendnum);\r\n                })\r\n            }\r\n        }\r\n    }\r\n</script>\n\n\n// WEBPACK FOOTER //\n// delivery_detail.vue?2c074442","<template>\r\n    <div class=\"chart-div\">\r\n        <!--<div class=\"myChart\" ref=\"myChart\"></div>-->\r\n        <div class=\"bot-arrow\"></div>\r\n        <div class=\"left-arrow\"></div>\r\n        <div class=\"y-text\">\r\n            <span></span>\r\n            <span></span>\r\n            <span></span>\r\n            <span></span>\r\n            <span></span>\r\n            <span></span>\r\n            <span></span>\r\n            <span></span>\r\n        </div>\r\n        <div class=\"time-wrap\">\r\n            <div class=\"item-div itemI\">\r\n                <div class=\"text\"></div>\r\n                <div class=\"time\">{{sendObj.producecommandtime}}</div>\r\n            </div>\r\n            <div class=\"item-div itemII\">\r\n                <div class=\"text\"></div>\r\n                <div class=\"time\">{{sendObj.makematerialtime}}</div>\r\n            </div>\r\n            <div class=\"item-div itemIII\">\r\n                <div class=\"text\"></div>\r\n                <div class=\"time\">{{sendObj.qualitychecktime}}</div>\r\n            </div>\r\n            <div class=\"item-div itemIV\">\r\n                <div class=\"text\"></div>\r\n                <div class=\"time\">{{sendObj.targetbuildsitetime}}</div>\r\n            </div>\r\n            <div class=\"item-div itemV\">\r\n                <div class=\"text\"></div>\r\n                <div class=\"time\">{{sendObj.buildsiteoffloadtime}}</div>\r\n            </div>\r\n            <div class=\"item-div itemVI\">\r\n                <div class=\"text\"></div>\r\n                <div class=\"time\">{{sendObj.targetstarttime}}</div>\r\n            </div>\r\n        </div>\r\n        <div class=\"xtext xtextI\">{{sendObj.producecommandtime}}</div>\r\n        <div class=\"xtext xtextII\">{{sendObj.producecommandtime+sendObj.makematerialtime}}</div>\r\n        <div class=\"xtext xtextIII\">{{sendObj.producecommandtime+sendObj.makematerialtime+sendObj.qualitychecktime}}</div>\r\n        <div class=\"xtext xtextIV\">{{sendObj.producecommandtime+sendObj.makematerialtime+sendObj.qualitychecktime+sendObj.targetbuildsitetime}}</div>\r\n        <div class=\"xtext xtextV\">{{sendObj.producecommandtime+sendObj.makematerialtime+sendObj.qualitychecktime+sendObj.targetbuildsitetime+sendObj.buildsiteoffloadtime}}</div>\r\n        <div class=\"xtext xtextVI\">{{sendObj.producecommandtime+sendObj.makematerialtime+sendObj.qualitychecktime+sendObj.targetbuildsitetime+sendObj.buildsiteoffloadtime+sendObj.targetstarttime}}</div>\r\n        <div class=\"x-text\">()</div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    const echarts = require('echarts/lib/echarts');\r\n    require('echarts/lib/chart/bar');\r\n    require('echarts/lib/component/tooltip');\r\n    require('echarts/lib/component/legend');\r\n    export default {\r\n        data() {\r\n            return {\r\n                sendObj: {\r\n                    producecommandtime: 0,\r\n                    makematerialtime: 0,\r\n                    qualitychecktime: 0,\r\n                    targetbuildsitetime: 0,\r\n                    buildsiteoffloadtime: 0,\r\n                    targetstarttime: 0\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            //echart\r\n            initEchart(sendnum) {\r\n                //this.myChart = echarts.init(this.$refs.myChart);\r\n                this.fetch('/location/prodsendmonitor/prodsendMonitorInfos',{sendnum:sendnum})\r\n                    .then(result => {\r\n                        if(result.status === 200) {\r\n                            this.sendObj = result.data;\r\n                            //this.setCustomChart(result.data);\r\n                        }else {\r\n\r\n                        }\r\n                    })\r\n            },\r\n\r\n            //echart\r\n            setCustomChart(obj) {\r\n                let lastII = 0, lastIII = 0, lastIV = 0, lastV = 0, lastVI;\r\n                lastII = obj.targetstarttime + obj.buildsiteoffloadtime;\r\n                lastIII = lastII + obj.targetbuildsitetime;\r\n                lastIV = lastIII + obj.qualitychecktime;\r\n                lastV = lastIV + obj.makematerialtime;\r\n                lastVI = lastV + obj.producecommandtime;\r\n                this.myChart.setOption({\r\n                    grid: {\r\n                        left: '15%',\r\n                        top: '10%'\r\n                    },\r\n                    xAxis: {\r\n                        name: '()',\r\n                        type : 'value',\r\n                        axisLine:{\r\n                            symbol: ['none', 'arrow']\r\n                        }\r\n                    },\r\n                    yAxis: {\r\n                        name: '',\r\n                        type : 'category',\r\n                        axisTick: false,\r\n                        splitLine: {show:false},\r\n                        data: ['','','','','',''],\r\n                        axisLine:{\r\n                            symbol: ['none', 'arrow']\r\n                        },\r\n                        nameLocation: 'middle',\r\n                        nameTextStyle: {\r\n                            fontWeight: 500,\r\n                            fontSize: 14\r\n                        },\r\n                        axisLabel: {\r\n                            show: false\r\n                        }\r\n                    },\r\n                    series: [\r\n                        {\r\n                            name: '',\r\n                            type: 'bar',\r\n                            stack:  '',\r\n                            itemStyle: {\r\n                                normal: {\r\n                                    barBorderColor: 'rgba(0,0,0,0)',\r\n                                    color: 'rgba(0,0,0,0)'\r\n                                },\r\n                                emphasis: {\r\n                                    barBorderColor: 'rgba(0,0,0,0)',\r\n                                    color: 'rgba(0,0,0,0)',\r\n                                }\r\n                            },\r\n                            data: [lastVI - obj.targetstarttime,lastVI - lastII,lastVI - lastIII,lastVI- lastIV,lastVI - lastV,0]\r\n                        },\r\n                        {\r\n                            name: '',\r\n                            type: 'bar',\r\n                            stack: '',\r\n                            barWidth: 15,\r\n                            label: {\r\n                                normal: {\r\n                                    show: true,\r\n                                    position: 'right',\r\n                                    formatter: '{b}\\n{c}'\r\n                                }\r\n                            },\r\n                            data:[\r\n                                {value:obj.targetstarttime, itemStyle:{normal:{color:\"#670b88\"}}},\r\n                                {value:obj.buildsiteoffloadtime, itemStyle:{normal:{color:\"#0300fa\"}}},\r\n                                {value:obj.targetbuildsitetime, itemStyle:{normal:{color:\"#00878c\"}}},\r\n                                {value:obj.qualitychecktime, itemStyle:{normal:{color:\"#857f00\"}}},\r\n                                {value:obj.makematerialtime, itemStyle:{normal:{color:\"#ff6500\"}}},\r\n                                {value:obj.producecommandtime, itemStyle:{normal:{color:\"#fc0000\"}}}\r\n                            ]\r\n                        }\r\n                    ]\r\n                });\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style lang=\"less\" scoped type=\"text/less\">\r\n    .chart-wrap {\r\n        width: 600px;\r\n        height: 720px;\r\n        @media screen and (max-width: 1500px) {\r\n            height: 550px;\r\n        }\r\n        @media screen and (min-width: 1200px) and (max-width: 1500px) {\r\n            height: 470px;\r\n        }\r\n    }\r\n    .myChart {\r\n        width: 800px;\r\n        height: 400px;\r\n    }\r\n    .chart-div {\r\n        position: relative;\r\n    }\r\n    .x-text {\r\n        position: absolute;\r\n        right: 6%;\r\n        bottom: -5%;\r\n        color: #000;\r\n        font-weight: 600;\r\n    }\r\n    .y-text {\r\n        left: 5%;\r\n        top: 35%;\r\n        position: absolute;\r\n        color: #000;\r\n        font-weight: 600;\r\n        display: inline-flex;\r\n        flex-direction: column;\r\n    }\r\n    .left-arrow {\r\n        position: absolute;\r\n        left: 6%;\r\n        top: -5%;\r\n        width: 0;\r\n        height: 0;\r\n        border: 10px solid transparent;\r\n        border-bottom-color: #000;\r\n    }\r\n    .bot-arrow {\r\n        position: absolute;\r\n        right: 6%;\r\n        bottom: -2%;\r\n        width: 0;\r\n        height: 0;\r\n        border: 10px solid transparent;\r\n        border-left-color: #000;\r\n    }\r\n    .time-wrap {\r\n        width: 700px;\r\n        height: 400px;\r\n        border-left: 2px solid #000;\r\n        border-bottom: 2px solid #000;\r\n        margin: 20px 70px 20px auto;\r\n        position: relative;\r\n        .item-div {\r\n            position: absolute;\r\n            text-align: center;\r\n            border-right: 1px dashed #ccc;\r\n            height: 100%;\r\n        }\r\n        .text {\r\n            color: #ae1d3a;\r\n            line-height: 1.2;\r\n            font-weight: 600;\r\n        }\r\n        .time {\r\n            height: 20px;\r\n            color: white;\r\n            text-align: center;\r\n            border: 1px solid #000;\r\n        }\r\n        .itemI {\r\n            left: 0;\r\n            top: 10%;\r\n            width: 7%;\r\n            .time {\r\n                background: #fc0000;\r\n            }\r\n        }\r\n        .itemII {\r\n            left: 7%;\r\n            top: 25%;\r\n            width: 13%;\r\n            .time {\r\n                background: #ff6500;\r\n            }\r\n        }\r\n        .itemIII {\r\n            left: 20%;\r\n            top: 40%;\r\n            width: 9%;\r\n            .time {\r\n                background: #857f00;\r\n            }\r\n        }\r\n        .itemIV {\r\n            left: 29%;\r\n            top: 55%;\r\n            width: 22%;\r\n            .time {\r\n                background: #00878c;\r\n            }\r\n        }\r\n        .itemV {\r\n            left: 51%;\r\n            top: 70%;\r\n            width: 18%;\r\n            .time {\r\n                background: #0300fa;\r\n            }\r\n        }\r\n        .itemVI {\r\n            left: 69%;\r\n            top: 85%;\r\n            width: 22%;\r\n            .time {\r\n                background: #670b88;\r\n            }\r\n        }\r\n    }\r\n    .xtext {\r\n        position: absolute;\r\n        bottom: -5%;\r\n        font-weight: 600;\r\n        color: #000;\r\n    }\r\n    .xtextI {\r\n        left: 12%;\r\n    }\r\n    .xtextII {\r\n        left: 23%;\r\n    }\r\n    .xtextIII {\r\n        left: 30%;\r\n    }\r\n    .xtextIV {\r\n        left: 49%;\r\n    }\r\n    .xtextV {\r\n        left: 64%;\r\n    }\r\n    .xtextVI {\r\n        left: 82%;\r\n    }\r\n</style>\n\n\n// WEBPACK FOOTER //\n// sequence_chart.vue?5942397a","exports = module.exports = require(\"../../../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".chart-wrap[data-v-9eaf5f0e]{width:600px;height:720px}@media screen and (max-width:1500px){.chart-wrap[data-v-9eaf5f0e]{height:550px}}@media screen and (min-width:1200px) and (max-width:1500px){.chart-wrap[data-v-9eaf5f0e]{height:470px}}.myChart[data-v-9eaf5f0e]{width:800px;height:400px}.chart-div[data-v-9eaf5f0e]{position:relative}.x-text[data-v-9eaf5f0e]{position:absolute;right:6%;bottom:-5%;color:#000;font-weight:600}.y-text[data-v-9eaf5f0e]{left:5%;top:35%;position:absolute;color:#000;font-weight:600;display:inline-flex;flex-direction:column}.left-arrow[data-v-9eaf5f0e]{position:absolute;left:6%;top:-5%;width:0;height:0;border:10px solid transparent;border-bottom-color:#000}.bot-arrow[data-v-9eaf5f0e]{position:absolute;right:6%;bottom:-2%;width:0;height:0;border:10px solid transparent;border-left-color:#000}.time-wrap[data-v-9eaf5f0e]{width:700px;height:400px;border-left:2px solid #000;border-bottom:2px solid #000;margin:20px 70px 20px auto;position:relative}.time-wrap .item-div[data-v-9eaf5f0e]{position:absolute;text-align:center;border-right:1px dashed #ccc;height:100%}.time-wrap .text[data-v-9eaf5f0e]{color:#ae1d3a;line-height:1.2;font-weight:600}.time-wrap .time[data-v-9eaf5f0e]{height:20px;color:#fff;text-align:center;border:1px solid #000}.time-wrap .itemI[data-v-9eaf5f0e]{left:0;top:10%;width:7%}.time-wrap .itemI .time[data-v-9eaf5f0e]{background:#fc0000}.time-wrap .itemII[data-v-9eaf5f0e]{left:7%;top:25%;width:13%}.time-wrap .itemII .time[data-v-9eaf5f0e]{background:#ff6500}.time-wrap .itemIII[data-v-9eaf5f0e]{left:20%;top:40%;width:9%}.time-wrap .itemIII .time[data-v-9eaf5f0e]{background:#857f00}.time-wrap .itemIV[data-v-9eaf5f0e]{left:29%;top:55%;width:22%}.time-wrap .itemIV .time[data-v-9eaf5f0e]{background:#00878c}.time-wrap .itemV[data-v-9eaf5f0e]{left:51%;top:70%;width:18%}.time-wrap .itemV .time[data-v-9eaf5f0e]{background:#0300fa}.time-wrap .itemVI[data-v-9eaf5f0e]{left:69%;top:85%;width:22%}.time-wrap .itemVI .time[data-v-9eaf5f0e]{background:#670b88}.xtext[data-v-9eaf5f0e]{position:absolute;bottom:-5%;font-weight:600;color:#000}.xtextI[data-v-9eaf5f0e]{left:12%}.xtextII[data-v-9eaf5f0e]{left:23%}.xtextIII[data-v-9eaf5f0e]{left:30%}.xtextIV[data-v-9eaf5f0e]{left:49%}.xtextV[data-v-9eaf5f0e]{left:64%}.xtextVI[data-v-9eaf5f0e]{left:82%}\", \"\", {\"version\":3,\"sources\":[\"F:/pc_project/erp-aluminium/yunerp/src/page/erp_pc/erp_report/report_block/sequence_chart.vue\"],\"names\":[],\"mappings\":\"AACA,6BACE,YAAa,AACb,YAAc,CACf,AACD,qCACA,6BACI,YAAc,CACjB,CACA,AACD,4DACA,6BACI,YAAc,CACjB,CACA,AACD,0BACE,YAAa,AACb,YAAc,CACf,AACD,4BACE,iBAAmB,CACpB,AACD,yBACE,kBAAmB,AACnB,SAAU,AACV,WAAY,AACZ,WAAY,AACZ,eAAiB,CAClB,AACD,yBACE,QAAS,AACT,QAAS,AACT,kBAAmB,AACnB,WAAY,AACZ,gBAAiB,AACjB,oBAAqB,AACrB,qBAAuB,CACxB,AACD,6BACE,kBAAmB,AACnB,QAAS,AACT,QAAS,AACT,QAAS,AACT,SAAU,AACV,8BAA+B,AAC/B,wBAA0B,CAC3B,AACD,4BACE,kBAAmB,AACnB,SAAU,AACV,WAAY,AACZ,QAAS,AACT,SAAU,AACV,8BAA+B,AAC/B,sBAAwB,CACzB,AACD,4BACE,YAAa,AACb,aAAc,AACd,2BAA4B,AAC5B,6BAA8B,AAC9B,2BAA4B,AAC5B,iBAAmB,CACpB,AACD,sCACE,kBAAmB,AACnB,kBAAmB,AACnB,6BAA8B,AAC9B,WAAa,CACd,AACD,kCACE,cAAe,AACf,gBAAiB,AACjB,eAAiB,CAClB,AACD,kCACE,YAAa,AACb,WAAa,AACb,kBAAmB,AACnB,qBAAuB,CACxB,AACD,mCACE,OAAQ,AACR,QAAS,AACT,QAAU,CACX,AACD,yCACE,kBAAoB,CACrB,AACD,oCACE,QAAS,AACT,QAAS,AACT,SAAW,CACZ,AACD,0CACE,kBAAoB,CACrB,AACD,qCACE,SAAU,AACV,QAAS,AACT,QAAU,CACX,AACD,2CACE,kBAAoB,CACrB,AACD,oCACE,SAAU,AACV,QAAS,AACT,SAAW,CACZ,AACD,0CACE,kBAAoB,CACrB,AACD,mCACE,SAAU,AACV,QAAS,AACT,SAAW,CACZ,AACD,yCACE,kBAAoB,CACrB,AACD,oCACE,SAAU,AACV,QAAS,AACT,SAAW,CACZ,AACD,0CACE,kBAAoB,CACrB,AACD,wBACE,kBAAmB,AACnB,WAAY,AACZ,gBAAiB,AACjB,UAAY,CACb,AACD,yBACE,QAAU,CACX,AACD,0BACE,QAAU,CACX,AACD,2BACE,QAAU,CACX,AACD,0BACE,QAAU,CACX,AACD,yBACE,QAAU,CACX,AACD,0BACE,QAAU,CACX\",\"file\":\"sequence_chart.vue\",\"sourcesContent\":[\"\\n.chart-wrap[data-v-9eaf5f0e] {\\n  width: 600px;\\n  height: 720px;\\n}\\n@media screen and (max-width: 1500px) {\\n.chart-wrap[data-v-9eaf5f0e] {\\n    height: 550px;\\n}\\n}\\n@media screen and (min-width: 1200px) and (max-width: 1500px) {\\n.chart-wrap[data-v-9eaf5f0e] {\\n    height: 470px;\\n}\\n}\\n.myChart[data-v-9eaf5f0e] {\\n  width: 800px;\\n  height: 400px;\\n}\\n.chart-div[data-v-9eaf5f0e] {\\n  position: relative;\\n}\\n.x-text[data-v-9eaf5f0e] {\\n  position: absolute;\\n  right: 6%;\\n  bottom: -5%;\\n  color: #000;\\n  font-weight: 600;\\n}\\n.y-text[data-v-9eaf5f0e] {\\n  left: 5%;\\n  top: 35%;\\n  position: absolute;\\n  color: #000;\\n  font-weight: 600;\\n  display: inline-flex;\\n  flex-direction: column;\\n}\\n.left-arrow[data-v-9eaf5f0e] {\\n  position: absolute;\\n  left: 6%;\\n  top: -5%;\\n  width: 0;\\n  height: 0;\\n  border: 10px solid transparent;\\n  border-bottom-color: #000;\\n}\\n.bot-arrow[data-v-9eaf5f0e] {\\n  position: absolute;\\n  right: 6%;\\n  bottom: -2%;\\n  width: 0;\\n  height: 0;\\n  border: 10px solid transparent;\\n  border-left-color: #000;\\n}\\n.time-wrap[data-v-9eaf5f0e] {\\n  width: 700px;\\n  height: 400px;\\n  border-left: 2px solid #000;\\n  border-bottom: 2px solid #000;\\n  margin: 20px 70px 20px auto;\\n  position: relative;\\n}\\n.time-wrap .item-div[data-v-9eaf5f0e] {\\n  position: absolute;\\n  text-align: center;\\n  border-right: 1px dashed #ccc;\\n  height: 100%;\\n}\\n.time-wrap .text[data-v-9eaf5f0e] {\\n  color: #ae1d3a;\\n  line-height: 1.2;\\n  font-weight: 600;\\n}\\n.time-wrap .time[data-v-9eaf5f0e] {\\n  height: 20px;\\n  color: white;\\n  text-align: center;\\n  border: 1px solid #000;\\n}\\n.time-wrap .itemI[data-v-9eaf5f0e] {\\n  left: 0;\\n  top: 10%;\\n  width: 7%;\\n}\\n.time-wrap .itemI .time[data-v-9eaf5f0e] {\\n  background: #fc0000;\\n}\\n.time-wrap .itemII[data-v-9eaf5f0e] {\\n  left: 7%;\\n  top: 25%;\\n  width: 13%;\\n}\\n.time-wrap .itemII .time[data-v-9eaf5f0e] {\\n  background: #ff6500;\\n}\\n.time-wrap .itemIII[data-v-9eaf5f0e] {\\n  left: 20%;\\n  top: 40%;\\n  width: 9%;\\n}\\n.time-wrap .itemIII .time[data-v-9eaf5f0e] {\\n  background: #857f00;\\n}\\n.time-wrap .itemIV[data-v-9eaf5f0e] {\\n  left: 29%;\\n  top: 55%;\\n  width: 22%;\\n}\\n.time-wrap .itemIV .time[data-v-9eaf5f0e] {\\n  background: #00878c;\\n}\\n.time-wrap .itemV[data-v-9eaf5f0e] {\\n  left: 51%;\\n  top: 70%;\\n  width: 18%;\\n}\\n.time-wrap .itemV .time[data-v-9eaf5f0e] {\\n  background: #0300fa;\\n}\\n.time-wrap .itemVI[data-v-9eaf5f0e] {\\n  left: 69%;\\n  top: 85%;\\n  width: 22%;\\n}\\n.time-wrap .itemVI .time[data-v-9eaf5f0e] {\\n  background: #670b88;\\n}\\n.xtext[data-v-9eaf5f0e] {\\n  position: absolute;\\n  bottom: -5%;\\n  font-weight: 600;\\n  color: #000;\\n}\\n.xtextI[data-v-9eaf5f0e] {\\n  left: 12%;\\n}\\n.xtextII[data-v-9eaf5f0e] {\\n  left: 23%;\\n}\\n.xtextIII[data-v-9eaf5f0e] {\\n  left: 30%;\\n}\\n.xtextIV[data-v-9eaf5f0e] {\\n  left: 49%;\\n}\\n.xtextV[data-v-9eaf5f0e] {\\n  left: 64%;\\n}\\n.xtextVI[data-v-9eaf5f0e] {\\n  left: 82%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-9eaf5f0e\",\"scoped\":true,\"hasInlineConfig\":false}!./~/less-loader/dist/cjs.js?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/page/erp_pc/erp_report/report_block/sequence_chart.vue\n// module id = 1371\n// module chunks = 2","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-9eaf5f0e\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../../../node_modules/less-loader/dist/cjs.js?{\\\"sourceMap\\\":true}!../../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./sequence_chart.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"6903b422\", content, true, {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-9eaf5f0e\",\"scoped\":true,\"hasInlineConfig\":false}!./~/less-loader/dist/cjs.js?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/page/erp_pc/erp_report/report_block/sequence_chart.vue\n// module id = 1502\n// module chunks = 2","function injectStyle (ssrContext) {\n  require(\"!!../../../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-9eaf5f0e\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!less-loader?{\\\"sourceMap\\\":true}!../../../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./sequence_chart.vue\")\n}\nvar Component = require(\"!../../../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./sequence_chart.vue\"),\n  /* template */\n  require(\"!!../../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-9eaf5f0e\\\",\\\"hasScoped\\\":true}!../../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./sequence_chart.vue\"),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  \"data-v-9eaf5f0e\",\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/page/erp_pc/erp_report/report_block/sequence_chart.vue\n// module id = 1559\n// module chunks = 2","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"pageHeight\",\n    staticClass: \"page-secondnav page-commonnav\"\n  }, [_c('div', {\n    staticClass: \"f-content\"\n  }, [_c('div', {\n    ref: \"btnHeight\",\n    staticClass: \"console-pt4 console-pb4\"\n  }, [_c('el-button', {\n    attrs: {\n      \"type\": \"text\"\n    }\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"pull-right\"\n  }, [_c('el-button', {\n    staticClass: \"ui-color2 console-mr2\",\n    attrs: {\n      \"title\": \"\"\n    },\n    on: {\n      \"click\": _vm.initials\n    }\n  }, [_c('i', {\n    staticClass: \"fa fa-refresh\"\n  })]), _vm._v(\" \"), (_vm.arrowBot) ? _c('span', {\n    staticClass: \"color-1 margin-2 fm-query\",\n    on: {\n      \"click\": _vm.toggleSearch\n    }\n  }, [_vm._v(\"\"), _c('i', {\n    staticClass: \"el-icon-arrow-down margin-2\"\n  })]) : _vm._e(), _vm._v(\" \"), (_vm.arrowTop) ? _c('span', {\n    staticClass: \"color-1 margin-2 fm-query\",\n    on: {\n      \"click\": _vm.toggleSearch\n    }\n  }, [_vm._v(\"\"), _c('i', {\n    staticClass: \"el-icon-arrow-up margin-2\"\n  })]) : _vm._e()], 1)], 1), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.searchVisible),\n      expression: \"searchVisible\"\n    }],\n    ref: \"formHeight\",\n    staticClass: \"console-pb4\"\n  }, [_c('ZLCommonSearch', {\n    ref: \"ZLCommonSearch\",\n    attrs: {\n      \"fields\": _vm.searchFields\n    },\n    on: {\n      \"searchII\": _vm.search\n    }\n  })], 1), _vm._v(\" \"), _c('ZLCommonTable', {\n    attrs: {\n      \"tableData\": _vm.deliveryData,\n      \"tabHeight\": _vm.tabHeight,\n      \"itemValues\": _vm.itemValues,\n      \"isLoading\": _vm.isLoading\n    },\n    on: {\n      \"detail\": _vm.showDetail\n    }\n  }), _vm._v(\" \"), _c('el-pagination', {\n    staticClass: \"console-mt5\",\n    attrs: {\n      \"current-page\": _vm.cPage,\n      \"page-sizes\": _vm.cpageSizes,\n      \"page-size\": _vm.cSize,\n      \"layout\": \"total, sizes, prev, pager, next\",\n      \"total\": _vm.cTotal\n    },\n    on: {\n      \"size-change\": _vm.handleSizeChange,\n      \"current-change\": _vm.handleCurrentChange\n    }\n  }), _vm._v(\" \"), _c('el-dialog', {\n    staticClass: \"dialogDiv dialogDivII\",\n    attrs: {\n      \"show-close\": false,\n      \"size\": \"tiny\",\n      \"top\": _vm.dialog_top,\n      \"visible\": _vm.detailVisible,\n      \"width\": _vm.dialogW,\n      \"modal\": true\n    },\n    on: {\n      \"update:visible\": function($event) {\n        _vm.detailVisible = $event\n      }\n    }\n  }, [_c('div', {\n    staticClass: \"slideContent leftOffsetIII\",\n    style: ({\n      width: _vm.dialogW\n    })\n  }, [_c('div', {\n    directives: [{\n      name: \"drag1\",\n      rawName: \"v-drag1\"\n    }],\n    staticClass: \"slideTop\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"slideMid\"\n  }, [_c('sequence_chart', {\n    ref: \"sequence\",\n    attrs: {\n      \"detailVisible\": _vm.detailVisible\n    }\n  })], 1)])])], 1)])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-6ceb3fb0\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/page/erp_pc/erp_report/delivery_detail.vue\n// module id = 1683\n// module chunks = 2","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"chart-div\"\n  }, [_c('div', {\n    staticClass: \"bot-arrow\"\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"left-arrow\"\n  }), _vm._v(\" \"), _vm._m(0), _vm._v(\" \"), _c('div', {\n    staticClass: \"time-wrap\"\n  }, [_c('div', {\n    staticClass: \"item-div itemI\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemII\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.makematerialtime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemIII\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.qualitychecktime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemIV\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.targetbuildsitetime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemV\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.buildsiteoffloadtime) + \"\")])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"item-div itemVI\"\n  }, [_c('div', {\n    staticClass: \"text\"\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"time\"\n  }, [_vm._v(_vm._s(_vm.sendObj.targetstarttime) + \"\")])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextI\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextII\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextIII\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextIV\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime + _vm.sendObj.targetbuildsitetime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextV\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime + _vm.sendObj.targetbuildsitetime + _vm.sendObj.buildsiteoffloadtime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"xtext xtextVI\"\n  }, [_vm._v(_vm._s(_vm.sendObj.producecommandtime + _vm.sendObj.makematerialtime + _vm.sendObj.qualitychecktime + _vm.sendObj.targetbuildsitetime + _vm.sendObj.buildsiteoffloadtime + _vm.sendObj.targetstarttime))]), _vm._v(\" \"), _c('div', {\n    staticClass: \"x-text\"\n  }, [_vm._v(\"()\")])])\n},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"y-text\"\n  }, [_c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")]), _vm._v(\" \"), _c('span', [_vm._v(\"\")])])\n}]}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-9eaf5f0e\",\"hasScoped\":true}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/page/erp_pc/erp_report/report_block/sequence_chart.vue\n// module id = 1716\n// module chunks = 2","var Component = require(\"!../../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./delivery_detail.vue\"),\n  /* template */\n  require(\"!!../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-6ceb3fb0\\\",\\\"hasScoped\\\":false}!../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./delivery_detail.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/page/erp_pc/erp_report/delivery_detail.vue\n// module id = 769\n// module chunks = 2","/**\n * @module zrender/core/util\n */\n// mergeDate\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source != 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    result = [];\n\n    for (var i = 0, len = source.length; i < len; i++) {\n      result[i] = clone(source[i]);\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    var Ctor = source.constructor;\n\n    if (source.constructor.from) {\n      result = Ctor.from(source);\n    } else {\n      result = new Ctor(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // overwritetrue\n        // NOTE target[key] \n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * \n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz \n * @param {Function} baseClazz \n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    clazz.prototype[prop] = clazzPrototype[prop];\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data == 'string') {\n    return false;\n  }\n\n  return typeof data.length == 'number';\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type == 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  obj && each(obj, function (value, key) {\n    this.set(key, value);\n  }, this);\n} // Add prefix to avoid conflict with Object.prototype.\n\n\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this[HASH_MAP_PREFIX + key];\n  },\n  set: function (key, value) {\n    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n\n    return value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n\n    for (var prefixedKey in this) {\n      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n    }\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this[HASH_MAP_PREFIX + key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.noop = noop;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 794\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar pathTool = require(\"zrender/lib/tool/path\");\n\nvar colorTool = require(\"zrender/lib/tool/color\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar vector = require(\"zrender/lib/core/vector\");\n\nvar Path = require(\"zrender/lib/graphic/Path\");\n\nvar Transformable = require(\"zrender/lib/mixin/Transformable\");\n\nvar Image = require(\"zrender/lib/graphic/Image\");\n\nexports.Image = Image;\n\nvar Group = require(\"zrender/lib/container/Group\");\n\nexports.Group = Group;\n\nvar Text = require(\"zrender/lib/graphic/Text\");\n\nexports.Text = Text;\n\nvar Circle = require(\"zrender/lib/graphic/shape/Circle\");\n\nexports.Circle = Circle;\n\nvar Sector = require(\"zrender/lib/graphic/shape/Sector\");\n\nexports.Sector = Sector;\n\nvar Ring = require(\"zrender/lib/graphic/shape/Ring\");\n\nexports.Ring = Ring;\n\nvar Polygon = require(\"zrender/lib/graphic/shape/Polygon\");\n\nexports.Polygon = Polygon;\n\nvar Polyline = require(\"zrender/lib/graphic/shape/Polyline\");\n\nexports.Polyline = Polyline;\n\nvar Rect = require(\"zrender/lib/graphic/shape/Rect\");\n\nexports.Rect = Rect;\n\nvar Line = require(\"zrender/lib/graphic/shape/Line\");\n\nexports.Line = Line;\n\nvar BezierCurve = require(\"zrender/lib/graphic/shape/BezierCurve\");\n\nexports.BezierCurve = BezierCurve;\n\nvar Arc = require(\"zrender/lib/graphic/shape/Arc\");\n\nexports.Arc = Arc;\n\nvar CompoundPath = require(\"zrender/lib/graphic/CompoundPath\");\n\nexports.CompoundPath = CompoundPath;\n\nvar LinearGradient = require(\"zrender/lib/graphic/LinearGradient\");\n\nexports.LinearGradient = LinearGradient;\n\nvar RadialGradient = require(\"zrender/lib/graphic/RadialGradient\");\n\nexports.RadialGradient = RadialGradient;\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nexports.BoundingRect = BoundingRect;\nvar round = Math.round;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar EMPTY_OBJ = {};\n/**\n * Extend shape with parameters\n */\n\nfunction extendShape(opts) {\n  return Path.extend(opts);\n}\n/**\n * Extend path\n */\n\n\nfunction extendPath(pathData, opts) {\n  return pathTool.extendFromString(pathData, opts);\n}\n/**\n * Create a path element from path data string\n * @param {string} pathData\n * @param {Object} opts\n * @param {module:zrender/core/BoundingRect} rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\n\n\nfunction makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n  var boundingRect = path.getBoundingRect();\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, boundingRect);\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\n * Create a image element from image url\n * @param {string} imageUrl image url\n * @param {Object} opts options\n * @param {module:zrender/core/BoundingRect} rect constrain rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\n\n\nfunction makeImage(imageUrl, rect, layout) {\n  var path = new Image({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        path.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return path;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  {Object} rect         element local bounding box\n * @param  {Object} boundingRect constraint bounding box\n * @return {Object} element position containing x, y, width, and height\n */\n\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nvar mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param {module:zrender/graphic/Path} path\n * @param {Object} rect\n */\n\nfunction resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x1]\n * @param {number} [param.shape.y1]\n * @param {number} [param.shape.x2]\n * @param {number} [param.shape.y2]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\n\n\nfunction subPixelOptimizeLine(param) {\n  var shape = param.shape;\n  var lineWidth = param.style.lineWidth;\n\n  if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n  }\n\n  if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n  }\n\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x]\n * @param {number} [param.shape.y]\n * @param {number} [param.shape.width]\n * @param {number} [param.shape.height]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\n\n\nfunction subPixelOptimizeRect(param) {\n  var shape = param.shape;\n  var lineWidth = param.style.lineWidth;\n  var originX = shape.x;\n  var originY = shape.y;\n  var originWidth = shape.width;\n  var originHeight = shape.height;\n  shape.x = subPixelOptimize(shape.x, lineWidth, true);\n  shape.y = subPixelOptimize(shape.y, lineWidth, true);\n  shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);\n  shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nfunction hasFillOrStroke(fillOrStroke) {\n  return fillOrStroke != null && fillOrStroke != 'none';\n}\n\nfunction liftColor(color) {\n  return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n}\n/**\n * @private\n */\n\n\nfunction cacheElementStl(el) {\n  if (el.__hoverStlDirty) {\n    var stroke = el.style.stroke;\n    var fill = el.style.fill; // Create hoverStyle on mouseover\n\n    var hoverStyle = el.__hoverStl;\n    hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n    hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n    var normalStyle = {};\n\n    for (var name in hoverStyle) {\n      // See comment in `doSingleEnterHover`.\n      if (hoverStyle[name] != null) {\n        normalStyle[name] = el.style[name];\n      }\n    }\n\n    el.__normalStl = normalStyle;\n    el.__hoverStlDirty = false;\n  }\n}\n/**\n * @private\n */\n\n\nfunction doSingleEnterHover(el) {\n  if (el.__isHover) {\n    return;\n  }\n\n  cacheElementStl(el);\n\n  if (el.useHoverLayer) {\n    el.__zr && el.__zr.addHover(el, el.__hoverStl);\n  } else {\n    var style = el.style;\n    var insideRollbackOpt = style.insideRollbackOpt; // Consider case: only `position: 'top'` is set on emphasis, then text\n    // color should be returned to `autoColor`, rather than remain '#fff'.\n    // So we should rollback then apply again after style merging.\n\n    insideRollbackOpt && rollbackInsideStyle(style); // styles can be:\n    // {\n    //     label: {\n    //         normal: {\n    //             show: false,\n    //             position: 'outside',\n    //             fontSize: 18\n    //         },\n    //         emphasis: {\n    //             show: true\n    //         }\n    //     }\n    // },\n    // where properties of `emphasis` may not appear in `normal`. We previously use\n    // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.\n    // But consider rich text and setOption in merge mode, it is impossible to cover\n    // all properties in merge. So we use merge mode when setting style here, where\n    // only properties that is not `null/undefined` can be set. The disadventage:\n    // null/undefined can not be used to remove style any more in `emphasis`.\n\n    style.extendFrom(el.__hoverStl); // Do not save `insideRollback`.\n\n    if (insideRollbackOpt) {\n      applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt); // textFill may be rollbacked to null.\n\n      if (style.textFill == null) {\n        style.textFill = insideRollbackOpt.autoColor;\n      }\n    }\n\n    el.dirty(false);\n    el.z2 += 1;\n  }\n\n  el.__isHover = true;\n}\n/**\n * @inner\n */\n\n\nfunction doSingleLeaveHover(el) {\n  if (!el.__isHover) {\n    return;\n  }\n\n  var normalStl = el.__normalStl;\n\n  if (el.useHoverLayer) {\n    el.__zr && el.__zr.removeHover(el);\n  } else {\n    // Consider null/undefined value, should use\n    // `setStyle` but not `extendFrom(stl, true)`.\n    normalStl && el.setStyle(normalStl);\n    el.z2 -= 1;\n  }\n\n  el.__isHover = false;\n}\n/**\n * @inner\n */\n\n\nfunction doEnterHover(el) {\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      doSingleEnterHover(child);\n    }\n  }) : doSingleEnterHover(el);\n}\n\nfunction doLeaveHover(el) {\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      doSingleLeaveHover(child);\n    }\n  }) : doSingleLeaveHover(el);\n}\n/**\n * @inner\n */\n\n\nfunction setElementHoverStl(el, hoverStl) {\n  // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n  // Often used when item group has a label element and it's hoverStyle is different\n  el.__hoverStl = el.hoverStyle || hoverStl || {};\n  el.__hoverStlDirty = true;\n\n  if (el.__isHover) {\n    cacheElementStl(el);\n  }\n}\n/**\n * @inner\n */\n\n\nfunction onElementMouseOver(e) {\n  if (this.__hoverSilentOnTouch && e.zrByTouch) {\n    return;\n  } // Only if element is not in emphasis status\n\n\n  !this.__isEmphasis && doEnterHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction onElementMouseOut(e) {\n  if (this.__hoverSilentOnTouch && e.zrByTouch) {\n    return;\n  } // Only if element is not in emphasis status\n\n\n  !this.__isEmphasis && doLeaveHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction enterEmphasis() {\n  this.__isEmphasis = true;\n  doEnterHover(this);\n}\n/**\n * @inner\n */\n\n\nfunction leaveEmphasis() {\n  this.__isEmphasis = false;\n  doLeaveHover(this);\n}\n/**\n * Set hover style of element.\n * This method can be called repeatly without side-effects.\n * @param {module:zrender/Element} el\n * @param {Object} [hoverStyle]\n * @param {Object} [opt]\n * @param {boolean} [opt.hoverSilentOnTouch=false]\n *        In touch device, mouseover event will be trigger on touchstart event\n *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n *        conviniently use hoverStyle when tap on touch screen without additional\n *        code for compatibility.\n *        But if the chart/component has select feature, which usually also use\n *        hoverStyle, there might be conflict between 'select-highlight' and\n *        'hover-highlight' especially when roam is enabled (see geo for example).\n *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n *        on touch device.\n */\n\n\nfunction setHoverStyle(el, hoverStyle, opt) {\n  el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n  el.type === 'group' ? el.traverse(function (child) {\n    if (child.type !== 'group') {\n      setElementHoverStl(child, hoverStyle);\n    }\n  }) : setElementHoverStl(el, hoverStyle); // Duplicated function will be auto-ignored, see Eventful.js.\n\n  el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut); // Emphasis, normal can be triggered manually\n\n  el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);\n}\n/**\n * @param {Object|module:zrender/graphic/Style} normalStyle\n * @param {Object} emphasisStyle\n * @param {module:echarts/model/Model} normalModel\n * @param {module:echarts/model/Model} emphasisModel\n * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.\n * @param {Object} [opt.defaultText]\n * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by\n *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {Object} [normalSpecified]\n * @param {Object} [emphasisSpecified]\n */\n\n\nfunction setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {\n  opt = opt || EMPTY_OBJ;\n  var labelFetcher = opt.labelFetcher;\n  var labelDataIndex = opt.labelDataIndex;\n  var labelDimIndex = opt.labelDimIndex; // This scenario, `label.normal.show = true; label.emphasis.show = false`,\n  // is not supported util someone requests.\n\n  var showNormal = normalModel.getShallow('show');\n  var showEmphasis = emphasisModel.getShallow('show'); // Consider performance, only fetch label when necessary.\n  // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,\n  // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.\n\n  var baseText = showNormal || showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex) : null, opt.defaultText) : null;\n  var normalStyleText = showNormal ? baseText : null;\n  var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null; // Optimize: If style.text is null, text will not be drawn.\n\n  if (normalStyleText != null || emphasisStyleText != null) {\n    // Always set `textStyle` even if `normalStyle.text` is null, because default\n    // values have to be set on `normalStyle`.\n    // If we set default values on `emphasisStyle`, consider case:\n    // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`\n    // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`\n    // Then the 'red' will not work on emphasis.\n    setTextStyle(normalStyle, normalModel, normalSpecified, opt);\n    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);\n  }\n\n  normalStyle.text = normalStyleText;\n  emphasisStyle.text = emphasisStyleText;\n}\n/**\n * Set basic textStyle properties.\n * @param {Object|module:zrender/graphic/Style} textStyle\n * @param {module:echarts/model/Model} model\n * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.\n * @param {Object} [opt] See `opt` of `setTextStyleCommon`.\n * @param {boolean} [isEmphasis]\n */\n\n\nfunction setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {\n  setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);\n  specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);\n  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n  return textStyle;\n}\n/**\n * Set text option in the style.\n * @deprecated\n * @param {Object} textStyle\n * @param {module:echarts/model/Model} labelModel\n * @param {string|boolean} defaultColor Default text color.\n *        If set as false, it will be processed as a emphasis style.\n */\n\n\nfunction setText(textStyle, labelModel, defaultColor) {\n  var opt = {\n    isRectText: true\n  };\n  var isEmphasis;\n\n  if (defaultColor === false) {\n    isEmphasis = true;\n  } else {\n    // Support setting color as 'auto' to get visual color.\n    opt.autoColor = defaultColor;\n  }\n\n  setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);\n  textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n}\n/**\n * {\n *      disableBox: boolean, Whether diable drawing box of block (outer most).\n *      isRectText: boolean,\n *      autoColor: string, specify a color when color is 'auto',\n *              for textFill, textStroke, textBackgroundColor, and textBorderColor.\n *              If autoColor specified, it is used as default textFill.\n *      useInsideStyle:\n *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)\n *                  if `textFill` is not specified.\n *              `false`: Do not use inside style.\n *              `null/undefined`: use inside style if `isRectText` is true and\n *                  `textFill` is not specified and textPosition contains `'inside'`.\n *      forceRich: boolean\n * }\n */\n\n\nfunction setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {\n  // Consider there will be abnormal when merge hover style to normal style if given default value.\n  opt = opt || EMPTY_OBJ;\n\n  if (opt.isRectText) {\n    var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used\n    // in bar series, and magric type should be considered.\n\n    textPosition === 'outside' && (textPosition = 'top');\n    textStyle.textPosition = textPosition;\n    textStyle.textOffset = textStyleModel.getShallow('offset');\n    var labelRotate = textStyleModel.getShallow('rotate');\n    labelRotate != null && (labelRotate *= Math.PI / 180);\n    textStyle.textRotation = labelRotate;\n    textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow('distance'), isEmphasis ? null : 5);\n  }\n\n  var ecModel = textStyleModel.ecModel;\n  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:\n  // {\n  //     data: [{\n  //         value: 12,\n  //         label: {\n  //             normal: {\n  //                 rich: {\n  //                     // no 'a' here but using parent 'a'.\n  //                 }\n  //             }\n  //         }\n  //     }],\n  //     rich: {\n  //         a: { ... }\n  //     }\n  // }\n\n  var richItemNames = getRichItemNames(textStyleModel);\n  var richResult;\n\n  if (richItemNames) {\n    richResult = {};\n\n    for (var name in richItemNames) {\n      if (richItemNames.hasOwnProperty(name)) {\n        // Cascade is supported in rich.\n        var richTextStyle = textStyleModel.getModel(['rich', name]); // In rich, never `disableBox`.\n\n        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);\n      }\n    }\n  }\n\n  textStyle.rich = richResult;\n  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);\n\n  if (opt.forceRich && !opt.textStyle) {\n    opt.textStyle = {};\n  }\n\n  return textStyle;\n} // Consider case:\n// {\n//     data: [{\n//         value: 12,\n//         label: {\n//             normal: {\n//                 rich: {\n//                     // no 'a' here but using parent 'a'.\n//                 }\n//             }\n//         }\n//     }],\n//     rich: {\n//         a: { ... }\n//     }\n// }\n\n\nfunction getRichItemNames(textStyleModel) {\n  // Use object to remove duplicated names.\n  var richItemNameMap;\n\n  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n    var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n\n    if (rich) {\n      richItemNameMap = richItemNameMap || {};\n\n      for (var name in rich) {\n        if (rich.hasOwnProperty(name)) {\n          richItemNameMap[name] = 1;\n        }\n      }\n    }\n\n    textStyleModel = textStyleModel.parentModel;\n  }\n\n  return richItemNameMap;\n}\n\nfunction setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {\n  // In merge mode, default value should not be given.\n  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;\n  textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;\n  textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;\n  textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);\n\n  if (!isEmphasis) {\n    if (isBlock) {\n      // Always set `insideRollback`, for clearing previous.\n      var originalTextPosition = textStyle.textPosition;\n      textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt); // Save original textPosition, because style.textPosition will be repalced by\n      // real location (like [10, 30]) in zrender.\n\n      textStyle.insideOriginalTextPosition = originalTextPosition;\n      textStyle.insideRollbackOpt = opt;\n    } // Set default finally.\n\n\n    if (textStyle.textFill == null) {\n      textStyle.textFill = opt.autoColor;\n    }\n  } // Do not use `getFont` here, because merge should be supported, where\n  // part of these properties may be changed in emphasis style, and the\n  // others should remain their original value got from normal style.\n\n\n  textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;\n  textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;\n  textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;\n  textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;\n  textStyle.textAlign = textStyleModel.getShallow('align');\n  textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');\n  textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');\n  textStyle.textWidth = textStyleModel.getShallow('width');\n  textStyle.textHeight = textStyleModel.getShallow('height');\n  textStyle.textTag = textStyleModel.getShallow('tag');\n\n  if (!isBlock || !opt.disableBox) {\n    textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);\n    textStyle.textPadding = textStyleModel.getShallow('padding');\n    textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);\n    textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');\n    textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');\n    textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');\n    textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');\n    textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');\n    textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');\n  }\n\n  textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;\n  textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;\n  textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;\n  textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;\n}\n\nfunction getAutoColor(color, opt) {\n  return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;\n}\n\nfunction applyInsideStyle(textStyle, textPosition, opt) {\n  var useInsideStyle = opt.useInsideStyle;\n  var insideRollback;\n\n  if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition // textPosition can be [10, 30]\n  && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {\n    insideRollback = {\n      textFill: null,\n      textStroke: textStyle.textStroke,\n      textStrokeWidth: textStyle.textStrokeWidth\n    };\n    textStyle.textFill = '#fff'; // Consider text with #fff overflow its container.\n\n    if (textStyle.textStroke == null) {\n      textStyle.textStroke = opt.autoColor;\n      textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);\n    }\n  }\n\n  return insideRollback;\n}\n\nfunction rollbackInsideStyle(style) {\n  var insideRollback = style.insideRollback;\n\n  if (insideRollback) {\n    style.textFill = insideRollback.textFill;\n    style.textStroke = insideRollback.textStroke;\n    style.textStrokeWidth = insideRollback.textStrokeWidth;\n  }\n}\n\nfunction getFont(opt, ecModel) {\n  // ecModel or default text style model.\n  var gTextStyleModel = ecModel || ecModel.getModel('textStyle');\n  return [// FIXME in node-canvas fontWeight is before fontStyle\n  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' ');\n}\n\nfunction animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n  if (typeof dataIndex === 'function') {\n    cb = dataIndex;\n    dataIndex = null;\n  } // Do not check 'animation' property directly here. Consider this case:\n  // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n  // but its parent model (`seriesModel`) does.\n\n\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n  if (animationEnabled) {\n    var postfix = isUpdate ? 'Update' : '';\n    var duration = animatableModel.getShallow('animationDuration' + postfix);\n    var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n    var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n\n    if (typeof animationDelay === 'function') {\n      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n    }\n\n    if (typeof duration === 'function') {\n      duration = duration(dataIndex);\n    }\n\n    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());\n  } else {\n    el.stopAnimation();\n    el.attr(props);\n    cb && cb();\n  }\n}\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} [cb]\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\n\n\nfunction updateProps(el, props, animatableModel, dataIndex, cb) {\n  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n}\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} cb\n */\n\n\nfunction initProps(el, props, animatableModel, dataIndex, cb) {\n  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n}\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param {module:zrender/mixin/Transformable} target\n * @param {module:zrender/mixin/Transformable} [ancestor]\n */\n\n\nfunction getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param {Array.<number>} target [x, y]\n * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param {boolean=} invert Whether use invert matrix.\n * @return {Array.<number>} [x, y]\n */\n\n\nfunction applyTransform(target, transform, invert) {\n  if (transform && !zrUtil.isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param {string} direction 'left' 'right' 'top' 'bottom'\n * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param {boolean=} invert Whether use invert matrix.\n * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\n\nfunction transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\n\nfunction groupTransition(g1, g2, animatableModel, cb) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (!el.isGroup && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      position: vector.clone(el.position),\n      rotation: el.rotation\n    };\n\n    if (el.shape) {\n      obj.shape = zrUtil.extend({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (!el.isGroup && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, el.dataIndex);\n      } // else {\n      //     if (el.previousProps) {\n      //         graphic.updateProps\n      //     }\n      // }\n\n    }\n  });\n}\n/**\n * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n * @param {Object} rect {x, y, width, height}\n * @return {Array.<Array.<number>>} A new clipped points.\n */\n\n\nfunction clipPointsByRect(points, rect) {\n  return zrUtil.map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * @param {Object} targetRect {x, y, width, height}\n * @param {Object} rect {x, y, width, height}\n * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n */\n\n\nfunction clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n/**\n * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.\n * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.\n * @param {Object} [rect] {x, y, width, height}\n * @return {module:zrender/Element} Icon path or image element.\n */\n\n\nfunction createIcon(iconStr, opt, rect) {\n  opt = zrUtil.extend({\n    rectHover: true\n  }, opt);\n  var style = opt.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new Image(opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');\n  }\n}\n\nexports.extendShape = extendShape;\nexports.extendPath = extendPath;\nexports.makePath = makePath;\nexports.makeImage = makeImage;\nexports.mergePath = mergePath;\nexports.resizePath = resizePath;\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;\nexports.setHoverStyle = setHoverStyle;\nexports.setLabelStyle = setLabelStyle;\nexports.setTextStyle = setTextStyle;\nexports.setText = setText;\nexports.getFont = getFont;\nexports.updateProps = updateProps;\nexports.initProps = initProps;\nexports.getTransform = getTransform;\nexports.applyTransform = applyTransform;\nexports.transformDirection = transformDirection;\nexports.groupTransition = groupTransition;\nexports.clipPointsByRect = clipPointsByRect;\nexports.clipRectByRect = clipRectByRect;\nexports.createIcon = createIcon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/graphic.js\n// module id = 808\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"./config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrender = require(\"zrender/lib/zrender\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar colorTool = require(\"zrender/lib/tool/color\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar timsort = require(\"zrender/lib/core/timsort\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar GlobalModel = require(\"./model/Global\");\n\nvar ExtensionAPI = require(\"./ExtensionAPI\");\n\nvar CoordinateSystemManager = require(\"./CoordinateSystem\");\n\nvar OptionManager = require(\"./model/OptionManager\");\n\nvar backwardCompat = require(\"./preprocessor/backwardCompat\");\n\nvar ComponentModel = require(\"./model/Component\");\n\nvar SeriesModel = require(\"./model/Series\");\n\nvar ComponentView = require(\"./view/Component\");\n\nvar ChartView = require(\"./view/Chart\");\n\nvar graphic = require(\"./util/graphic\");\n\nvar modelUtil = require(\"./util/model\");\n\nvar _throttle = require(\"./util/throttle\");\n\nvar throttle = _throttle.throttle;\n\nvar seriesColor = require(\"./visual/seriesColor\");\n\nvar loadingDefault = require(\"./loading/default\");\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\nvar each = zrUtil.each;\nvar parseClassType = ComponentModel.parseClassType;\nvar version = '3.8.5';\nvar dependencies = {\n  zrender: '3.7.4'\n};\nvar PRIORITY_PROCESSOR_FILTER = 1000;\nvar PRIORITY_PROCESSOR_STATISTIC = 5000;\nvar PRIORITY_VISUAL_LAYOUT = 1000;\nvar PRIORITY_VISUAL_GLOBAL = 2000;\nvar PRIORITY_VISUAL_CHART = 3000;\nvar PRIORITY_VISUAL_COMPONENT = 4000; // FIXME\n// necessary?\n\nvar PRIORITY_VISUAL_BRUSH = 5000;\nvar PRIORITY = {\n  PROCESSOR: {\n    FILTER: PRIORITY_PROCESSOR_FILTER,\n    STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n  },\n  VISUAL: {\n    LAYOUT: PRIORITY_VISUAL_LAYOUT,\n    GLOBAL: PRIORITY_VISUAL_GLOBAL,\n    CHART: PRIORITY_VISUAL_CHART,\n    COMPONENT: PRIORITY_VISUAL_COMPONENT,\n    BRUSH: PRIORITY_VISUAL_BRUSH\n  }\n}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n// where they must not be invoked nestedly, except the only case: invoke\n// dispatchAction with updateMethod \"none\" in main process.\n// This flag is used to carry out this rule.\n// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\nvar IN_MAIN_PROCESS = '__flagInMainProcess';\nvar HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\nvar OPTION_UPDATED = '__optionUpdated';\nvar ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\nfunction createRegisterEventWithLowercaseName(method) {\n  return function (eventName, handler, context) {\n    // Event name is all lowercase\n    eventName = eventName && eventName.toLowerCase();\n    Eventful.prototype[method].call(this, eventName, handler, context);\n  };\n}\n/**\n * @module echarts~MessageCenter\n */\n\n\nfunction MessageCenter() {\n  Eventful.call(this);\n}\n\nMessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\nMessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\nMessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\nzrUtil.mixin(MessageCenter, Eventful);\n/**\n * @module echarts~ECharts\n */\n\nfunction ECharts(dom, theme, opts) {\n  opts = opts || {}; // Get theme by name\n\n  if (typeof theme === 'string') {\n    theme = themeStorage[theme];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  this.id;\n  /**\n   * Group id\n   * @type {string}\n   */\n\n  this.group;\n  /**\n   * @type {HTMLElement}\n   * @private\n   */\n\n  this._dom = dom;\n  var defaultRenderer = 'canvas';\n\n  /**\n   * @type {module:zrender/ZRender}\n   * @private\n   */\n  var zr = this._zr = zrender.init(dom, {\n    renderer: opts.renderer || defaultRenderer,\n    devicePixelRatio: opts.devicePixelRatio,\n    width: opts.width,\n    height: opts.height\n  });\n  /**\n   * Expect 60 pfs.\n   * @type {Function}\n   * @private\n   */\n\n  this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);\n  var theme = zrUtil.clone(theme);\n  theme && backwardCompat(theme, true);\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._theme = theme;\n  /**\n   * @type {Array.<module:echarts/view/Chart>}\n   * @private\n   */\n\n  this._chartsViews = [];\n  /**\n   * @type {Object.<string, module:echarts/view/Chart>}\n   * @private\n   */\n\n  this._chartsMap = {};\n  /**\n   * @type {Array.<module:echarts/view/Component>}\n   * @private\n   */\n\n  this._componentsViews = [];\n  /**\n   * @type {Object.<string, module:echarts/view/Component>}\n   * @private\n   */\n\n  this._componentsMap = {};\n  /**\n   * @type {module:echarts/CoordinateSystem}\n   * @private\n   */\n\n  this._coordSysMgr = new CoordinateSystemManager();\n  /**\n   * @type {module:echarts/ExtensionAPI}\n   * @private\n   */\n\n  this._api = createExtensionAPI(this);\n  Eventful.call(this);\n  /**\n   * @type {module:echarts~MessageCenter}\n   * @private\n   */\n\n  this._messageCenter = new MessageCenter(); // Init mouse events\n\n  this._initEvents(); // In case some people write `window.onresize = chart.resize`\n\n\n  this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure\n\n  this._pendingActions = []; // Sort on demand\n\n  function prioritySortFunc(a, b) {\n    return a.prio - b.prio;\n  }\n\n  timsort(visualFuncs, prioritySortFunc);\n  timsort(dataProcessorFuncs, prioritySortFunc);\n  zr.animation.on('frame', this._onframe, this); // ECharts instance can be used as value.\n\n  zrUtil.setAsPrimitive(this);\n}\n\nvar echartsProto = ECharts.prototype;\n\nechartsProto._onframe = function () {\n  // Lazy update\n  if (this[OPTION_UPDATED]) {\n    var silent = this[OPTION_UPDATED].silent;\n    this[IN_MAIN_PROCESS] = true;\n    updateMethods.prepareAndUpdate.call(this);\n    this[IN_MAIN_PROCESS] = false;\n    this[OPTION_UPDATED] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  }\n};\n/**\n * @return {HTMLElement}\n */\n\n\nechartsProto.getDom = function () {\n  return this._dom;\n};\n/**\n * @return {module:zrender~ZRender}\n */\n\n\nechartsProto.getZr = function () {\n  return this._zr;\n};\n/**\n * Usage:\n * chart.setOption(option, notMerge, lazyUpdate);\n * chart.setOption(option, {\n *     notMerge: ...,\n *     lazyUpdate: ...,\n *     silent: ...\n * });\n *\n * @param {Object} option\n * @param {Object|boolean} [opts] opts or notMerge.\n * @param {boolean} [opts.notMerge=false]\n * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n */\n\n\nechartsProto.setOption = function (option, notMerge, lazyUpdate) {\n  var silent;\n\n  if (zrUtil.isObject(notMerge)) {\n    lazyUpdate = notMerge.lazyUpdate;\n    silent = notMerge.silent;\n    notMerge = notMerge.notMerge;\n  }\n\n  this[IN_MAIN_PROCESS] = true;\n\n  if (!this._model || notMerge) {\n    var optionManager = new OptionManager(this._api);\n    var theme = this._theme;\n    var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n    ecModel.init(null, null, theme, optionManager);\n  }\n\n  this._model.setOption(option, optionPreprocessorFuncs);\n\n  if (lazyUpdate) {\n    this[OPTION_UPDATED] = {\n      silent: silent\n    };\n    this[IN_MAIN_PROCESS] = false;\n  } else {\n    updateMethods.prepareAndUpdate.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be\n    // fetched after `setOption`.\n\n    this._zr.flush();\n\n    this[OPTION_UPDATED] = false;\n    this[IN_MAIN_PROCESS] = false;\n    flushPendingActions.call(this, silent);\n    triggerUpdatedEvent.call(this, silent);\n  }\n};\n/**\n * @DEPRECATED\n */\n\n\nechartsProto.setTheme = function () {\n  console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n};\n/**\n * @return {module:echarts/model/Global}\n */\n\n\nechartsProto.getModel = function () {\n  return this._model;\n};\n/**\n * @return {Object}\n */\n\n\nechartsProto.getOption = function () {\n  return this._model && this._model.getOption();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getWidth = function () {\n  return this._zr.getWidth();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getHeight = function () {\n  return this._zr.getHeight();\n};\n/**\n * @return {number}\n */\n\n\nechartsProto.getDevicePixelRatio = function () {\n  return this._zr.painter.dpr || window.devicePixelRatio || 1;\n};\n/**\n * Get canvas which has all thing rendered\n * @param {Object} opts\n * @param {string} [opts.backgroundColor]\n * @return {string}\n */\n\n\nechartsProto.getRenderedCanvas = function (opts) {\n  if (!env.canvasSupported) {\n    return;\n  }\n\n  opts = opts || {};\n  opts.pixelRatio = opts.pixelRatio || 1;\n  opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n  var zr = this._zr;\n  var list = zr.storage.getDisplayList(); // Stop animations\n\n  zrUtil.each(list, function (el) {\n    el.stopAnimation(true);\n  });\n  return zr.painter.getRenderedCanvas(opts);\n};\n/**\n * Get svg data url\n * @return {string}\n */\n\n\nechartsProto.getSvgDataUrl = function () {\n  if (!env.svgSupported) {\n    return;\n  }\n\n  var zr = this._zr;\n  var list = zr.storage.getDisplayList(); // Stop animations\n\n  zrUtil.each(list, function (el) {\n    el.stopAnimation(true);\n  });\n  return zr.painter.pathToSvg();\n};\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n * @param {string} [opts.excludeComponents]\n */\n\n\nechartsProto.getDataURL = function (opts) {\n  opts = opts || {};\n  var excludeComponents = opts.excludeComponents;\n  var ecModel = this._model;\n  var excludesComponentViews = [];\n  var self = this;\n  each(excludeComponents, function (componentType) {\n    ecModel.eachComponent({\n      mainType: componentType\n    }, function (component) {\n      var view = self._componentsMap[component.__viewId];\n\n      if (!view.group.ignore) {\n        excludesComponentViews.push(view);\n        view.group.ignore = true;\n      }\n    });\n  });\n  var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n  each(excludesComponentViews, function (view) {\n    view.group.ignore = false;\n  });\n  return url;\n};\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n */\n\n\nechartsProto.getConnectedDataURL = function (opts) {\n  if (!env.canvasSupported) {\n    return;\n  }\n\n  var groupId = this.group;\n  var mathMin = Math.min;\n  var mathMax = Math.max;\n  var MAX_NUMBER = Infinity;\n\n  if (connectedGroups[groupId]) {\n    var left = MAX_NUMBER;\n    var top = MAX_NUMBER;\n    var right = -MAX_NUMBER;\n    var bottom = -MAX_NUMBER;\n    var canvasList = [];\n    var dpr = opts && opts.pixelRatio || 1;\n    zrUtil.each(instances, function (chart, id) {\n      if (chart.group === groupId) {\n        var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));\n        var boundingRect = chart.getDom().getBoundingClientRect();\n        left = mathMin(boundingRect.left, left);\n        top = mathMin(boundingRect.top, top);\n        right = mathMax(boundingRect.right, right);\n        bottom = mathMax(boundingRect.bottom, bottom);\n        canvasList.push({\n          dom: canvas,\n          left: boundingRect.left,\n          top: boundingRect.top\n        });\n      }\n    });\n    left *= dpr;\n    top *= dpr;\n    right *= dpr;\n    bottom *= dpr;\n    var width = right - left;\n    var height = bottom - top;\n    var targetCanvas = zrUtil.createCanvas();\n    targetCanvas.width = width;\n    targetCanvas.height = height;\n    var zr = zrender.init(targetCanvas);\n    each(canvasList, function (item) {\n      var img = new graphic.Image({\n        style: {\n          x: item.left * dpr - left,\n          y: item.top * dpr - top,\n          image: item.dom\n        }\n      });\n      zr.add(img);\n    });\n    zr.refreshImmediately();\n    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n  } else {\n    return this.getDataURL(opts);\n  }\n};\n/**\n * Convert from logical coordinate system to pixel coordinate system.\n * See CoordinateSystem#convertToPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId, geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\n\n\nechartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n/**\n * Convert from pixel coordinate system to logical coordinate system.\n * See CoordinateSystem#convertFromPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\n\nechartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\nfunction doConvertPixel(methodName, finder, value) {\n  var ecModel = this._model;\n\n  var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\n  var result;\n  finder = modelUtil.parseFinder(ecModel, finder);\n\n  for (var i = 0; i < coordSysList.length; i++) {\n    var coordSys = coordSysList[i];\n\n    if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {\n      return result;\n    }\n  }\n}\n/**\n * Is the specified coordinate systems or components contain the given pixel point.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {boolean} result\n */\n\n\nechartsProto.containPixel = function (finder, value) {\n  var ecModel = this._model;\n  var result;\n  finder = modelUtil.parseFinder(ecModel, finder);\n  zrUtil.each(finder, function (models, key) {\n    key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n      var coordSys = model.coordinateSystem;\n\n      if (coordSys && coordSys.containPoint) {\n        result |= !!coordSys.containPoint(value);\n      } else if (key === 'seriesModels') {\n        var view = this._chartsMap[model.__viewId];\n\n        if (view && view.containPoint) {\n          result |= view.containPoint(value, model);\n        } else {}\n      } else {}\n    }, this);\n  }, this);\n  return !!result;\n};\n/**\n * Get visual from series or data.\n * @param {string|Object} finder\n *        If string, e.g., 'series', means {seriesIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            dataIndex / dataIndexInside\n *        }\n *        If dataIndex is not specified, series visual will be fetched,\n *        but not data item visual.\n *        If all of seriesIndex, seriesId, seriesName are not specified,\n *        visual will be fetched from first series.\n * @param {string} visualType 'color', 'symbol', 'symbolSize'\n */\n\n\nechartsProto.getVisual = function (finder, visualType) {\n  var ecModel = this._model;\n  finder = modelUtil.parseFinder(ecModel, finder, {\n    defaultMainType: 'series'\n  });\n  var seriesModel = finder.seriesModel;\n  var data = seriesModel.getData();\n  var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;\n  return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);\n};\n/**\n * Get view of corresponding component model\n * @param  {module:echarts/model/Component} componentModel\n * @return {module:echarts/view/Component}\n */\n\n\nechartsProto.getViewOfComponentModel = function (componentModel) {\n  return this._componentsMap[componentModel.__viewId];\n};\n/**\n * Get view of corresponding series model\n * @param  {module:echarts/model/Series} seriesModel\n * @return {module:echarts/view/Chart}\n */\n\n\nechartsProto.getViewOfSeriesModel = function (seriesModel) {\n  return this._chartsMap[seriesModel.__viewId];\n};\n\nvar updateMethods = {\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  update: function (payload) {\n    // console.profile && console.profile('update');\n    var ecModel = this._model;\n    var api = this._api;\n    var coordSysMgr = this._coordSysMgr;\n    var zr = this._zr; // update before setOption\n\n    if (!ecModel) {\n      return;\n    } // Fixme First time update ?\n\n\n    ecModel.restoreData(); // TODO\n    // Save total ecModel here for undo/redo (after restoring data and before processing data).\n    // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n    // Create new coordinate system each update\n    // In LineView may save the old coordinate system and use it to get the orignal point\n\n    coordSysMgr.create(this._model, this._api);\n    processData.call(this, ecModel, api);\n    stackSeriesData.call(this, ecModel);\n    coordSysMgr.update(ecModel, api);\n    doVisualEncoding.call(this, ecModel, payload);\n    doRender.call(this, ecModel, payload); // Set background\n\n    var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n    var painter = zr.painter; // TODO all use clearColor ?\n\n    if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n      zr.configLayer(0, {\n        clearColor: backgroundColor\n      });\n    } else {\n      // In IE8\n      if (!env.canvasSupported) {\n        var colorArr = colorTool.parse(backgroundColor);\n        backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\n        if (colorArr[3] === 0) {\n          backgroundColor = 'transparent';\n        }\n      }\n\n      if (backgroundColor.colorStops || backgroundColor.image) {\n        // Gradient background\n        // FIXME Fixed layer\n        zr.configLayer(0, {\n          clearColor: backgroundColor\n        });\n        this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n        this._dom.style.background = 'transparent';\n      } else {\n        if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n          zr.configLayer(0, {\n            clearColor: null\n          });\n        }\n\n        this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n        this._dom.style.background = backgroundColor;\n      }\n    }\n\n    each(postUpdateFuncs, function (func) {\n      func(ecModel, api);\n    }); // console.profile && console.profileEnd('update');\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateView: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    ecModel.eachSeries(function (seriesModel) {\n      seriesModel.getData().clearAllVisual();\n    });\n    doVisualEncoding.call(this, ecModel, payload);\n    invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateVisual: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    ecModel.eachSeries(function (seriesModel) {\n      seriesModel.getData().clearAllVisual();\n    });\n    doVisualEncoding.call(this, ecModel, payload, true);\n    invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  updateLayout: function (payload) {\n    var ecModel = this._model; // update before setOption\n\n    if (!ecModel) {\n      return;\n    }\n\n    doLayout.call(this, ecModel, payload);\n    invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n  },\n\n  /**\n   * @param {Object} payload\n   * @private\n   */\n  prepareAndUpdate: function (payload) {\n    var ecModel = this._model;\n    prepareView.call(this, 'component', ecModel);\n    prepareView.call(this, 'chart', ecModel);\n    updateMethods.update.call(this, payload);\n  }\n};\n/**\n * @private\n */\n\nfunction updateDirectly(ecIns, method, payload, mainType, subType) {\n  var ecModel = ecIns._model; // broadcast\n\n  if (!mainType) {\n    each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n    return;\n  }\n\n  var query = {};\n  query[mainType + 'Id'] = payload[mainType + 'Id'];\n  query[mainType + 'Index'] = payload[mainType + 'Index'];\n  query[mainType + 'Name'] = payload[mainType + 'Name'];\n  var condition = {\n    mainType: mainType,\n    query: query\n  };\n  subType && (condition.subType = subType); // subType may be '' by parseClassType;\n  // If dispatchAction before setOption, do nothing.\n\n  ecModel && ecModel.eachComponent(condition, function (model, index) {\n    callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);\n  }, ecIns);\n\n  function callView(view) {\n    view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);\n  }\n}\n/**\n * Resize the chart\n * @param {Object} opts\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n * @param {boolean} [opts.silent=false]\n */\n\n\nechartsProto.resize = function (opts) {\n  this[IN_MAIN_PROCESS] = true;\n\n  this._zr.resize(opts);\n\n  var optionChanged = this._model && this._model.resetOption('media');\n\n  var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n  updateMethods[updateMethod].call(this); // Resize loading effect\n\n  this._loadingFX && this._loadingFX.resize();\n  this[IN_MAIN_PROCESS] = false;\n  var silent = opts && opts.silent;\n  flushPendingActions.call(this, silent);\n  triggerUpdatedEvent.call(this, silent);\n};\n/**\n * Show loading effect\n * @param  {string} [name='default']\n * @param  {Object} [cfg]\n */\n\n\nechartsProto.showLoading = function (name, cfg) {\n  if (zrUtil.isObject(name)) {\n    cfg = name;\n    name = '';\n  }\n\n  name = name || 'default';\n  this.hideLoading();\n\n  if (!loadingEffects[name]) {\n    return;\n  }\n\n  var el = loadingEffects[name](this._api, cfg);\n  var zr = this._zr;\n  this._loadingFX = el;\n  zr.add(el);\n};\n/**\n * Hide loading effect\n */\n\n\nechartsProto.hideLoading = function () {\n  this._loadingFX && this._zr.remove(this._loadingFX);\n  this._loadingFX = null;\n};\n/**\n * @param {Object} eventObj\n * @return {Object}\n */\n\n\nechartsProto.makeActionFromEvent = function (eventObj) {\n  var payload = zrUtil.extend({}, eventObj);\n  payload.type = eventActionMap[eventObj.type];\n  return payload;\n};\n/**\n * @pubilc\n * @param {Object} payload\n * @param {string} [payload.type] Action type\n * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n * @param {boolean} [opt.silent=false] Whether trigger events.\n * @param {boolean} [opt.flush=undefined]\n *                  true: Flush immediately, and then pixel in canvas can be fetched\n *                      immediately. Caution: it might affect performance.\n *                  false: Not not flush.\n *                  undefined: Auto decide whether perform flush.\n */\n\n\nechartsProto.dispatchAction = function (payload, opt) {\n  if (!zrUtil.isObject(opt)) {\n    opt = {\n      silent: !!opt\n    };\n  }\n\n  if (!actions[payload.type]) {\n    return;\n  } // Avoid dispatch action before setOption. Especially in `connect`.\n\n\n  if (!this._model) {\n    return;\n  } // May dispatchAction in rendering procedure\n\n\n  if (this[IN_MAIN_PROCESS]) {\n    this._pendingActions.push(payload);\n\n    return;\n  }\n\n  doDispatchAction.call(this, payload, opt.silent);\n\n  if (opt.flush) {\n    this._zr.flush(true);\n  } else if (opt.flush !== false && env.browser.weChat) {\n    // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n    // hang when sliding page (on touch event), which cause that zr does not\n    // refresh util user interaction finished, which is not expected.\n    // But `dispatchAction` may be called too frequently when pan on touch\n    // screen, which impacts performance if do not throttle them.\n    this._throttledZrFlush();\n  }\n\n  flushPendingActions.call(this, opt.silent);\n  triggerUpdatedEvent.call(this, opt.silent);\n};\n\nfunction doDispatchAction(payload, silent) {\n  var payloadType = payload.type;\n  var escapeConnect = payload.escapeConnect;\n  var actionWrap = actions[payloadType];\n  var actionInfo = actionWrap.actionInfo;\n  var cptType = (actionInfo.update || 'update').split(':');\n  var updateMethod = cptType.pop();\n  cptType = cptType[0] != null && parseClassType(cptType[0]);\n  this[IN_MAIN_PROCESS] = true;\n  var payloads = [payload];\n  var batched = false; // Batch action\n\n  if (payload.batch) {\n    batched = true;\n    payloads = zrUtil.map(payload.batch, function (item) {\n      item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n      item.batch = null;\n      return item;\n    });\n  }\n\n  var eventObjBatch = [];\n  var eventObj;\n  var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n  each(payloads, function (batchItem) {\n    // Action can specify the event by return it.\n    eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside\n\n    eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType\n\n    eventObj.type = actionInfo.event || eventObj.type;\n    eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.\n\n    if (isHighDown) {\n      // method, payload, mainType, subType\n      updateDirectly(this, updateMethod, batchItem, 'series');\n    } else if (cptType) {\n      updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n    }\n  }, this);\n\n  if (updateMethod !== 'none' && !isHighDown && !cptType) {\n    // Still dirty\n    if (this[OPTION_UPDATED]) {\n      // FIXME Pass payload ?\n      updateMethods.prepareAndUpdate.call(this, payload);\n      this[OPTION_UPDATED] = false;\n    } else {\n      updateMethods[updateMethod].call(this, payload);\n    }\n  } // Follow the rule of action batch\n\n\n  if (batched) {\n    eventObj = {\n      type: actionInfo.event || payloadType,\n      escapeConnect: escapeConnect,\n      batch: eventObjBatch\n    };\n  } else {\n    eventObj = eventObjBatch[0];\n  }\n\n  this[IN_MAIN_PROCESS] = false;\n  !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n}\n\nfunction flushPendingActions(silent) {\n  var pendingActions = this._pendingActions;\n\n  while (pendingActions.length) {\n    var payload = pendingActions.shift();\n    doDispatchAction.call(this, payload, silent);\n  }\n}\n\nfunction triggerUpdatedEvent(silent) {\n  !silent && this.trigger('updated');\n}\n/**\n * Register event\n * @method\n */\n\n\nechartsProto.on = createRegisterEventWithLowercaseName('on');\nechartsProto.off = createRegisterEventWithLowercaseName('off');\nechartsProto.one = createRegisterEventWithLowercaseName('one');\n/**\n * @param {string} methodName\n * @private\n */\n\nfunction invokeUpdateMethod(methodName, ecModel, payload) {\n  var api = this._api; // Update all components\n\n  each(this._componentsViews, function (component) {\n    var componentModel = component.__model;\n    component[methodName](componentModel, ecModel, api, payload);\n    updateZ(componentModel, component);\n  }, this); // Upate all charts\n\n  ecModel.eachSeries(function (seriesModel, idx) {\n    var chart = this._chartsMap[seriesModel.__viewId];\n    chart[methodName](seriesModel, ecModel, api, payload);\n    updateZ(seriesModel, chart);\n    updateProgressiveAndBlend(seriesModel, chart);\n  }, this); // If use hover layer\n\n  updateHoverLayerStatus(this._zr, ecModel); // Post render\n\n  each(postUpdateFuncs, function (func) {\n    func(ecModel, api);\n  });\n}\n/**\n * Prepare view instances of charts and components\n * @param  {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction prepareView(type, ecModel) {\n  var isComponent = type === 'component';\n  var viewList = isComponent ? this._componentsViews : this._chartsViews;\n  var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n  var zr = this._zr;\n\n  for (var i = 0; i < viewList.length; i++) {\n    viewList[i].__alive = false;\n  }\n\n  ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n    if (isComponent) {\n      if (componentType === 'series') {\n        return;\n      }\n    } else {\n      model = componentType;\n    } // Consider: id same and type changed.\n\n\n    var viewId = '_ec_' + model.id + '_' + model.type;\n    var view = viewMap[viewId];\n\n    if (!view) {\n      var classType = parseClassType(model.type);\n      var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\n      if (Clazz) {\n        view = new Clazz();\n        view.init(ecModel, this._api);\n        viewMap[viewId] = view;\n        viewList.push(view);\n        zr.add(view.group);\n      } else {\n        // Error\n        return;\n      }\n    }\n\n    model.__viewId = view.__id = viewId;\n    view.__alive = true;\n    view.__model = model;\n    view.group.__ecComponentInfo = {\n      mainType: model.mainType,\n      index: model.componentIndex\n    };\n  }, this);\n\n  for (var i = 0; i < viewList.length;) {\n    var view = viewList[i];\n\n    if (!view.__alive) {\n      zr.remove(view.group);\n      view.dispose(ecModel, this._api);\n      viewList.splice(i, 1);\n      delete viewMap[view.__id];\n      view.__id = view.group.__ecComponentInfo = null;\n    } else {\n      i++;\n    }\n  }\n}\n/**\n * Processor data in each series\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction processData(ecModel, api) {\n  each(dataProcessorFuncs, function (process) {\n    process.func(ecModel, api);\n  });\n}\n/**\n * @private\n */\n\n\nfunction stackSeriesData(ecModel) {\n  var stackedDataMap = {};\n  ecModel.eachSeries(function (series) {\n    var stack = series.get('stack');\n    var data = series.getData();\n\n    if (stack && data.type === 'list') {\n      var previousStack = stackedDataMap[stack]; // Avoid conflict with Object.prototype\n\n      if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n        data.stackedOn = previousStack;\n      }\n\n      stackedDataMap[stack] = data;\n    }\n  });\n}\n/**\n * Layout before each chart render there series, special visual encoding stage\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\n\n\nfunction doLayout(ecModel, payload) {\n  var api = this._api;\n  each(visualFuncs, function (visual) {\n    if (visual.isLayout) {\n      visual.func(ecModel, api, payload);\n    }\n  });\n}\n/**\n * Encode visual infomation from data after data processing\n *\n * @param {module:echarts/model/Global} ecModel\n * @param {object} layout\n * @param {boolean} [excludesLayout]\n * @private\n */\n\n\nfunction doVisualEncoding(ecModel, payload, excludesLayout) {\n  var api = this._api;\n  ecModel.clearColorPalette();\n  ecModel.eachSeries(function (seriesModel) {\n    seriesModel.clearColorPalette();\n  });\n  each(visualFuncs, function (visual) {\n    (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload);\n  });\n}\n/**\n * Render each chart and component\n * @private\n */\n\n\nfunction doRender(ecModel, payload) {\n  var api = this._api; // Render all components\n\n  each(this._componentsViews, function (componentView) {\n    var componentModel = componentView.__model;\n    componentView.render(componentModel, ecModel, api, payload);\n    updateZ(componentModel, componentView);\n  }, this);\n  each(this._chartsViews, function (chart) {\n    chart.__alive = false;\n  }, this); // Render all charts\n\n  ecModel.eachSeries(function (seriesModel, idx) {\n    var chartView = this._chartsMap[seriesModel.__viewId];\n    chartView.__alive = true;\n    chartView.render(seriesModel, ecModel, api, payload);\n    chartView.group.silent = !!seriesModel.get('silent');\n    updateZ(seriesModel, chartView);\n    updateProgressiveAndBlend(seriesModel, chartView);\n  }, this); // If use hover layer\n\n  updateHoverLayerStatus(this._zr, ecModel); // Remove groups of unrendered charts\n\n  each(this._chartsViews, function (chart) {\n    if (!chart.__alive) {\n      chart.remove(ecModel, api);\n    }\n  }, this);\n}\n\nvar MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];\n/**\n * @private\n */\n\nechartsProto._initEvents = function () {\n  each(MOUSE_EVENT_NAMES, function (eveName) {\n    this._zr.on(eveName, function (e) {\n      var ecModel = this.getModel();\n      var el = e.target;\n      var params; // no e.target when 'globalout'.\n\n      if (eveName === 'globalout') {\n        params = {};\n      } else if (el && el.dataIndex != null) {\n        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n        params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n      } // If element has custom eventData of components\n      else if (el && el.eventData) {\n          params = zrUtil.extend({}, el.eventData);\n        }\n\n      if (params) {\n        params.event = e;\n        params.type = eveName;\n        this.trigger(eveName, params);\n      }\n    }, this);\n  }, this);\n  each(eventActionMap, function (actionType, eventType) {\n    this._messageCenter.on(eventType, function (event) {\n      this.trigger(eventType, event);\n    }, this);\n  }, this);\n};\n/**\n * @return {boolean}\n */\n\n\nechartsProto.isDisposed = function () {\n  return this._disposed;\n};\n/**\n * Clear\n */\n\n\nechartsProto.clear = function () {\n  this.setOption({\n    series: []\n  }, true);\n};\n/**\n * Dispose instance\n */\n\n\nechartsProto.dispose = function () {\n  if (this._disposed) {\n    return;\n  }\n\n  this._disposed = true;\n  var api = this._api;\n  var ecModel = this._model;\n  each(this._componentsViews, function (component) {\n    component.dispose(ecModel, api);\n  });\n  each(this._chartsViews, function (chart) {\n    chart.dispose(ecModel, api);\n  }); // Dispose after all views disposed\n\n  this._zr.dispose();\n\n  delete instances[this.id];\n};\n\nzrUtil.mixin(ECharts, Eventful);\n\nfunction updateHoverLayerStatus(zr, ecModel) {\n  var storage = zr.storage;\n  var elCount = 0;\n  storage.traverse(function (el) {\n    if (!el.isGroup) {\n      elCount++;\n    }\n  });\n\n  if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n    storage.traverse(function (el) {\n      if (!el.isGroup) {\n        el.useHoverLayer = true;\n      }\n    });\n  }\n}\n/**\n * Update chart progressive and blend.\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\n\n\nfunction updateProgressiveAndBlend(seriesModel, chartView) {\n  // Progressive configuration\n  var elCount = 0;\n  chartView.group.traverse(function (el) {\n    if (el.type !== 'group' && !el.ignore) {\n      elCount++;\n    }\n  });\n  var frameDrawNum = +seriesModel.get('progressive');\n  var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\n  if (needProgressive) {\n    chartView.group.traverse(function (el) {\n      // FIXME marker and other components\n      if (!el.isGroup) {\n        el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;\n\n        if (needProgressive) {\n          el.stopAnimation(true);\n        }\n      }\n    });\n  } // Blend configration\n\n\n  var blendMode = seriesModel.get('blendMode') || null;\n  chartView.group.traverse(function (el) {\n    // FIXME marker and other components\n    if (!el.isGroup) {\n      el.setStyle('blend', blendMode);\n    }\n  });\n}\n/**\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\n\n\nfunction updateZ(model, view) {\n  var z = model.get('z');\n  var zlevel = model.get('zlevel'); // Set z and zlevel\n\n  view.group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n    }\n  });\n}\n\nfunction createExtensionAPI(ecInstance) {\n  var coordSysMgr = ecInstance._coordSysMgr;\n  return zrUtil.extend(new ExtensionAPI(ecInstance), {\n    // Inject methods\n    getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),\n    getComponentByElement: function (el) {\n      while (el) {\n        var modelInfo = el.__ecComponentInfo;\n\n        if (modelInfo != null) {\n          return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n        }\n\n        el = el.parent;\n      }\n    }\n  });\n}\n/**\n * @type {Object} key: actionType.\n * @inner\n */\n\n\nvar actions = {};\n/**\n * Map eventType to actionType\n * @type {Object}\n */\n\nvar eventActionMap = {};\n/**\n * Data processor functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\n\nvar dataProcessorFuncs = [];\n/**\n * @type {Array.<Function>}\n * @inner\n */\n\nvar optionPreprocessorFuncs = [];\n/**\n * @type {Array.<Function>}\n * @inner\n */\n\nvar postUpdateFuncs = [];\n/**\n * Visual encoding functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\n\nvar visualFuncs = [];\n/**\n * Theme storage\n * @type {Object.<key, Object>}\n */\n\nvar themeStorage = {};\n/**\n * Loading effects\n */\n\nvar loadingEffects = {};\nvar instances = {};\nvar connectedGroups = {};\nvar idBase = new Date() - 0;\nvar groupIdBase = new Date() - 0;\nvar DOM_ATTRIBUTE_KEY = '_echarts_instance_';\nvar mapDataStores = {};\n\nfunction enableConnect(chart) {\n  var STATUS_PENDING = 0;\n  var STATUS_UPDATING = 1;\n  var STATUS_UPDATED = 2;\n  var STATUS_KEY = '__connectUpdateStatus';\n\n  function updateConnectedChartsStatus(charts, status) {\n    for (var i = 0; i < charts.length; i++) {\n      var otherChart = charts[i];\n      otherChart[STATUS_KEY] = status;\n    }\n  }\n\n  zrUtil.each(eventActionMap, function (actionType, eventType) {\n    chart._messageCenter.on(eventType, function (event) {\n      if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n        if (event && event.escapeConnect) {\n          return;\n        }\n\n        var action = chart.makeActionFromEvent(event);\n        var otherCharts = [];\n        zrUtil.each(instances, function (otherChart) {\n          if (otherChart !== chart && otherChart.group === chart.group) {\n            otherCharts.push(otherChart);\n          }\n        });\n        updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n        each(otherCharts, function (otherChart) {\n          if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n            otherChart.dispatchAction(action);\n          }\n        });\n        updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n      }\n    });\n  });\n}\n/**\n * @param {HTMLElement} dom\n * @param {Object} [theme]\n * @param {Object} opts\n * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n *                              Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n *                               Can be 'auto' (the same as null/undefined)\n */\n\n\nfunction init(dom, theme, opts) {\n  var existInstance = getInstanceByDom(dom);\n\n  if (existInstance) {\n    return existInstance;\n  }\n\n  var chart = new ECharts(dom, theme, opts);\n  chart.id = 'ec_' + idBase++;\n  instances[chart.id] = chart;\n\n  if (dom.setAttribute) {\n    dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n  } else {\n    dom[DOM_ATTRIBUTE_KEY] = chart.id;\n  }\n\n  enableConnect(chart);\n  return chart;\n}\n/**\n * @return {string|Array.<module:echarts~ECharts>} groupId\n */\n\n\nfunction connect(groupId) {\n  // Is array of charts\n  if (zrUtil.isArray(groupId)) {\n    var charts = groupId;\n    groupId = null; // If any chart has group\n\n    zrUtil.each(charts, function (chart) {\n      if (chart.group != null) {\n        groupId = chart.group;\n      }\n    });\n    groupId = groupId || 'g_' + groupIdBase++;\n    zrUtil.each(charts, function (chart) {\n      chart.group = groupId;\n    });\n  }\n\n  connectedGroups[groupId] = true;\n  return groupId;\n}\n/**\n * @DEPRECATED\n * @return {string} groupId\n */\n\n\nfunction disConnect(groupId) {\n  connectedGroups[groupId] = false;\n}\n/**\n * @return {string} groupId\n */\n\n\nvar disconnect = disConnect;\n/**\n * Dispose a chart instance\n * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n */\n\nfunction dispose(chart) {\n  if (typeof chart === 'string') {\n    chart = instances[chart];\n  } else if (!(chart instanceof ECharts)) {\n    // Try to treat as dom\n    chart = getInstanceByDom(chart);\n  }\n\n  if (chart instanceof ECharts && !chart.isDisposed()) {\n    chart.dispose();\n  }\n}\n/**\n * @param  {HTMLElement} dom\n * @return {echarts~ECharts}\n */\n\n\nfunction getInstanceByDom(dom) {\n  var key;\n\n  if (dom.getAttribute) {\n    key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n  } else {\n    key = dom[DOM_ATTRIBUTE_KEY];\n  }\n\n  return instances[key];\n}\n/**\n * @param {string} key\n * @return {echarts~ECharts}\n */\n\n\nfunction getInstanceById(key) {\n  return instances[key];\n}\n/**\n * Register theme\n */\n\n\nfunction registerTheme(name, theme) {\n  themeStorage[name] = theme;\n}\n/**\n * Register option preprocessor\n * @param {Function} preprocessorFunc\n */\n\n\nfunction registerPreprocessor(preprocessorFunc) {\n  optionPreprocessorFuncs.push(preprocessorFunc);\n}\n/**\n * @param {number} [priority=1000]\n * @param {Function} processorFunc\n */\n\n\nfunction registerProcessor(priority, processorFunc) {\n  if (typeof priority === 'function') {\n    processorFunc = priority;\n    priority = PRIORITY_PROCESSOR_FILTER;\n  }\n\n  dataProcessorFuncs.push({\n    prio: priority,\n    func: processorFunc\n  });\n}\n/**\n * Register postUpdater\n * @param {Function} postUpdateFunc\n */\n\n\nfunction registerPostUpdate(postUpdateFunc) {\n  postUpdateFuncs.push(postUpdateFunc);\n}\n/**\n * Usage:\n * registerAction('someAction', 'someEvent', function () { ... });\n * registerAction('someAction', function () { ... });\n * registerAction(\n *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n *     function () { ... }\n * );\n *\n * @param {(string|Object)} actionInfo\n * @param {string} actionInfo.type\n * @param {string} [actionInfo.event]\n * @param {string} [actionInfo.update]\n * @param {string} [eventName]\n * @param {Function} action\n */\n\n\nfunction registerAction(actionInfo, eventName, action) {\n  if (typeof eventName === 'function') {\n    action = eventName;\n    eventName = '';\n  }\n\n  var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {\n    event: eventName\n  }][0]; // Event name is all lowercase\n\n  actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n  eventName = actionInfo.event; // Validate action type and event name.\n\n  zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n  if (!actions[actionType]) {\n    actions[actionType] = {\n      action: action,\n      actionInfo: actionInfo\n    };\n  }\n\n  eventActionMap[eventName] = actionType;\n}\n/**\n * @param {string} type\n * @param {*} CoordinateSystem\n */\n\n\nfunction registerCoordinateSystem(type, CoordinateSystem) {\n  CoordinateSystemManager.register(type, CoordinateSystem);\n}\n/**\n * Get dimensions of specified coordinate system.\n * @param {string} type\n * @return {Array.<string|Object>}\n */\n\n\nfunction getCoordinateSystemDimensions(type) {\n  var coordSysCreator = CoordinateSystemManager.get(type);\n\n  if (coordSysCreator) {\n    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();\n  }\n}\n/**\n * Layout is a special stage of visual encoding\n * Most visual encoding like color are common for different chart\n * But each chart has it's own layout algorithm\n *\n * @param {number} [priority=1000]\n * @param {Function} layoutFunc\n */\n\n\nfunction registerLayout(priority, layoutFunc) {\n  if (typeof priority === 'function') {\n    layoutFunc = priority;\n    priority = PRIORITY_VISUAL_LAYOUT;\n  }\n\n  visualFuncs.push({\n    prio: priority,\n    func: layoutFunc,\n    isLayout: true\n  });\n}\n/**\n * @param {number} [priority=3000]\n * @param {Function} visualFunc\n */\n\n\nfunction registerVisual(priority, visualFunc) {\n  if (typeof priority === 'function') {\n    visualFunc = priority;\n    priority = PRIORITY_VISUAL_CHART;\n  }\n\n  visualFuncs.push({\n    prio: priority,\n    func: visualFunc\n  });\n}\n/**\n * @param {string} name\n */\n\n\nfunction registerLoading(name, loadingFx) {\n  loadingEffects[name] = loadingFx;\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendComponentModel(opts\n/*, superClass*/\n) {\n  // var Clazz = ComponentModel;\n  // if (superClass) {\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n  // }\n  return ComponentModel.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendComponentView(opts\n/*, superClass*/\n) {\n  // var Clazz = ComponentView;\n  // if (superClass) {\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n  // }\n  return ComponentView.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendSeriesModel(opts\n/*, superClass*/\n) {\n  // var Clazz = SeriesModel;\n  // if (superClass) {\n  //     superClass = 'series.' + superClass.replace('series.', '');\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n  // }\n  return SeriesModel.extend(opts);\n}\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\n\n\nfunction extendChartView(opts\n/*, superClass*/\n) {\n  // var Clazz = ChartView;\n  // if (superClass) {\n  //     superClass = superClass.replace('series.', '');\n  //     var classType = parseClassType(superClass);\n  //     Clazz = ChartView.getClass(classType.main, true);\n  // }\n  return ChartView.extend(opts);\n}\n/**\n * ZRender need a canvas context to do measureText.\n * But in node environment canvas may be created by node-canvas.\n * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n *\n * Be careful of using it in the browser.\n *\n * @param {Function} creator\n * @example\n *     var Canvas = require('canvas');\n *     var echarts = require('echarts');\n *     echarts.setCanvasCreator(function () {\n *         // Small size is enough.\n *         return new Canvas(32, 32);\n *     });\n */\n\n\nfunction setCanvasCreator(creator) {\n  zrUtil.$override('createCanvas', creator);\n}\n/**\n * @param {string} mapName\n * @param {Object|string} geoJson\n * @param {Object} [specialAreas]\n *\n * @example\n *     $.get('USA.json', function (geoJson) {\n *         echarts.registerMap('USA', geoJson);\n *         // Or\n *         echarts.registerMap('USA', {\n *             geoJson: geoJson,\n *             specialAreas: {}\n *         })\n *     });\n */\n\n\nfunction registerMap(mapName, geoJson, specialAreas) {\n  if (geoJson.geoJson && !geoJson.features) {\n    specialAreas = geoJson.specialAreas;\n    geoJson = geoJson.geoJson;\n  }\n\n  if (typeof geoJson === 'string') {\n    geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();\n  }\n\n  mapDataStores[mapName] = {\n    geoJson: geoJson,\n    specialAreas: specialAreas\n  };\n}\n/**\n * @param {string} mapName\n * @return {Object}\n */\n\n\nfunction getMap(mapName) {\n  return mapDataStores[mapName];\n}\n\nregisterVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);\nregisterPreprocessor(backwardCompat);\nregisterLoading('default', loadingDefault); // Default actions\n\nregisterAction({\n  type: 'highlight',\n  event: 'highlight',\n  update: 'highlight'\n}, zrUtil.noop);\nregisterAction({\n  type: 'downplay',\n  event: 'downplay',\n  update: 'downplay'\n}, zrUtil.noop); // For backward compatibility, where the namespace `dataTool` will\n// be mounted on `echarts` is the extension `dataTool` is imported.\n\nvar dataTool = {};\nexports.version = version;\nexports.dependencies = dependencies;\nexports.PRIORITY = PRIORITY;\nexports.init = init;\nexports.connect = connect;\nexports.disConnect = disConnect;\nexports.disconnect = disconnect;\nexports.dispose = dispose;\nexports.getInstanceByDom = getInstanceByDom;\nexports.getInstanceById = getInstanceById;\nexports.registerTheme = registerTheme;\nexports.registerPreprocessor = registerPreprocessor;\nexports.registerProcessor = registerProcessor;\nexports.registerPostUpdate = registerPostUpdate;\nexports.registerAction = registerAction;\nexports.registerCoordinateSystem = registerCoordinateSystem;\nexports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;\nexports.registerLayout = registerLayout;\nexports.registerVisual = registerVisual;\nexports.registerLoading = registerLoading;\nexports.extendComponentModel = extendComponentModel;\nexports.extendComponentView = extendComponentView;\nexports.extendSeriesModel = extendSeriesModel;\nexports.extendChartView = extendChartView;\nexports.setCanvasCreator = setCanvasCreator;\nexports.registerMap = registerMap;\nexports.getMap = getMap;\nexports.dataTool = dataTool;\nvar ___ec_export = require(\"./export\");\n(function () {\n    for (var key in ___ec_export) {\n        if (___ec_export.hasOwnProperty(key)) {\n            exports[key] = ___ec_export[key];\n        }\n    }\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/echarts.js\n// module id = 809\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar RADIAN_EPSILON = 1e-4;\n\nfunction _trim(str) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n/**\n * Linear mapping a value from domain to range\n * @memberOf module:echarts/util/number\n * @param  {(number|Array.<number>)} val\n * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n * @param  {boolean} clamp\n * @return {(number|Array.<number>}\n */\n\n\nfunction linearMap(val, domain, range, clamp) {\n  var subDomain = domain[1] - domain[0];\n  var subRange = range[1] - range[0];\n\n  if (subDomain === 0) {\n    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n  } // Avoid accuracy problem in edge, such as\n  // 146.39 - 62.83 === 83.55999999999999.\n  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n  // It is a little verbose for efficiency considering this method\n  // is a hotspot.\n\n\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= domain[0]) {\n        return range[0];\n      } else if (val >= domain[1]) {\n        return range[1];\n      }\n    } else {\n      if (val >= domain[0]) {\n        return range[0];\n      } else if (val <= domain[1]) {\n        return range[1];\n      }\n    }\n  } else {\n    if (val === domain[0]) {\n      return range[0];\n    }\n\n    if (val === domain[1]) {\n      return range[1];\n    }\n  }\n\n  return (val - domain[0]) / subDomain * subRange + range[0];\n}\n/**\n * Convert a percent string to absolute number.\n * Returns NaN if percent is not a valid string or number\n * @memberOf module:echarts/util/number\n * @param {string|number} percent\n * @param {number} all\n * @return {number}\n */\n\n\nfunction parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n\n  if (typeof percent === 'string') {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n\n    return parseFloat(percent);\n  }\n\n  return percent == null ? NaN : +percent;\n}\n/**\n * (1) Fix rounding error of float numbers.\n * (2) Support return string to avoid scientific notation like '3.5e-7'.\n *\n * @param {number} x\n * @param {number} [precision]\n * @param {boolean} [returnStr]\n * @return {number|string}\n */\n\n\nfunction round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  } // Avoid range error\n\n\n  precision = Math.min(Math.max(0, precision), 20);\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\n\nfunction asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\n/**\n * Get precision\n * @param {number} val\n */\n\n\nfunction getPrecision(val) {\n  val = +val;\n\n  if (isNaN(val)) {\n    return 0;\n  } // It is much faster than methods converting number to string as follows\n  //      var tmp = val.toString();\n  //      return tmp.length - 1 - tmp.indexOf('.');\n  // especially when precision is low\n\n\n  var e = 1;\n  var count = 0;\n\n  while (Math.round(val * e) / e !== val) {\n    e *= 10;\n    count++;\n  }\n\n  return count;\n}\n/**\n * @param {string|number} val\n * @return {number}\n */\n\n\nfunction getPrecisionSafe(val) {\n  var str = val.toString(); // Consider scientific notation: '3.4e-12' '3.4e+12'\n\n  var eIndex = str.indexOf('e');\n\n  if (eIndex > 0) {\n    var precision = +str.slice(eIndex + 1);\n    return precision < 0 ? -precision : 0;\n  } else {\n    var dotIndex = str.indexOf('.');\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n  }\n}\n/**\n * Minimal dicernible data precisioin according to a single pixel.\n *\n * @param {Array.<number>} dataExtent\n * @param {Array.<number>} pixelExtent\n * @return {number} precision\n */\n\n\nfunction getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.\n\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\n/**\n * Get a data of given precision, assuring the sum of percentages\n * in valueList is 1.\n * The largest remainer method is used.\n * https://en.wikipedia.org/wiki/Largest_remainder_method\n *\n * @param {Array.<number>} valueList a list of all data\n * @param {number} idx index of the data to be processed in valueList\n * @param {number} precision integer number showing digits of precision\n * @return {number} percent ranging from 0 to 100\n */\n\n\nfunction getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n\n  var sum = zrUtil.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n\n  if (sum === 0) {\n    return 0;\n  }\n\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrUtil.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrUtil.map(votesPerQuota, function (votes) {\n    // Assign automatic seats.\n    return Math.floor(votes);\n  });\n  var currentSum = zrUtil.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  }); // Has remainding votes.\n\n  while (currentSum < targetSeats) {\n    // Find next largest remainder.\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    } // Add a vote to max remainder.\n\n\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n\n  return seats[idx] / digits;\n} // Number.MAX_SAFE_INTEGER, ie do not support.\n\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * To 0 - 2 * PI, considering negative radian.\n * @param {number} radian\n * @return {number}\n */\n\nfunction remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\n/**\n * @param {type} radian\n * @return {boolean}\n */\n\n\nfunction isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n/**\n * @param {string|Date|number} value These values can be accepted:\n *   + An instance of Date, represent a time in its own time zone.\n *   + Or string in a subset of ISO 8601, only including:\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n *     all of which will be treated as local time if time zone is not specified\n *     (see <https://momentjs.com/>).\n *   + Or other string format, including (all of which will be treated as loacal time):\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n *   + a timestamp, which represent a time in UTC.\n * @return {Date} date\n */\n\nfunction parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (typeof value === 'string') {\n    // Different browsers parse date in different way, so we parse it manually.\n    // Some other issues:\n    // new Date('1970-01-01') is UTC,\n    // new Date('1970/01/01') and new Date('1970-1-01') is local.\n    // See issue #3623\n    var match = TIME_REG.exec(value);\n\n    if (!match) {\n      // return Invalid Date.\n      return new Date(NaN);\n    } // Use local time when no timezone offset specifed.\n\n\n    if (!match[8]) {\n      // match[n] can only be string or undefined.\n      // But take care of '12' + 1 => '121'.\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n    // For example, system timezone is set as \"Time Zone: America/Toronto\",\n    // then these code will get different result:\n    // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n    // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n    // So we should not use `new Date`, but use `Date.UTC`.\n    else {\n        var hour = +match[4] || 0;\n\n        if (match[8].toUpperCase() !== 'Z') {\n          hour -= match[8].slice(0, 3);\n        }\n\n        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n      }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n\n  return new Date(Math.round(value));\n}\n/**\n * Quantity of a number. e.g. 0.1, 1, 10, 100\n *\n * @param  {number} val\n * @return {number}\n */\n\n\nfunction quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\n\nfunction quantityExponent(val) {\n  return Math.floor(Math.log(val) / Math.LN10);\n}\n/**\n * find a nice number approximately equal to x. Round the number if round = true,\n * take ceiling if round = false. The primary observation is that the nicest\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n *\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n *\n * @param  {number} val Non-negative value.\n * @param  {boolean} round\n * @return {number}\n */\n\n\nfunction nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10; // 1 <= f < 10\n\n  var nf;\n\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n\n  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n  // 20 is the uppper bound of toFixed.\n\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n/**\n * Order intervals asc, and split them when overlap.\n * expect(numberUtil.reformIntervals([\n *     {interval: [18, 62], close: [1, 1]},\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [1, 1]},\n *     {interval: [62, 150], close: [1, 1]},\n *     {interval: [106, 150], close: [1, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ])).toEqual([\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [0, 1]},\n *     {interval: [18, 62], close: [0, 1]},\n *     {interval: [62, 150], close: [0, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ]);\n * @param {Array.<Object>} list, where `close` mean open or close\n *        of the interval, and Infinity can be used.\n * @return {Array.<Object>} The origin list, which has been reformed.\n */\n\n\nfunction reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close = list[i].close;\n\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close[lg] = !lg ? 1 - currClose : 1;\n      }\n\n      curr = interval[lg];\n      currClose = close[lg];\n    }\n\n    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  return list;\n\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\n/**\n * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n * subtraction forces infinities to NaN\n *\n * @param {*} v\n * @return {boolean}\n */\n\n\nfunction isNumeric(v) {\n  return v - parseFloat(v) >= 0;\n}\n\nexports.linearMap = linearMap;\nexports.parsePercent = parsePercent;\nexports.round = round;\nexports.asc = asc;\nexports.getPrecision = getPrecision;\nexports.getPrecisionSafe = getPrecisionSafe;\nexports.getPixelPrecision = getPixelPrecision;\nexports.getPercentWithPrecision = getPercentWithPrecision;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nexports.remRadian = remRadian;\nexports.isRadianAroundZero = isRadianAroundZero;\nexports.parseDate = parseDate;\nexports.quantity = quantity;\nexports.nice = nice;\nexports.reformIntervals = reformIntervals;\nexports.isNumeric = isNumeric;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/number.js\n// module id = 810\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"./format\");\n\nvar nubmerUtil = require(\"./number\");\n\nvar Model = require(\"../model/Model\");\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nfunction normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *         normal: {\n *             show: false,\n *             position: 'outside',\n *             fontSize: 18\n *         },\n *         emphasis: {\n *             show: true\n *         }\n *     }\n * @param {Object} opt\n * @param {Array.<string>} subOpts\n */\n\n\nfunction defaultEmphasis(opt, subOpts) {\n  if (opt) {\n    var emphasisOpt = opt.emphasis = opt.emphasis || {};\n    var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {\n        emphasisOpt[subOptName] = normalOpt[subOptName];\n      }\n    }\n  }\n}\n\nvar TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n * @param {string|number|Date|Array|Object} dataItem\n * @return {number|string|Date|Array.<number|string|Date>}\n */\n\nfunction getDataItemValue(dataItem) {\n  // Performance sensitive.\n  return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n * @param {string|number|Date|Array|Object} dataItem\n */\n\n\nfunction isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n/**\n * This helper method convert value in data.\n * @param {string|number|Date} value\n * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n */\n\n\nfunction converDataValue(value, dimInfo) {\n  // Performance sensitive.\n  var dimType = dimInfo && dimInfo.type;\n\n  if (dimType === 'ordinal') {\n    return value;\n  }\n\n  if (dimType === 'time' // spead up when using timestamp\n  && typeof value !== 'number' && value != null && value !== '-') {\n    value = +nubmerUtil.parseDate(value);\n  } // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n\n\n  return value == null || value === '' ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n}\n/**\n * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n * @param {module:echarts/data/List} data\n * @param {Object} opt\n * @param {string} [opt.seriesIndex]\n * @param {Object} [opt.name]\n * @param {Object} [opt.mainType]\n * @param {Object} [opt.subType]\n */\n\n\nfunction createDataFormatModel(data, opt) {\n  var model = new Model();\n  zrUtil.mixin(model, dataFormatMixin);\n  model.seriesIndex = opt.seriesIndex;\n  model.name = opt.name || '';\n  model.mainType = opt.mainType;\n  model.subType = opt.subType;\n\n  model.getData = function () {\n    return data;\n  };\n\n  return model;\n} // PENDING A little ugly\n\n\nvar dataFormatMixin = {\n  /**\n   * Get params for formatter\n   * @param {number} dataIndex\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getDataParams: function (dataIndex, dataType) {\n    var data = this.getData(dataType);\n    var rawValue = this.getRawValue(dataIndex, dataType);\n    var rawDataIndex = data.getRawIndex(dataIndex);\n    var name = data.getName(dataIndex, true);\n    var itemOpt = data.getRawDataItem(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n    return {\n      componentType: this.mainType,\n      componentSubType: this.subType,\n      seriesType: this.mainType === 'series' ? this.subType : null,\n      seriesIndex: this.seriesIndex,\n      seriesId: this.id,\n      seriesName: this.name,\n      name: name,\n      dataIndex: rawDataIndex,\n      data: itemOpt,\n      dataType: dataType,\n      value: rawValue,\n      color: color,\n      marker: formatUtil.getTooltipMarker(color),\n      // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n      $vars: ['seriesName', 'name', 'value']\n    };\n  },\n\n  /**\n   * Format label\n   * @param {number} dataIndex\n   * @param {string} [status='normal'] 'normal' or 'emphasis'\n   * @param {string} [dataType]\n   * @param {number} [dimIndex]\n   * @param {string} [labelProp='label']\n   * @return {string}\n   */\n  getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n    status = status || 'normal';\n    var data = this.getData(dataType);\n    var itemModel = data.getItemModel(dataIndex);\n    var params = this.getDataParams(dataIndex, dataType);\n\n    if (dimIndex != null && params.value instanceof Array) {\n      params.value = params.value[dimIndex];\n    }\n\n    var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n    if (typeof formatter === 'function') {\n      params.status = status;\n      return formatter(params);\n    } else if (typeof formatter === 'string') {\n      return formatUtil.formatTpl(formatter, params);\n    }\n  },\n\n  /**\n   * Get raw value in option\n   * @param {number} idx\n   * @param {string} [dataType]\n   * @return {Object}\n   */\n  getRawValue: function (idx, dataType) {\n    var data = this.getData(dataType);\n    var dataItem = data.getRawDataItem(idx);\n\n    if (dataItem != null) {\n      return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;\n    }\n  },\n\n  /**\n   * Should be implemented.\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   * @return {string} tooltip string\n   */\n  formatTooltip: zrUtil.noop\n};\n/**\n * Mapping to exists for merge.\n *\n * @public\n * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n * @param {Object|Array.<Object>} newCptOptions\n * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          index of which is the same as exists.\n */\n\nfunction mappingToExists(exists, newCptOptions) {\n  // Mapping by the order by original option (but not order of\n  // new option) in merge mode. Because we should ensure\n  // some specified index (like xAxisIndex) is consistent with\n  // original option, which is easy to understand, espatially in\n  // media query. And in most case, merge option is used to\n  // update partial option but not be expected to change order.\n  newCptOptions = (newCptOptions || []).slice();\n  var result = zrUtil.map(exists || [], function (obj, index) {\n    return {\n      exist: obj\n    };\n  }); // Mapping by id or name if specified.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    } // id has highest priority.\n\n\n    for (var i = 0; i < result.length; i++) {\n      if (!result[i].option // Consider name: two map to one.\n      && cptOption.id != null && result[i].exist.id === cptOption.id + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Consider name: two map to one.\n      // Can not match when both ids exist but different.\n      && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {\n        result[i].option = cptOption;\n        newCptOptions[index] = null;\n        return;\n      }\n    }\n  }); // Otherwise mapping by index.\n\n  each(newCptOptions, function (cptOption, index) {\n    if (!isObject(cptOption)) {\n      return;\n    }\n\n    var i = 0;\n\n    for (; i < result.length; i++) {\n      var exist = result[i].exist;\n\n      if (!result[i].option // Existing model that already has id should be able to\n      // mapped to (because after mapping performed model may\n      // be assigned with a id, whish should not affect next\n      // mapping), except those has inner id.\n      && !isIdInner(exist) // Caution:\n      // Do not overwrite id. But name can be overwritten,\n      // because axis use name as 'show label text'.\n      // 'exist' always has id and name and we dont\n      // need to check it.\n      && cptOption.id == null) {\n        result[i].option = cptOption;\n        break;\n      }\n    }\n\n    if (i >= result.length) {\n      result.push({\n        option: cptOption\n      });\n    }\n  });\n  return result;\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n *\n * @public\n * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          which order is the same as exists.\n * @return {Array.<Object>} The input.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = zrUtil.createHashMap();\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    existCpt && idMap.set(existCpt.id, item);\n  });\n  each(mapResult, function (item, index) {\n    var opt = item.option;\n    zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existCpt = item.exist;\n    var opt = item.option;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\\0-'; // name may be displayed on screen, so use '-'.\n\n    if (existCpt) {\n      keyInfo.id = existCpt.id;\n    } else if (opt.id != null) {\n      keyInfo.id = opt.id + '';\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n/**\n * @public\n * @param {Object} cptOption\n * @return {boolean}\n */\n\n\nfunction isIdInner(cptOption) {\n  return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n */\n\n\nfunction compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = sourceBatch[i].seriesId;\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param {module:echarts/data/List} data\n * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n */\n\n\nfunction queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * var get = modelUitl.makeGetter();\n *\n * function some(hostObj) {\n *      get(hostObj)._someProperty = 1212;\n *      ...\n * }\n *\n * @return {Function}\n */\n\n\nvar makeGetter = function () {\n  var index = 0;\n  return function () {\n    var key = '\\0__ec_prop_getter_' + index++;\n    return function (hostObj) {\n      return hostObj[key] || (hostObj[key] = {});\n    };\n  };\n}();\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex, seriesId, seriesName,\n *            geoIndex, geoId, geoName,\n *            bmapIndex, bmapId, bmapName,\n *            xAxisIndex, xAxisId, xAxisName,\n *            yAxisIndex, yAxisId, yAxisName,\n *            gridIndex, gridId, gridName,\n *            ... (can be extended)\n *        }\n *        Each properties can be number|string|Array.<number>|Array.<string>\n *        For example, a finder could be\n *        {\n *            seriesIndex: 3,\n *            geoId: ['aa', 'cc'],\n *            gridName: ['xx', 'rr']\n *        }\n *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n *        If nothing or null/undefined specified, return nothing.\n * @param {Object} [opt]\n * @param {string} [opt.defaultMainType]\n * @param {Array.<string>} [opt.includeMainTypes]\n * @return {Object} result like:\n *        {\n *            seriesModels: [seriesModel1, seriesModel2],\n *            seriesModel: seriesModel1, // The first model\n *            geoModels: [geoModel1, geoModel2],\n *            geoModel: geoModel1, // The first model\n *            ...\n *        }\n */\n\n\nfunction parseFinder(ecModel, finder, opt) {\n  if (zrUtil.isString(finder)) {\n    var obj = {};\n    obj[finder + 'Index'] = 0;\n    finder = obj;\n  }\n\n  var defaultMainType = opt && opt.defaultMainType;\n\n  if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {\n    finder[defaultMainType + 'Index'] = 0;\n  }\n\n  var result = {};\n  each(finder, function (value, key) {\n    var value = finder[key]; // Exclude 'dataIndex' and other illgal keys.\n\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      result[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    var queryParam = {\n      mainType: mainType\n    };\n\n    if (queryType !== 'index' || value !== 'all') {\n      queryParam[queryType] = value;\n    }\n\n    var models = ecModel.queryComponents(queryParam);\n    result[mainType + 'Models'] = models;\n    result[mainType + 'Model'] = models[0];\n  });\n  return result;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string|number} dataDim\n * @return {string}\n */\n\n\nfunction dataDimToCoordDim(data, dataDim) {\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} coordDim\n * @return {Array.<string>} data dimensions on the coordDim.\n */\n\n\nfunction coordDimToDataDim(data, coordDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n\n    if (dimItem.coordDim === coordDim) {\n      dataDim[dimItem.coordDimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} otherDim Can be `otherDims`\n *                        like 'label' or 'tooltip'.\n * @return {Array.<string>} data dimensions on the otherDim.\n */\n\n\nfunction otherDimToDataDim(data, otherDim) {\n  var dataDim = [];\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var otherDims = dimItem.otherDims;\n    var dimIndex = otherDims[otherDim];\n\n    if (dimIndex != null && dimIndex !== false) {\n      dataDim[dimIndex] = dimItem.name;\n    }\n  });\n  return dataDim;\n}\n\nfunction has(obj, prop) {\n  return obj && obj.hasOwnProperty(prop);\n}\n\nexports.normalizeToArray = normalizeToArray;\nexports.defaultEmphasis = defaultEmphasis;\nexports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;\nexports.getDataItemValue = getDataItemValue;\nexports.isDataItemOption = isDataItemOption;\nexports.converDataValue = converDataValue;\nexports.createDataFormatModel = createDataFormatModel;\nexports.dataFormatMixin = dataFormatMixin;\nexports.mappingToExists = mappingToExists;\nexports.makeIdAndName = makeIdAndName;\nexports.isIdInner = isIdInner;\nexports.compressBatches = compressBatches;\nexports.queryDataIndex = queryDataIndex;\nexports.makeGetter = makeGetter;\nexports.parseFinder = parseFinder;\nexports.dataDimToCoordDim = dataDimToCoordDim;\nexports.coordDimToDataDim = coordDimToDataDim;\nexports.otherDimToDataDim = otherDimToDataDim;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/model.js\n// module id = 811\n// module chunks = 1 2 3 141 142 143 144 145","var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * \n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} \n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 812\n// module chunks = 1 2 3 141 142 143 144 145","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1]); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    hasFill && path.fill(ctx);\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    hasStroke && path.stroke(ctx);\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n *  Path element, \n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME  extend position, rotation \n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 813\n// module chunks = 1 2 3 141 142 143 144 145","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // canvas\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    && (browser.edge || browser.ie && browser.version >= 11)\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 819\n// module chunks = 1 2 3 141 142 143 144 145","// (1) The code `if (__DEV__) ...` can be removed by build tool.\n// (2) If intend to use `__DEV__`, this module should be imported. Use a global\n// variable `__DEV__` may cause that miss the declaration (see #6535), or the\n// declaration is behind of the using position (for example in `Model.extent`,\n// And tools like rollup can not analysis the dependency if not import).\nvar dev; // In browser\n\nif (typeof window !== 'undefined') {\n  dev = window.__DEV__;\n} // In node\nelse if (typeof global !== 'undefined') {\n    dev = global.__DEV__;\n  }\n\nif (typeof dev === 'undefined') {\n  dev = true;\n}\n\nvar __DEV__ = dev;\nexports.__DEV__ = __DEV__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/config.js\n// module id = 820\n// module chunks = 1 2 3 141 142 143 144 145","var vec2 = require(\"./vector\");\n\nvar matrix = require(\"./matrix\");\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // \n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 821\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar numberUtil = require(\"./number\");\n\n/**\n * ,\n * @param {string|number} x\n * @return {string}\n */\nfunction addCommas(x) {\n  if (isNaN(x)) {\n    return '-';\n  }\n\n  x = (x + '').split('.');\n  return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');\n}\n/**\n * @param {string} str\n * @param {boolean} [upperCaseFirst=false]\n * @return {string} str\n */\n\n\nfunction toCamelCase(str, upperCaseFirst) {\n  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\n    return group1.toUpperCase();\n  });\n\n  if (upperCaseFirst && str) {\n    str = str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  return str;\n}\n\nvar normalizeCssArray = zrUtil.normalizeCssArray;\n\nfunction encodeHTML(source) {\n  return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n}\n\nvar TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\nvar wrapVar = function (varName, seriesIdx) {\n  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n};\n/**\n * Template formatter\n * @param {string} tpl\n * @param {Array.<Object>|Object} paramsList\n * @param {boolean} [encode=false]\n * @return {string}\n */\n\n\nfunction formatTpl(tpl, paramsList, encode) {\n  if (!zrUtil.isArray(paramsList)) {\n    paramsList = [paramsList];\n  }\n\n  var seriesLen = paramsList.length;\n\n  if (!seriesLen) {\n    return '';\n  }\n\n  var $vars = paramsList[0].$vars || [];\n\n  for (var i = 0; i < $vars.length; i++) {\n    var alias = TPL_VAR_ALIAS[i];\n    var val = wrapVar(alias, 0);\n    tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n  }\n\n  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n    for (var k = 0; k < $vars.length; k++) {\n      var val = paramsList[seriesIdx][$vars[k]];\n      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);\n    }\n  }\n\n  return tpl;\n}\n/**\n * simple Template formatter\n *\n * @param {string} tpl\n * @param {Object} param\n * @param {boolean} [encode=false]\n * @return {string}\n */\n\n\nfunction formatTplSimple(tpl, param, encode) {\n  zrUtil.each(param, function (value, key) {\n    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);\n  });\n  return tpl;\n}\n/**\n * @param {string} color\n * @param {string} [extraCssText]\n * @return {string}\n */\n\n\nfunction getTooltipMarker(color, extraCssText) {\n  return color ? '<span style=\"display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>' : '';\n}\n/**\n * @param {string} str\n * @return {string}\n * @inner\n */\n\n\nvar s2d = function (str) {\n  return str < 10 ? '0' + str : str;\n};\n/**\n * ISO Date format\n * @param {string} tpl\n * @param {number} value\n * @param {boolean} [isUTC=false] Default in local time.\n *           see `module:echarts/scale/Time`\n *           and `module:echarts/util/number#parseDate`.\n * @inner\n */\n\n\nfunction formatTime(tpl, value, isUTC) {\n  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n    tpl = 'MM-dd\\nyyyy';\n  }\n\n  var date = numberUtil.parseDate(value);\n  var utc = isUTC ? 'UTC' : '';\n  var y = date['get' + utc + 'FullYear']();\n  var M = date['get' + utc + 'Month']() + 1;\n  var d = date['get' + utc + 'Date']();\n  var h = date['get' + utc + 'Hours']();\n  var m = date['get' + utc + 'Minutes']();\n  var s = date['get' + utc + 'Seconds']();\n  tpl = tpl.replace('MM', s2d(M)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);\n  return tpl;\n}\n/**\n * Capital first\n * @param {string} str\n * @return {string}\n */\n\n\nfunction capitalFirst(str) {\n  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n}\n\nvar truncateText = textContain.truncateText;\nvar getTextRect = textContain.getBoundingRect;\nexports.addCommas = addCommas;\nexports.toCamelCase = toCamelCase;\nexports.normalizeCssArray = normalizeCssArray;\nexports.encodeHTML = encodeHTML;\nexports.formatTpl = formatTpl;\nexports.formatTplSimple = formatTplSimple;\nexports.getTooltipMarker = getTooltipMarker;\nexports.formatTime = formatTime;\nexports.capitalFirst = capitalFirst;\nexports.truncateText = truncateText;\nexports.getTextRect = getTextRect;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/format.js\n// module id = 822\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar clazzUtil = require(\"../util/clazz\");\n\nvar lineStyleMixin = require(\"./mixin/lineStyle\");\n\nvar areaStyleMixin = require(\"./mixin/areaStyle\");\n\nvar textStyleMixin = require(\"./mixin/textStyle\");\n\nvar itemStyleMixin = require(\"./mixin/itemStyle\");\n\n/**\n * @module echarts/model/Model\n */\nvar mixin = zrUtil.mixin;\n/**\n * @alias module:echarts/model/Model\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} [parentModel]\n * @param {module:echarts/model/Global} [ecModel]\n */\n\nfunction Model(option, parentModel, ecModel) {\n  /**\n   * @type {module:echarts/model/Model}\n   * @readOnly\n   */\n  this.parentModel = parentModel;\n  /**\n   * @type {module:echarts/model/Global}\n   * @readOnly\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @type {Object}\n   * @protected\n   */\n\n  this.option = option; // Simple optimization\n  // if (this.init) {\n  //     if (arguments.length <= 4) {\n  //         this.init(option, parentModel, ecModel, extraOpt);\n  //     }\n  //     else {\n  //         this.init.apply(this, arguments);\n  //     }\n  // }\n}\n\nModel.prototype = {\n  constructor: Model,\n\n  /**\n   * Model \n   * @param {Object} option\n   */\n  init: null,\n\n  /**\n   *  Option merge\n   */\n  mergeOption: function (option) {\n    zrUtil.merge(this.option, option, true);\n  },\n\n  /**\n   * @param {string|Array.<string>} path\n   * @param {boolean} [ignoreParent=false]\n   * @return {*}\n   */\n  get: function (path, ignoreParent) {\n    if (path == null) {\n      return this.option;\n    }\n\n    return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));\n  },\n\n  /**\n   * @param {string} key\n   * @param {boolean} [ignoreParent=false]\n   * @return {*}\n   */\n  getShallow: function (key, ignoreParent) {\n    var option = this.option;\n    var val = option == null ? option : option[key];\n    var parentModel = !ignoreParent && getParent(this, key);\n\n    if (val == null && parentModel) {\n      val = parentModel.getShallow(key);\n    }\n\n    return val;\n  },\n\n  /**\n   * @param {string|Array.<string>} [path]\n   * @param {module:echarts/model/Model} [parentModel]\n   * @return {module:echarts/model/Model}\n   */\n  getModel: function (path, parentModel) {\n    var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));\n    var thisParentModel;\n    parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);\n    return new Model(obj, parentModel, this.ecModel);\n  },\n\n  /**\n   * If model has option\n   */\n  isEmpty: function () {\n    return this.option == null;\n  },\n  restoreData: function () {},\n  // Pending\n  clone: function () {\n    var Ctor = this.constructor;\n    return new Ctor(zrUtil.clone(this.option));\n  },\n  setReadOnly: function (properties) {\n    clazzUtil.setReadOnly(this, properties);\n  },\n  // If path is null/undefined, return null/undefined.\n  parsePath: function (path) {\n    if (typeof path === 'string') {\n      path = path.split('.');\n    }\n\n    return path;\n  },\n\n  /**\n   * @param {Function} getParentMethod\n   *        param {Array.<string>|string} path\n   *        return {module:echarts/model/Model}\n   */\n  customizeGetParent: function (getParentMethod) {\n    clazzUtil.set(this, 'getParent', getParentMethod);\n  },\n  isAnimationEnabled: function () {\n    if (!env.node) {\n      if (this.option.animation != null) {\n        return !!this.option.animation;\n      } else if (this.parentModel) {\n        return this.parentModel.isAnimationEnabled();\n      }\n    }\n  }\n};\n\nfunction doGet(obj, pathArr, parentModel) {\n  for (var i = 0; i < pathArr.length; i++) {\n    // Ignore empty\n    if (!pathArr[i]) {\n      continue;\n    } // obj could be number/string/... (like 0)\n\n\n    obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;\n\n    if (obj == null) {\n      break;\n    }\n  }\n\n  if (obj == null && parentModel) {\n    obj = parentModel.get(pathArr);\n  }\n\n  return obj;\n} // `path` can be null/undefined\n\n\nfunction getParent(model, path) {\n  var getParentMethod = clazzUtil.get(model, 'getParent');\n  return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n} // Enable Model.extend.\n\n\nclazzUtil.enableClassExtend(Model);\nmixin(Model, lineStyleMixin);\nmixin(Model, areaStyleMixin);\nmixin(Model, textStyleMixin);\nmixin(Model, itemStyleMixin);\nvar _default = Model;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Model.js\n// module id = 823\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar TYPE_DELIMITER = '.';\nvar IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\nvar MEMBER_PRIFIX = '\\0ec_\\0';\n/**\n * Hide private class member.\n * The same behavior as `host[name] = value;` (can be right-value)\n * @public\n */\n\nfunction set(host, name, value) {\n  return host[MEMBER_PRIFIX + name] = value;\n}\n/**\n * Hide private class member.\n * The same behavior as `host[name];`\n * @public\n */\n\n\nfunction get(host, name) {\n  return host[MEMBER_PRIFIX + name];\n}\n/**\n * For hidden private class member.\n * The same behavior as `host.hasOwnProperty(name);`\n * @public\n */\n\n\nfunction hasOwn(host, name) {\n  return host.hasOwnProperty(MEMBER_PRIFIX + name);\n}\n/**\n * Notice, parseClassType('') should returns {main: '', sub: ''}\n * @public\n */\n\n\nfunction parseClassType(componentType) {\n  var ret = {\n    main: '',\n    sub: ''\n  };\n\n  if (componentType) {\n    componentType = componentType.split(TYPE_DELIMITER);\n    ret.main = componentType[0] || '';\n    ret.sub = componentType[1] || '';\n  }\n\n  return ret;\n}\n/**\n * @public\n */\n\n\nfunction checkClassType(componentType) {\n  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType \"' + componentType + '\" illegal');\n}\n/**\n * @public\n */\n\n\nfunction enableClassExtend(RootClass, mandatoryMethods) {\n  RootClass.$constructor = RootClass;\n\n  RootClass.extend = function (proto) {\n    var superClass = this;\n\n    var ExtendedClass = function () {\n      if (!proto.$constructor) {\n        superClass.apply(this, arguments);\n      } else {\n        proto.$constructor.apply(this, arguments);\n      }\n    };\n\n    zrUtil.extend(ExtendedClass.prototype, proto);\n    ExtendedClass.extend = this.extend;\n    ExtendedClass.superCall = superCall;\n    ExtendedClass.superApply = superApply;\n    zrUtil.inherits(ExtendedClass, this);\n    ExtendedClass.superClass = superClass;\n    return ExtendedClass;\n  };\n} // superCall should have class info, which can not be fetch from 'this'.\n// Consider this case:\n// class A has method f,\n// class B inherits class A, overrides method f, f call superApply('f'),\n// class C inherits class B, do not overrides method f,\n// then when method of class C is called, dead loop occured.\n\n\nfunction superCall(context, methodName) {\n  var args = zrUtil.slice(arguments, 2);\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n\nfunction superApply(context, methodName, args) {\n  return this.superClass.prototype[methodName].apply(context, args);\n}\n/**\n * @param {Object} entity\n * @param {Object} options\n * @param {boolean} [options.registerWhenExtend]\n * @public\n */\n\n\nfunction enableClassManagement(entity, options) {\n  options = options || {};\n  /**\n   * Component model classes\n   * key: componentType,\n   * value:\n   *     componentClass, when componentType is 'xxx'\n   *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n   * @type {Object}\n   */\n\n  var storage = {};\n\n  entity.registerClass = function (Clazz, componentType) {\n    if (componentType) {\n      checkClassType(componentType);\n      componentType = parseClassType(componentType);\n\n      if (!componentType.sub) {\n        storage[componentType.main] = Clazz;\n      } else if (componentType.sub !== IS_CONTAINER) {\n        var container = makeContainer(componentType);\n        container[componentType.sub] = Clazz;\n      }\n    }\n\n    return Clazz;\n  };\n\n  entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n    var Clazz = storage[componentMainType];\n\n    if (Clazz && Clazz[IS_CONTAINER]) {\n      Clazz = subType ? Clazz[subType] : null;\n    }\n\n    if (throwWhenNotFound && !Clazz) {\n      throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');\n    }\n\n    return Clazz;\n  };\n\n  entity.getClassesByMainType = function (componentType) {\n    componentType = parseClassType(componentType);\n    var result = [];\n    var obj = storage[componentType.main];\n\n    if (obj && obj[IS_CONTAINER]) {\n      zrUtil.each(obj, function (o, type) {\n        type !== IS_CONTAINER && result.push(o);\n      });\n    } else {\n      result.push(obj);\n    }\n\n    return result;\n  };\n\n  entity.hasClass = function (componentType) {\n    // Just consider componentType.main.\n    componentType = parseClassType(componentType);\n    return !!storage[componentType.main];\n  };\n  /**\n   * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n   */\n\n\n  entity.getAllClassMainTypes = function () {\n    var types = [];\n    zrUtil.each(storage, function (obj, type) {\n      types.push(type);\n    });\n    return types;\n  };\n  /**\n   * If a main type is container and has sub types\n   * @param  {string}  mainType\n   * @return {boolean}\n   */\n\n\n  entity.hasSubTypes = function (componentType) {\n    componentType = parseClassType(componentType);\n    var obj = storage[componentType.main];\n    return obj && obj[IS_CONTAINER];\n  };\n\n  entity.parseClassType = parseClassType;\n\n  function makeContainer(componentType) {\n    var container = storage[componentType.main];\n\n    if (!container || !container[IS_CONTAINER]) {\n      container = storage[componentType.main] = {};\n      container[IS_CONTAINER] = true;\n    }\n\n    return container;\n  }\n\n  if (options.registerWhenExtend) {\n    var originalExtend = entity.extend;\n\n    if (originalExtend) {\n      entity.extend = function (proto) {\n        var ExtendedClass = originalExtend.call(this, proto);\n        return entity.registerClass(ExtendedClass, proto.type);\n      };\n    }\n  }\n\n  return entity;\n}\n/**\n * @param {string|Array.<string>} properties\n */\n\n\nfunction setReadOnly(obj, properties) {// FIXME It seems broken in IE8 simulation of IE11\n  // if (!zrUtil.isArray(properties)) {\n  //     properties = properties != null ? [properties] : [];\n  // }\n  // zrUtil.each(properties, function (prop) {\n  //     var value = obj[prop];\n  //     Object.defineProperty\n  //         && Object.defineProperty(obj, prop, {\n  //             value: value, writable: false\n  //         });\n  //     zrUtil.isArray(obj[prop])\n  //         && Object.freeze\n  //         && Object.freeze(obj[prop]);\n  // });\n}\n\nexports.set = set;\nexports.get = get;\nexports.hasOwn = hasOwn;\nexports.parseClassType = parseClassType;\nexports.enableClassExtend = enableClassExtend;\nexports.enableClassManagement = enableClassManagement;\nexports.setReadOnly = setReadOnly;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/clazz.js\n// module id = 824\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"./Model\");\n\nvar componentUtil = require(\"../util/component\");\n\nvar clazzUtil = require(\"../util/clazz\");\n\nvar layout = require(\"../util/layout\");\n\nvar boxLayoutMixin = require(\"./mixin/boxLayout\");\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\nvar arrayPush = Array.prototype.push;\n/**\n * @alias module:echarts/model/Component\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {module:echarts/model/Model} ecModel\n */\n\nvar ComponentModel = Model.extend({\n  type: 'component',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  id: '',\n\n  /**\n   * @readOnly\n   */\n  name: '',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  mainType: '',\n\n  /**\n   * @readOnly\n   * @type {string}\n   */\n  subType: '',\n\n  /**\n   * @readOnly\n   * @type {number}\n   */\n  componentIndex: 0,\n\n  /**\n   * @type {Object}\n   * @protected\n   */\n  defaultOption: null,\n\n  /**\n   * @type {module:echarts/model/Global}\n   * @readOnly\n   */\n  ecModel: null,\n\n  /**\n   * key: componentType\n   * value:  Component model list, can not be null.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @readOnly\n   */\n  dependentModels: [],\n\n  /**\n   * @type {string}\n   * @readOnly\n   */\n  uid: null,\n\n  /**\n   * Support merge layout params.\n   * Only support 'box' now (left/right/top/bottom/width/height).\n   * @type {string|Object} Object can be {ignoreSize: true}\n   * @readOnly\n   */\n  layoutMode: null,\n  $constructor: function (option, parentModel, ecModel, extraOpt) {\n    Model.call(this, option, parentModel, ecModel, extraOpt);\n    this.uid = componentUtil.getUID('componentModel');\n  },\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n  },\n  mergeDefaultAndTheme: function (option, ecModel) {\n    var layoutMode = this.layoutMode;\n    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};\n    var themeModel = ecModel.getTheme();\n    zrUtil.merge(option, themeModel.get(this.mainType));\n    zrUtil.merge(option, this.getDefaultOption());\n\n    if (layoutMode) {\n      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  },\n  mergeOption: function (option, extraOpt) {\n    zrUtil.merge(this.option, option, true);\n    var layoutMode = this.layoutMode;\n\n    if (layoutMode) {\n      layout.mergeLayoutParam(this.option, option, layoutMode);\n    }\n  },\n  // Hooker after init or mergeOption\n  optionUpdated: function (newCptOption, isInit) {},\n  getDefaultOption: function () {\n    if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n      var optList = [];\n      var Class = this.constructor;\n\n      while (Class) {\n        var opt = Class.prototype.defaultOption;\n        opt && optList.push(opt);\n        Class = Class.superClass;\n      }\n\n      var defaultOption = {};\n\n      for (var i = optList.length - 1; i >= 0; i--) {\n        defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n      }\n\n      clazzUtil.set(this, '__defaultOption', defaultOption);\n    }\n\n    return clazzUtil.get(this, '__defaultOption');\n  },\n  getReferringComponents: function (mainType) {\n    return this.ecModel.queryComponents({\n      mainType: mainType,\n      index: this.get(mainType + 'Index', true),\n      id: this.get(mainType + 'Id', true)\n    });\n  }\n}); // Reset ComponentModel.extend, add preConstruct.\n// clazzUtil.enableClassExtend(\n//     ComponentModel,\n//     function (option, parentModel, ecModel, extraOpt) {\n//         // Set dependentModels, componentIndex, name, id, mainType, subType.\n//         zrUtil.extend(this, extraOpt);\n//         this.uid = componentUtil.getUID('componentModel');\n//         // this.setReadOnly([\n//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n//         //     'dependentModels', 'componentIndex'\n//         // ]);\n//     }\n// );\n// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(ComponentModel, {\n  registerWhenExtend: true\n});\ncomponentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel.\n\ncomponentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\nfunction getDependencies(componentType) {\n  var deps = [];\n  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n    arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n  }); // Ensure main type\n\n  return zrUtil.map(deps, function (type) {\n    return clazzUtil.parseClassType(type).main;\n  });\n}\n\nzrUtil.mixin(ComponentModel, boxLayoutMixin);\nvar _default = ComponentModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Component.js\n// module id = 838\n// module chunks = 1 2 3 141 142 143 144 145","var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var x = rect.x;\n  var y = rect.y;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  return {\n    x: x,\n    y: y,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\n\n\nfunction parsePlainText(text, font, padding, truncate) {\n  text != null && (text += '');\n  var lineHeight = getLineHeight(font);\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 844\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _number = require(\"./number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar formatUtil = require(\"./format\");\n\n// Layout helpers for each component positioning\nvar each = zrUtil.each;\n/**\n * @public\n */\n\nvar LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n/**\n * @public\n */\n\nvar HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n  var x = 0;\n  var y = 0;\n\n  if (maxWidth == null) {\n    maxWidth = Infinity;\n  }\n\n  if (maxHeight == null) {\n    maxHeight = Infinity;\n  }\n\n  var currentLineMaxSize = 0;\n  group.eachChild(function (child, idx) {\n    var position = child.position;\n    var rect = child.getBoundingRect();\n    var nextChild = group.childAt(idx + 1);\n    var nextChildRect = nextChild && nextChild.getBoundingRect();\n    var nextX;\n    var nextY;\n\n    if (orient === 'horizontal') {\n      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group\n      // FIXME compare before adding gap?\n\n      if (nextX > maxWidth || child.newline) {\n        x = 0;\n        nextX = moveX;\n        y += currentLineMaxSize + gap;\n        currentLineMaxSize = rect.height;\n      } else {\n        // FIXME: consider rect.y is not `0`?\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n      }\n    } else {\n      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group\n\n      if (nextY > maxHeight || child.newline) {\n        x += currentLineMaxSize + gap;\n        y = 0;\n        nextY = moveY;\n        currentLineMaxSize = rect.width;\n      } else {\n        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n      }\n    }\n\n    if (child.newline) {\n      return;\n    }\n\n    position[0] = x;\n    position[1] = y;\n    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n  });\n}\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\n\nvar box = boxLayout;\n/**\n * VBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar vbox = zrUtil.curry(boxLayout, 'vertical');\n/**\n * HBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\n\nvar hbox = zrUtil.curry(boxLayout, 'horizontal');\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.x]\n * @param {number|string} [positionInfo.y]\n * @param {number|string} [positionInfo.x2]\n * @param {number|string} [positionInfo.y2]\n * @param {Object} containerRect {width, height}\n * @param {string|number} margin\n * @return {Object} {width, height}\n */\n\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var x = parsePercent(positionInfo.x, containerWidth);\n  var y = parsePercent(positionInfo.y, containerHeight);\n  var x2 = parsePercent(positionInfo.x2, containerWidth);\n  var y2 = parsePercent(positionInfo.y2, containerHeight);\n  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  return {\n    width: Math.max(x2 - x - margin[1] - margin[3], 0),\n    height: Math.max(y2 - y - margin[0] - margin[2], 0)\n  };\n}\n/**\n * Parse position info.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width]\n * @param {number|string} [positionInfo.height]\n * @param {number|string} [positionInfo.aspect] Aspect is width / height\n * @param {Object} containerRect\n * @param {string|number} [margin]\n *\n * @return {module:zrender/core/BoundingRect}\n */\n\n\nfunction getLayoutRect(positionInfo, containerRect, margin) {\n  margin = formatUtil.normalizeCssArray(margin || 0);\n  var containerWidth = containerRect.width;\n  var containerHeight = containerRect.height;\n  var left = parsePercent(positionInfo.left, containerWidth);\n  var top = parsePercent(positionInfo.top, containerHeight);\n  var right = parsePercent(positionInfo.right, containerWidth);\n  var bottom = parsePercent(positionInfo.bottom, containerHeight);\n  var width = parsePercent(positionInfo.width, containerWidth);\n  var height = parsePercent(positionInfo.height, containerHeight);\n  var verticalMargin = margin[2] + margin[0];\n  var horizontalMargin = margin[1] + margin[3];\n  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right\n\n  if (isNaN(width)) {\n    width = containerWidth - right - horizontalMargin - left;\n  }\n\n  if (isNaN(height)) {\n    height = containerHeight - bottom - verticalMargin - top;\n  }\n\n  if (aspect != null) {\n    // If width and height are not given\n    // 1. Graph should not exceeds the container\n    // 2. Aspect must be keeped\n    // 3. Graph should take the space as more as possible\n    // FIXME\n    // Margin is not considered, because there is no case that both\n    // using margin and aspect so far.\n    if (isNaN(width) && isNaN(height)) {\n      if (aspect > containerWidth / containerHeight) {\n        width = containerWidth * 0.8;\n      } else {\n        height = containerHeight * 0.8;\n      }\n    } // Calculate width or height with given aspect\n\n\n    if (isNaN(width)) {\n      width = aspect * height;\n    }\n\n    if (isNaN(height)) {\n      height = width / aspect;\n    }\n  } // If left is not specified, calculate left from right and width\n\n\n  if (isNaN(left)) {\n    left = containerWidth - right - width - horizontalMargin;\n  }\n\n  if (isNaN(top)) {\n    top = containerHeight - bottom - height - verticalMargin;\n  } // Align left and top\n\n\n  switch (positionInfo.left || positionInfo.right) {\n    case 'center':\n      left = containerWidth / 2 - width / 2 - margin[3];\n      break;\n\n    case 'right':\n      left = containerWidth - width - horizontalMargin;\n      break;\n  }\n\n  switch (positionInfo.top || positionInfo.bottom) {\n    case 'middle':\n    case 'center':\n      top = containerHeight / 2 - height / 2 - margin[0];\n      break;\n\n    case 'bottom':\n      top = containerHeight - height - verticalMargin;\n      break;\n  } // If something is wrong and left, top, width, height are calculated as NaN\n\n\n  left = left || 0;\n  top = top || 0;\n\n  if (isNaN(width)) {\n    // Width may be NaN if only one value is given except width\n    width = containerWidth - horizontalMargin - left - (right || 0);\n  }\n\n  if (isNaN(height)) {\n    // Height may be NaN if only one value is given except height\n    height = containerHeight - verticalMargin - top - (bottom || 0);\n  }\n\n  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n  rect.margin = margin;\n  return rect;\n}\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n * @param {Object} containerRect\n * @param {string|number} margin\n * @param {Object} [opt]\n * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n * @param {Array.<number>} [opt.boundingMode='all']\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\n\n\nfunction positionElement(el, positionInfo, containerRect, margin, opt) {\n  var h = !opt || !opt.hv || opt.hv[0];\n  var v = !opt || !opt.hv || opt.hv[1];\n  var boundingMode = opt && opt.boundingMode || 'all';\n\n  if (!h && !v) {\n    return;\n  }\n\n  var rect;\n\n  if (boundingMode === 'raw') {\n    rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n  } else {\n    rect = el.getBoundingRect();\n\n    if (el.needLocalTransform()) {\n      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,\n      // which should not be modified.\n\n      rect = rect.clone();\n      rect.applyTransform(transform);\n    }\n  } // The real width and height can not be specified but calculated by the given el.\n\n\n  positionInfo = getLayoutRect(zrUtil.defaults({\n    width: rect.width,\n    height: rect.height\n  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform\n  // (see zrender/core/Transformable#getLocalTransfrom),\n  // we can just only modify el.position to get final result.\n\n  var elPos = el.position;\n  var dx = h ? positionInfo.x - rect.x : 0;\n  var dy = v ? positionInfo.y - rect.y : 0;\n  el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n}\n/**\n * @param {Object} option Contains some of the properties in HV_NAMES.\n * @param {number} hvIdx 0: horizontal; 1: vertical.\n */\n\n\nfunction sizeCalculable(option, hvIdx) {\n  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n}\n/**\n * Consider Case:\n * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         var inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param {Object} targetOption\n * @param {Object} newOption\n * @param {Object|string} [opt]\n * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n *  that width (or height) should not be calculated by left and right (or top and bottom).\n */\n\n\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n  !zrUtil.isObject(opt) && (opt = {});\n  var ignoreSize = opt.ignoreSize;\n  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n  var hResult = merge(HV_NAMES[0], 0);\n  var vResult = merge(HV_NAMES[1], 1);\n  copy(HV_NAMES[0], targetOption, hResult);\n  copy(HV_NAMES[1], targetOption, vResult);\n\n  function merge(names, hvIdx) {\n    var newParams = {};\n    var newValueCount = 0;\n    var merged = {};\n    var mergedValueCount = 0;\n    var enoughParamNumber = 2;\n    each(names, function (name) {\n      merged[name] = targetOption[name];\n    });\n    each(names, function (name) {\n      // Consider case: newOption.width is null, which is\n      // set by user for removing width setting.\n      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n      hasValue(newParams, name) && newValueCount++;\n      hasValue(merged, name) && mergedValueCount++;\n    });\n\n    if (ignoreSize[hvIdx]) {\n      // Only one of left/right is premitted to exist.\n      if (hasValue(newOption, names[1])) {\n        merged[names[2]] = null;\n      } else if (hasValue(newOption, names[2])) {\n        merged[names[1]] = null;\n      }\n\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // or targetOption: {right: ...} and newOption: {width: ...},\n    // There is no conflict when merged only has params count\n    // little than enoughParamNumber.\n\n\n    if (mergedValueCount === enoughParamNumber || !newValueCount) {\n      return merged;\n    } // Case: newOption: {width: ..., right: ...},\n    // Than we can make sure user only want those two, and ignore\n    // all origin params in targetOption.\n    else if (newValueCount >= enoughParamNumber) {\n        return newParams;\n      } else {\n        // Chose another param from targetOption by priority.\n        for (var i = 0; i < names.length; i++) {\n          var name = names[i];\n\n          if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n            newParams[name] = targetOption[name];\n            break;\n          }\n        }\n\n        return newParams;\n      }\n  }\n\n  function hasProp(obj, name) {\n    return obj.hasOwnProperty(name);\n  }\n\n  function hasValue(obj, name) {\n    return obj[name] != null && obj[name] !== 'auto';\n  }\n\n  function copy(names, target, source) {\n    each(names, function (name) {\n      target[name] = source[name];\n    });\n  }\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction getLayoutParams(source) {\n  return copyLayoutParams({}, source);\n}\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\n\n\nfunction copyLayoutParams(target, source) {\n  source && target && each(LOCATION_PARAMS, function (name) {\n    source.hasOwnProperty(name) && (target[name] = source[name]);\n  });\n  return target;\n}\n\nexports.LOCATION_PARAMS = LOCATION_PARAMS;\nexports.HV_NAMES = HV_NAMES;\nexports.box = box;\nexports.vbox = vbox;\nexports.hbox = hbox;\nexports.getAvailableSize = getAvailableSize;\nexports.getLayoutRect = getLayoutRect;\nexports.positionElement = positionElement;\nexports.sizeCalculable = sizeCalculable;\nexports.mergeLayoutParam = mergeLayoutParam;\nexports.getLayoutParams = getLayoutParams;\nexports.copyLayoutParams = copyLayoutParams;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/layout.js\n// module id = 845\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar OrdinalScale = require(\"../scale/Ordinal\");\n\nvar IntervalScale = require(\"../scale/Interval\");\n\nvar Scale = require(\"../scale/Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nrequire(\"../scale/Time\");\n\nrequire(\"../scale/Log\");\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = (model.get('data') || []).length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max)); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  }\n\n  return [min, max];\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {Array.<number>} tickCoords In axis self coordinate.\n * @param {Array.<string>} labels\n * @param {string} font\n * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.\n * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.\n * @return {number}\n */\n\n\nfunction getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {\n  var textSpaceTakenRect;\n  var autoLabelInterval = 0;\n  var accumulatedLabelInterval = 0;\n  var rotation = (axisRotate - labelRotate) / 180 * Math.PI;\n  var step = 1;\n\n  if (labels.length > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.floor(labels.length / 40);\n  }\n\n  for (var i = 0; i < tickCoords.length; i += step) {\n    var tickCoord = tickCoords[i]; // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');\n    rect.x += tickCoord * Math.cos(rotation);\n    rect.y += tickCoord * Math.sin(rotation); // Magic number\n\n    rect.width *= 1.3;\n    rect.height *= 1.3;\n\n    if (!textSpaceTakenRect) {\n      textSpaceTakenRect = rect.clone();\n    } // There is no space for current label;\n    else if (textSpaceTakenRect.intersect(rect)) {\n        accumulatedLabelInterval++;\n        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n      } else {\n        textSpaceTakenRect.union(rect); // Reset\n\n        accumulatedLabelInterval = 0;\n      }\n  }\n\n  if (autoLabelInterval === 0 && step > 1) {\n    return step;\n  }\n\n  return (autoLabelInterval + 1) * step - 1;\n}\n/**\n * @param {Object} axis\n * @param {Function} labelFormatter\n * @return {Array.<string>}\n */\n\n\nfunction getFormattedLabels(axis, labelFormatter) {\n  var scale = axis.scale;\n  var labels = scale.getTicksLabels();\n  var ticks = scale.getTicks();\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return zrUtil.map(labels, labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return zrUtil.map(ticks, function (tick, idx) {\n      return labelFormatter(getAxisRawValue(axis, tick), idx);\n    }, this);\n  } else {\n    return labels;\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.getAxisLabelInterval = getAxisLabelInterval;\nexports.getFormattedLabels = getFormattedLabels;\nexports.getAxisRawValue = getAxisRawValue;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisHelper.js\n// module id = 846\n// module chunks = 1 2 3 141 142 143 144 145","var _vector = require(\"./vector\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // \n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} \n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} \n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] \n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; //  t \n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} \n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out \n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; //  t \n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 847\n// module chunks = 1 2 3 141 142 143 144 145","/**\n * 3x2\n * @exports zrender/tool/matrix\n */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * \n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 848\n// module chunks = 1 2 3 141 142 143 144 145","var Eventful = require(\"../mixin/Eventful\");\n\nexports.Dispatcher = Eventful;\n\nvar env = require(\"./env\");\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n  return el.getBoundingClientRect ? el.getBoundingClientRect() : {\n    left: 0,\n    top: 0\n  };\n} // `calculate` is optional, default false\n\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n  // FIXME\n  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n  // is too complex. So css-transfrom dont support in this case temporarily.\n\n  if (calculate || !env.canvasSupported) {\n    defaultGetZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          defaultGetZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n  // This well-known method below does not support css transform.\n  var box = getBoundingClientRect(el);\n  out.zrX = e.clientX - box.left;\n  out.zrY = e.clientY - box.top;\n}\n/**\n * domtouch.\n * `calculate` is optional, default false.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = e || window.event;\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, if may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  }\n\n  return e;\n}\n\nfunction addEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.addEventListener(name, handler);\n  } else {\n    el.attachEvent('on' + name, handler);\n  }\n}\n\nfunction removeEventListener(el, name, handler) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // \n\n\nexports.clientToLocal = clientToLocal;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.notLeftMouse = notLeftMouse;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 851\n// module chunks = 1 2 3 141 142 143 144 145","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * \n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\n\nvar Eventful = function () {\n  this._$handlers = {};\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * trigger\n   *\n   * @param {string} event \n   * @param {Function} handler \n   * @param {Object} context\n   */\n  one: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: true,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * \n   * @param {string} event \n   * @param {Function} handler \n   * @param {Object} [context]\n   */\n  on: function (event, handler, context) {\n    var _h = this._$handlers;\n\n    if (!handler || !event) {\n      return this;\n    }\n\n    if (!_h[event]) {\n      _h[event] = [];\n    }\n\n    for (var i = 0; i < _h[event].length; i++) {\n      if (_h[event][i].h === handler) {\n        return this;\n      }\n    }\n\n    _h[event].push({\n      h: handler,\n      one: false,\n      ctx: context || this\n    });\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return _h[event] && _h[event].length;\n  },\n\n  /**\n   * \n   * @param {string} event \n   * @param {Function} [handler] \n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i]['h'] != handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   *\n   * @param {string} type \n   */\n  trigger: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(_h[i]['ctx']);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(_h[i]['ctx'], args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * context, context\n   * @param {string} type \n   */\n  triggerWithContext: function (type) {\n    if (this._$handlers[type]) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var _h = this._$handlers[type];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        // Optimize advise from backbone\n        switch (argLen) {\n          case 1:\n            _h[i]['h'].call(ctx);\n\n            break;\n\n          case 2:\n            _h[i]['h'].call(ctx, args[1]);\n\n            break;\n\n          case 3:\n            _h[i]['h'].call(ctx, args[1], args[2]);\n\n            break;\n\n          default:\n            // have more than 2 given arguments\n            _h[i]['h'].apply(ctx, args);\n\n            break;\n        }\n\n        if (_h[i]['one']) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    return this;\n  }\n}; //  onxxxx \n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\nvar _default = Eventful;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 852\n// module chunks = 1 2 3 141 142 143 144 145","var LRU = require(\"../core/LRU\");\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 853\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar each = zrUtil.each;\nvar curry = zrUtil.curry; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\n\nfunction collect(ecModel, api) {\n  var result = {\n    /**\n     * key: makeKey(axis.model)\n     * value: {\n     *      axis,\n     *      coordSys,\n     *      axisPointerModel,\n     *      triggerTooltip,\n     *      involveSeries,\n     *      snap,\n     *      seriesModels,\n     *      seriesDataCount\n     * }\n     */\n    axesInfo: {},\n    seriesInvolved: false,\n\n    /**\n     * key: makeKey(coordSys.model)\n     * value: Object: key makeKey(axis.model), value: axisInfo\n     */\n    coordSysAxesInfo: {},\n    coordSysMap: {}\n  };\n  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.\n\n  result.seriesInvolved && collectSeriesInfo(result, ecModel);\n  return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n  var globalTooltipModel = ecModel.getComponent('tooltip');\n  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.\n\n  var linksOption = globalAxisPointerModel.get('link', true) || [];\n  var linkGroups = []; // Collect axes info.\n\n  each(api.getCoordinateSystems(), function (coordSys) {\n    // Some coordinate system do not support axes, like geo.\n    if (!coordSys.axisPointerEnabled) {\n      return;\n    }\n\n    var coordSysKey = makeKey(coordSys.model);\n    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer\n    // for user. So we enable seting tooltip on coordSys model.\n\n    var coordSysModel = coordSys.model;\n    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.\n    // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n\n    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not\n    // show but axisPointer will show as normal.\n    && baseTooltipModel.get('show')) {\n      // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n      // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n      var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n\n      if (triggerAxis || cross) {\n        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n      }\n\n      if (cross) {\n        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n      }\n    } // fromTooltip: true | false | 'cross'\n    // triggerTooltip: true | false | null\n\n\n    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n      var axisPointerShow = axisPointerModel.get('show');\n\n      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n        return;\n      }\n\n      if (triggerTooltip == null) {\n        triggerTooltip = axisPointerModel.get('triggerTooltip');\n      }\n\n      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n      var snap = axisPointerModel.get('snap');\n      var key = makeKey(axis.model);\n      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n\n      var axisInfo = result.axesInfo[key] = {\n        key: key,\n        axis: axis,\n        coordSys: coordSys,\n        axisPointerModel: axisPointerModel,\n        triggerTooltip: triggerTooltip,\n        involveSeries: involveSeries,\n        snap: snap,\n        useHandle: isHandleTrigger(axisPointerModel),\n        seriesModels: []\n      };\n      axesInfoInCoordSys[key] = axisInfo;\n      result.seriesInvolved |= involveSeries;\n      var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n      if (groupIndex != null) {\n        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n          axesInfo: {}\n        });\n        linkGroup.axesInfo[key] = axisInfo;\n        linkGroup.mapper = linksOption[groupIndex].mapper;\n        axisInfo.linkGroup = linkGroup;\n      }\n    }\n  });\n}\n\nfunction makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n  var volatileOption = {};\n  each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {\n    volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n  }); // category axis do not auto snap, otherwise some tick that do not\n  // has value can not be hovered. value/time/log axis default snap if\n  // triggered from tooltip and trigger tooltip.\n\n  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.\n  // Only these properties can be overrided from tooltip to axisPointer.\n\n  if (tooltipAxisPointerModel.get('type') === 'cross') {\n    volatileOption.type = 'line';\n  }\n\n  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.\n\n  labelOption.show == null && (labelOption.show = false);\n\n  if (fromTooltip === 'cross') {\n    // When 'cross', both axes show labels.\n    labelOption.show = true; // If triggerTooltip, this is a base axis, which should better not use cross style\n    // (cross style is dashed by default)\n\n    if (!triggerTooltip) {\n      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n      crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n    }\n  }\n\n  return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n  // Prepare data for axis trigger\n  ecModel.eachSeries(function (seriesModel) {\n    // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n    var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n\n    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {\n      return;\n    }\n\n    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n      var axis = axisInfo.axis;\n\n      if (coordSys.getAxis(axis.dim) === axis) {\n        axisInfo.seriesModels.push(seriesModel);\n        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n        axisInfo.seriesDataCount += seriesModel.getData().count();\n      }\n    });\n  }, this);\n}\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\n\n\nfunction getLinkGroupIndex(linksOption, axis) {\n  var axisModel = axis.model;\n  var dim = axis.dim;\n\n  for (var i = 0; i < linksOption.length; i++) {\n    var linkOption = linksOption[i] || {};\n\n    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n      return i;\n    }\n  }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n  return linkPropValue === 'all' || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n\n  if (!axisInfo) {\n    return;\n  }\n\n  var axisPointerModel = axisInfo.axisPointerModel;\n  var scale = axisInfo.axis.scale;\n  var option = axisPointerModel.option;\n  var status = axisPointerModel.get('status');\n  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.\n\n  if (value != null) {\n    value = scale.parse(value);\n  }\n\n  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value\n  // and status should be initialized.\n\n  if (status == null) {\n    option.status = useHandle ? 'show' : 'hide';\n  }\n\n  var extent = scale.getExtent().slice();\n  extent[0] > extent[1] && extent.reverse();\n\n  if ( // Pick a value on axis when initializing.\n  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n  // where we should re-pick a value to keep `handle` displaying normally.\n  || value > extent[1]) {\n    // Make handle displayed on the end of the axis when init, which looks better.\n    value = extent[1];\n  }\n\n  if (value < extent[0]) {\n    value = extent[0];\n  }\n\n  option.value = value;\n\n  if (useHandle) {\n    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n  }\n}\n\nfunction getAxisInfo(axisModel) {\n  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n  var axisInfo = getAxisInfo(axisModel);\n  return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n  return !!axisPointerModel.get('handle.show');\n}\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\n\n\nfunction makeKey(model) {\n  return model.type + '||' + model.id;\n}\n\nexports.collect = collect;\nexports.fixValue = fixValue;\nexports.getAxisInfo = getAxisInfo;\nexports.getAxisPointerModel = getAxisPointerModel;\nexports.makeKey = makeKey;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/modelHelper.js\n// module id = 854\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar modelUtil = require(\"../util/model\");\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar globalObj = typeof window === UNDEFINED ? global : window;\nvar dataCtors = {\n  'float': typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array,\n  'int': typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];\n\nfunction transferProperties(a, b) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n    if (b.hasOwnProperty(propName)) {\n      a[propName] = b[propName];\n    }\n  });\n  a.__wrappedMethods = b.__wrappedMethods;\n}\n\nfunction DefaultDataProvider(dataArray) {\n  this._array = dataArray || [];\n}\n\nDefaultDataProvider.prototype.pure = false;\n\nDefaultDataProvider.prototype.count = function () {\n  return this._array.length;\n};\n\nDefaultDataProvider.prototype.getItem = function (idx) {\n  return this._array[idx];\n};\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimensionName;\n    var dimensionInfo = {};\n\n    if (typeof dimensions[i] === 'string') {\n      dimensionName = dimensions[i];\n      dimensionInfo = {\n        name: dimensionName,\n        coordDim: dimensionName,\n        coordDimIndex: 0,\n        stackable: false,\n        // Type can be 'float', 'int', 'number'\n        // Default is number, Precision of float may not enough\n        type: 'number'\n      };\n    } else {\n      dimensionInfo = dimensions[i];\n      dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'number';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this.indices = [];\n  /**\n   * Data storage\n   * @type {Object.<key, TypedArray|Array>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * @param {module:echarts/data/List}\n   */\n\n  this.stackedOn = null;\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (!isNaN(dim)) {\n    dim = this.dimensions[dim] || dim;\n  }\n\n  return dim;\n};\n/**\n * Get type and stackable info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data\n * @param {Array.<string>} [nameList]\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  data = data || [];\n  var isDataArray = zrUtil.isArray(data);\n\n  if (isDataArray) {\n    data = new DefaultDataProvider(data);\n  }\n\n  this._rawData = data; // Clear\n\n  var storage = this._storage = {};\n  var indices = this.indices = [];\n  var dimensions = this.dimensions;\n  var dimensionInfoMap = this._dimensionInfos;\n  var size = data.count();\n  var idList = [];\n  var nameRepeatCount = {};\n  var nameDimIdx;\n  nameList = nameList || []; // Init storage\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = dimensionInfoMap[dimensions[i]];\n    dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n    var DataCtor = dataCtors[dimInfo.type];\n    storage[dimensions[i]] = new DataCtor(size);\n  }\n\n  var self = this;\n\n  if (!dimValueGetter) {\n    self.hasItemOption = false;\n  } // Default dim value getter\n\n\n  dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n    var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 }\n\n    if (modelUtil.isDataItemOption(dataItem)) {\n      self.hasItemOption = true;\n    }\n\n    return modelUtil.converDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n    : value, dimensionInfoMap[dimName]);\n  };\n\n  for (var i = 0; i < size; i++) {\n    // NOTICE: Try not to write things into dataItem\n    var dataItem = data.getItem(i); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of cateogry\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // Store the data by dimensions\n\n    for (var k = 0; k < dimensions.length; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim]; // PENDING NULL is empty or zero\n\n      dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n    }\n\n    indices.push(i);\n  } // Use the name in option and create id\n\n\n  for (var i = 0; i < size; i++) {\n    var dataItem = data.getItem(i);\n\n    if (!nameList[i] && dataItem) {\n      if (dataItem.name != null) {\n        nameList[i] = dataItem.name;\n      } else if (nameDimIdx != null) {\n        nameList[i] = storage[dimensions[nameDimIdx]][i];\n      }\n    }\n\n    var name = nameList[i] || ''; // Try using the id in option\n\n    var id = dataItem && dataItem.id;\n\n    if (!id && name) {\n      // Use name as id and add counter to avoid same name\n      nameRepeatCount[name] = nameRepeatCount[name] || 0;\n      id = name;\n\n      if (nameRepeatCount[name] > 0) {\n        id += '__ec__' + nameRepeatCount[name];\n      }\n\n      nameRepeatCount[name]++;\n    }\n\n    id && (idList[i] = id);\n  }\n\n  this._nameList = nameList;\n  this._idList = idList;\n};\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this.indices.length;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx, stack) {\n  var storage = this._storage;\n  var dataIndex = this.indices[idx]; // If value not exists\n\n  if (dataIndex == null || !storage[dim]) {\n    return NaN;\n  }\n\n  var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable\n\n  if (stack) {\n    var dimensionInfo = this._dimensionInfos[dim];\n\n    if (dimensionInfo && dimensionInfo.stackable) {\n      var stackedOn = this.stackedOn;\n\n      while (stackedOn) {\n        // Get no stacked data of stacked on\n        var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data\n\n        if (value >= 0 && stackedValue > 0 || // Positive stack\n        value <= 0 && stackedValue < 0 // Negative stack\n        ) {\n            value += stackedValue;\n          }\n\n        stackedOn = stackedOn.stackedOn;\n      }\n    }\n  }\n\n  return value;\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx, stack) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx, stack));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dimensions = this.dimensions;\n  var dimensionInfos = this._dimensionInfos;\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    if ( // Ordinal type can be string or number\n    dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n * @param {Function} filter\n */\n\n\nlistProto.getDataExtent = function (dim, stack, filter) {\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var dimInfo = this.getDimensionInfo(dim);\n  stack = dimInfo && dimInfo.stackable && stack;\n  var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];\n  var value;\n\n  if (dimExtent) {\n    return dimExtent;\n  } // var dimInfo = this._dimensionInfos[dim];\n\n\n  if (dimData) {\n    var min = Infinity;\n    var max = -Infinity; // var isOrdinal = dimInfo.type === 'ordinal';\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      value = this.get(dim, i, stack); // FIXME\n      // if (isOrdinal && typeof value === 'string') {\n      //     value = zrUtil.indexOf(dimData, value);\n      // }\n\n      if (!filter || filter(value, dim, i)) {\n        value < min && (min = value);\n        value > max && (max = value);\n      }\n    }\n\n    return this._extent[dim + !!stack] = [min, max];\n  } else {\n    return [Infinity, -Infinity];\n  }\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getSum = function (dim, stack) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i, stack);\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Retreive the index with given value\n * @param {number} idx\n * @param {number} value\n * @return {number}\n */\n// FIXME Precision of float value\n\n\nlistProto.indexOf = function (dim, value) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var indices = this.indices;\n\n  if (dimData) {\n    for (var i = 0, len = indices.length; i < len; i++) {\n      var rawIndex = indices[i];\n\n      if (dimData[rawIndex] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  var indices = this.indices;\n  var nameList = this._nameList;\n\n  for (var i = 0, len = indices.length; i < len; i++) {\n    var rawIndex = indices[i];\n\n    if (nameList[rawIndex] === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  // Indices are ascending\n  var indices = this.indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = indices.length - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {boolean} stack If given value is after stacked\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i, stack);\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = function (idx) {\n  var rawIdx = this.indices[idx];\n  return rawIdx == null ? -1 : rawIdx;\n};\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  return this._rawData.getItem(this.getRawIndex(idx));\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  return this._nameList[this.indices[idx]] || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';\n};\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, stack, context) {\n  if (typeof dims === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dims;\n    dims = [];\n  }\n\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var value = [];\n  var dimSize = dims.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i, stack), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n        break;\n\n      default:\n        for (var k = 0; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i, stack);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var newIndices = [];\n  var value = [];\n  var dimSize = dimensions.length;\n  var indices = this.indices;\n  context = context || this;\n\n  for (var i = 0; i < indices.length; i++) {\n    var keep; // Simple optimization\n\n    if (!dimSize) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      keep = cb.call(context, this.get(dimensions[0], i, stack), i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this.get(dimensions[k], i, stack);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices.push(indices[i]);\n    }\n  }\n\n  this.indices = newIndices; // Reset data extent\n\n  this._extent = {};\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, stack, context) {\n  if (typeof dimensions === 'function') {\n    context = stack;\n    stack = cb;\n    cb = dimensions;\n    dimensions = [];\n  }\n\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, stack, context);\n  return result;\n};\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n    var dimStore = originalStorage[dim];\n\n    if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n      storage[dim] = new dimStore.constructor(originalStorage[dim].length);\n    } else {\n      // Direct reference for other dimensions\n      storage[dim] = originalStorage[dim];\n    }\n  }\n\n  return list;\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, stack, context) {\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  var indices = list.indices = this.indices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  this.each(dimensions, function () {\n    var idx = arguments[arguments.length - 1];\n    var retValue = cb && cb.apply(this, arguments);\n\n    if (retValue != null) {\n      // a number\n      if (typeof retValue === 'number') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var dimStore = storage[dim];\n        var rawIdx = indices[idx];\n\n        if (dimStore) {\n          dimStore[rawIdx] = retValue[i];\n        }\n      }\n    }\n  }, stack, context);\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var storage = this._storage;\n  var targetStorage = list._storage;\n  var originalIndices = this.indices;\n  var indices = list.indices = [];\n  var frameValues = [];\n  var frameIndices = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count(); // Copy data from original data\n\n  for (var i = 0; i < storage[dimension].length; i++) {\n    targetStorage[dimension][i] = storage[dimension][i];\n  }\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var idx = originalIndices[i + k];\n      frameValues[k] = dimStore[idx];\n      frameIndices[k] = idx;\n    }\n\n    var value = sampleValue(frameValues);\n    var idx = frameIndices[sampleIndex(frameValues, value) || 0]; // Only write value on the filtered data\n\n    dimStore[idx] = value;\n    indices.push(idx);\n  }\n\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  idx = this.indices[idx];\n  return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var idList = this._idList;\n  var otherIdList = otherList && otherList._idList;\n  var val; // Use prefix to avoid index to be the same as otherIdList[idx],\n  // which will cause weird udpate animation.\n\n  var prefix = 'e\\0\\0';\n  return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {\n    return (val = otherIdList[idx]) != null ? val : prefix + idx;\n  }, function (idx) {\n    return (val = idList[idx]) != null ? val : prefix + idx;\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function () {\n  var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n  var list = new List(dimensionInfoList, this.hostModel); // FIXME\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  list.indices = this.indices.slice();\n\n  if (this._extent) {\n    list._extent = zrUtil.extend({}, this._extent);\n  }\n\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf'];\nvar _default = List;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/List.js\n// module id = 855\n// module chunks = 1 2 3 141 142 143 144 145","var clazzUtil = require(\"../util/clazz\");\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n/**\n * @param {Object} [setting]\n */\nfunction Scale(setting) {\n  this._setting = setting || {};\n  /**\n   * Extent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._extent = [Infinity, -Infinity];\n  /**\n   * Step is calculated in adjustExtent\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this._interval = 0;\n  this.init && this.init.apply(this, arguments);\n}\n/**\n * Parse input val to valid inner number.\n * @param {*} val\n * @return {number}\n */\n\n\nScale.prototype.parse = function (val) {\n  // Notice: This would be a trap here, If the implementation\n  // of this method depends on extent, and this method is used\n  // before extent set (like in dataZoom), it would be wrong.\n  // Nevertheless, parse does not depend on extent generally.\n  return val;\n};\n\nScale.prototype.getSetting = function (name) {\n  return this._setting[name];\n};\n\nScale.prototype.contain = function (val) {\n  var extent = this._extent;\n  return val >= extent[0] && val <= extent[1];\n};\n/**\n * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.normalize = function (val) {\n  var extent = this._extent;\n\n  if (extent[1] === extent[0]) {\n    return 0.5;\n  }\n\n  return (val - extent[0]) / (extent[1] - extent[0]);\n};\n/**\n * Scale normalized value\n * @param {number} val\n * @return {number}\n */\n\n\nScale.prototype.scale = function (val) {\n  var extent = this._extent;\n  return val * (extent[1] - extent[0]) + extent[0];\n};\n/**\n * Set extent from data\n * @param {Array.<number>} other\n */\n\n\nScale.prototype.unionExtent = function (other) {\n  var extent = this._extent;\n  other[0] < extent[0] && (extent[0] = other[0]);\n  other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power\n  // this.setExtent(extent[0], extent[1]);\n};\n/**\n * Set extent from data\n * @param {module:echarts/data/List} data\n * @param {string} dim\n */\n\n\nScale.prototype.unionExtentFromData = function (data, dim) {\n  this.unionExtent(data.getDataExtent(dim, true));\n};\n/**\n * Get extent\n * @return {Array.<number>}\n */\n\n\nScale.prototype.getExtent = function () {\n  return this._extent.slice();\n};\n/**\n * Set extent\n * @param {number} start\n * @param {number} end\n */\n\n\nScale.prototype.setExtent = function (start, end) {\n  var thisExtent = this._extent;\n\n  if (!isNaN(start)) {\n    thisExtent[0] = start;\n  }\n\n  if (!isNaN(end)) {\n    thisExtent[1] = end;\n  }\n};\n/**\n * @return {Array.<string>}\n */\n\n\nScale.prototype.getTicksLabels = function () {\n  var labels = [];\n  var ticks = this.getTicks();\n\n  for (var i = 0; i < ticks.length; i++) {\n    labels.push(this.getLabel(ticks[i]));\n  }\n\n  return labels;\n};\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\n\n\nScale.prototype.isBlank = function () {\n  return this._isBlank;\n},\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.setBlank = function (isBlank) {\n  this._isBlank = isBlank;\n};\nclazzUtil.enableClassExtend(Scale);\nclazzUtil.enableClassManagement(Scale, {\n  registerWhenExtend: true\n});\nvar _default = Scale;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Scale.js\n// module id = 856\n// module chunks = 1 2 3 141 142 143 144 145","var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config\n * @exports zrender/config\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n/**\n * debugcatchBrushExceptiontrue\n * 0 : debug\n * 1 : \n * 2 : \n */\n\n\nvar debugMode = 0; // retina \n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 857\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"../core/util\");\n\nvar Element = require(\"../Element\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * \n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   *  index \n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * \n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * \n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   *  nextSibling \n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * \n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * \n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 858\n// module chunks = 1 2 3 141 142 143 144 145","var curve = require(\"./curve\");\n\nvar vec2 = require(\"./vector\");\n\nvar bbox = require(\"./bbox\");\n\nvar BoundingRect = require(\"./BoundingRect\");\n\nvar _config = require(\"../config\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array != 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * Path\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy) {\n    this._ux = mathAbs(1 / dpr / sx) || 0;\n    this._uy = mathAbs(1 / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi  _dashedXXXXTo \n    // xi, yi , x0, y0  closePath \n    //  beginPath  lineTo x0, y0 \n    //  lineTo dashed line  IE10- \n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cx;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context  rebuildPath  fill\n   * stroke \n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * \n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   *  Path \n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length == len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * \n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   *  Path \n   * \n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      //  Float32Array\n      // \n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   *  Float32Array \n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i == 1) {\n        //  L, C, Q\n        //  previous point  point\n        //\n        //  Arc \n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo  subpath, \n          //  closePath \n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc \n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc \n\n          var psi = data[i++];\n          var anticlockwise = 1 - data[i++];\n\n          if (i == 1) {\n            //  arc \n            // \n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0, y0;\n    var xi, yi;\n    var x, y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i == 1) {\n        //  L, C, Q\n        //  previous point  point\n        //\n        //  Arc \n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i == 1) {\n            //  arc \n            // \n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 859\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\n// TODO Parse shadow style\n// TODO Only shallow path support\nfunction _default(properties) {\n  // Normalize\n  for (var i = 0; i < properties.length; i++) {\n    if (!properties[i][1]) {\n      properties[i][1] = properties[i][0];\n    }\n  }\n\n  return function (model, excludes, includes) {\n    var style = {};\n\n    for (var i = 0; i < properties.length; i++) {\n      var propName = properties[i][1];\n\n      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {\n        continue;\n      }\n\n      var val = model.getShallow(propName);\n\n      if (val != null) {\n        style[properties[i][0]] = val;\n      }\n    }\n\n    return style;\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 860\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar _format = require(\"../util/format\");\n\nvar formatTime = _format.formatTime;\nvar encodeHTML = _format.encodeHTML;\nvar addCommas = _format.addCommas;\nvar getTooltipMarker = _format.getTooltipMarker;\n\nvar _clazz = require(\"../util/clazz\");\n\nvar set = _clazz.set;\nvar get = _clazz.get;\n\nvar modelUtil = require(\"../util/model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar SeriesModel = ComponentModel.extend({\n  type: 'series.__base__',\n\n  /**\n   * @readOnly\n   */\n  seriesIndex: 0,\n  // coodinateSystem will be injected in the echarts/CoordinateSystem\n  coordinateSystem: null,\n\n  /**\n   * @type {Object}\n   * @protected\n   */\n  defaultOption: null,\n\n  /**\n   * Data provided for legend\n   * @type {Function}\n   */\n  // PENDING\n  legendDataProvider: null,\n\n  /**\n   * Access path of color for visual\n   */\n  visualColorAccessPath: 'itemStyle.normal.color',\n\n  /**\n   * Support merge layout params.\n   * Only support 'box' now (left/right/top/bottom/width/height).\n   * @type {string|Object} Object can be {ignoreSize: true}\n   * @readOnly\n   */\n  layoutMode: null,\n  init: function (option, parentModel, ecModel, extraOpt) {\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.seriesIndex = this.componentIndex;\n    this.mergeDefaultAndTheme(option, ecModel);\n    var data = this.getInitialData(option, ecModel);\n\n    /**\n     * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n     * @private\n     */\n    set(this, 'dataBeforeProcessed', data); // If we reverse the order (make data firstly, and then make\n    // dataBeforeProcessed by cloneShallow), cloneShallow will\n    // cause data.graph.data !== data when using\n    // module:echarts/data/Graph or module:echarts/data/Tree.\n    // See module:echarts/data/helper/linkList\n\n    this.restoreData();\n  },\n\n  /**\n   * Util for merge default and theme to option\n   * @param  {Object} option\n   * @param  {module:echarts/model/Global} ecModel\n   */\n  mergeDefaultAndTheme: function (option, ecModel) {\n    var layoutMode = this.layoutMode;\n    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.\n    // But if name duplicate between series subType\n    // (for example: parallel) add component mainType,\n    // add suffix 'Series'.\n\n    var themeSubType = this.subType;\n\n    if (ComponentModel.hasClass(themeSubType)) {\n      themeSubType += 'Series';\n    }\n\n    zrUtil.merge(option, ecModel.getTheme().get(this.subType));\n    zrUtil.merge(option, this.getDefaultOption()); // Default label emphasis `show`\n\n    modelUtil.defaultEmphasis(option.label, ['show']);\n    this.fillDataTextStyle(option.data);\n\n    if (layoutMode) {\n      mergeLayoutParam(option, inputPositionParams, layoutMode);\n    }\n  },\n  mergeOption: function (newSeriesOption, ecModel) {\n    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n    this.fillDataTextStyle(newSeriesOption.data);\n    var layoutMode = this.layoutMode;\n\n    if (layoutMode) {\n      mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n    }\n\n    var data = this.getInitialData(newSeriesOption, ecModel); // TODO Merge data?\n\n    if (data) {\n      set(this, 'data', data);\n      set(this, 'dataBeforeProcessed', data.cloneShallow());\n    }\n  },\n  fillDataTextStyle: function (data) {\n    // Default data label emphasis `show`\n    // FIXME Tree structure data ?\n    // FIXME Performance ?\n    if (data) {\n      var props = ['show'];\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] && data[i].label) {\n          modelUtil.defaultEmphasis(data[i].label, props);\n        }\n      }\n    }\n  },\n\n  /**\n   * Init a data structure from data related option in series\n   * Must be overwritten\n   */\n  getInitialData: function () {},\n\n  /**\n   * @param {string} [dataType]\n   * @return {module:echarts/data/List}\n   */\n  getData: function (dataType) {\n    var data = get(this, 'data');\n    return dataType == null ? data : data.getLinkedData(dataType);\n  },\n\n  /**\n   * @param {module:echarts/data/List} data\n   */\n  setData: function (data) {\n    set(this, 'data', data);\n  },\n\n  /**\n   * Get data before processed\n   * @return {module:echarts/data/List}\n   */\n  getRawData: function () {\n    return get(this, 'dataBeforeProcessed');\n  },\n\n  /**\n   * Coord dimension to data dimension.\n   *\n   * By default the result is the same as dimensions of series data.\n   * But in some series data dimensions are different from coord dimensions (i.e.\n   * candlestick and boxplot). Override this method to handle those cases.\n   *\n   * Coord dimension to data dimension can be one-to-many\n   *\n   * @param {string} coordDim\n   * @return {Array.<string>} dimensions on the axis.\n   */\n  coordDimToDataDim: function (coordDim) {\n    return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n  },\n\n  /**\n   * Convert data dimension to coord dimension.\n   *\n   * @param {string|number} dataDim\n   * @return {string}\n   */\n  dataDimToCoordDim: function (dataDim) {\n    return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n  },\n\n  /**\n   * Get base axis if has coordinate system and has axis.\n   * By default use coordSys.getBaseAxis();\n   * Can be overrided for some chart.\n   * @return {type} description\n   */\n  getBaseAxis: function () {\n    var coordSys = this.coordinateSystem;\n    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n  },\n  // FIXME\n\n  /**\n   * Default tooltip formatter\n   *\n   * @param {number} dataIndex\n   * @param {boolean} [multipleSeries=false]\n   * @param {number} [dataType]\n   */\n  formatTooltip: function (dataIndex, multipleSeries, dataType) {\n    function formatArrayValue(value) {\n      var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n        var dimItem = data.getDimensionInfo(idx);\n        return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n      }, 0);\n      var result = [];\n      var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n      tooltipDims.length ? zrUtil.each(tooltipDims, function (dimIdx) {\n        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n      }) // By default, all dims is used on tooltip.\n      : zrUtil.each(value, setEachItem);\n\n      function setEachItem(val, dimIdx) {\n        var dimInfo = data.getDimensionInfo(dimIdx); // If `dimInfo.tooltip` is not set, show tooltip.\n\n        if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n          return;\n        }\n\n        var dimType = dimInfo.type;\n        var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '') + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val) : addCommas(val));\n        valStr && result.push(encodeHTML(valStr));\n      }\n\n      return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n    }\n\n    var data = get(this, 'data');\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? formatArrayValue(value) : encodeHTML(addCommas(value));\n    var name = data.getName(dataIndex);\n    var color = data.getItemVisual(dataIndex, 'color');\n\n    if (zrUtil.isObject(color) && color.colorStops) {\n      color = (color.colorStops[0] || {}).color;\n    }\n\n    color = color || 'transparent';\n    var colorEl = getTooltipMarker(color);\n    var seriesName = this.name; // FIXME\n\n    if (seriesName === '\\0-') {\n      // Not show '-'\n      seriesName = '';\n    }\n\n    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';\n    return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var animationEnabled = this.getShallow('animation');\n\n    if (animationEnabled) {\n      if (this.getData().count() > this.getShallow('animationThreshold')) {\n        animationEnabled = false;\n      }\n    }\n\n    return animationEnabled;\n  },\n  restoreData: function () {\n    set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n  },\n  getColorFromPalette: function (name, scope) {\n    var ecModel = this.ecModel; // PENDING\n\n    var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\n    if (!color) {\n      color = ecModel.getColorFromPalette(name, scope);\n    }\n\n    return color;\n  },\n\n  /**\n   * Get data indices for show tooltip content. See tooltip.\n   * @abstract\n   * @param {Array.<string>|string} dim\n   * @param {Array.<number>} value\n   * @param {module:echarts/coord/single/SingleAxis} baseAxis\n   * @return {Object} {dataIndices, nestestValue}.\n   */\n  getAxisTooltipData: null,\n\n  /**\n   * See tooltip.\n   * @abstract\n   * @param {number} dataIndex\n   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n   */\n  getTooltipPosition: null\n});\nzrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\nzrUtil.mixin(SeriesModel, colorPaletteMixin);\nvar _default = SeriesModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Series.js\n// module id = 868\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Group = require(\"zrender/lib/container/Group\");\n\nvar componentUtil = require(\"../util/component\");\n\nvar clazzUtil = require(\"../util/clazz\");\n\nvar modelUtil = require(\"../util/model\");\n\nfunction Chart() {\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n  this.group = new Group();\n  /**\n   * @type {string}\n   * @readOnly\n   */\n\n  this.uid = componentUtil.getUID('viewChart');\n}\n\nChart.prototype = {\n  type: 'chart',\n\n  /**\n   * Init the chart\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  init: function (ecModel, api) {},\n\n  /**\n   * Render the chart\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  render: function (seriesModel, ecModel, api, payload) {},\n\n  /**\n   * Highlight series or specified data item\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  highlight: function (seriesModel, ecModel, api, payload) {\n    toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n  },\n\n  /**\n   * Downplay series or specified data item\n   * @param  {module:echarts/model/Series} seriesModel\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   * @param  {Object} payload\n   */\n  downplay: function (seriesModel, ecModel, api, payload) {\n    toggleHighlight(seriesModel.getData(), payload, 'normal');\n  },\n\n  /**\n   * Remove self\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  remove: function (ecModel, api) {\n    this.group.removeAll();\n  },\n\n  /**\n   * Dispose self\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  dispose: function () {}\n  /**\n   * The view contains the given point.\n   * @interface\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  // containPoint: function () {}\n\n};\nvar chartProto = Chart.prototype;\n\nchartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {\n  this.render(seriesModel, ecModel, api, payload);\n};\n/**\n * Set state of single element\n * @param  {module:zrender/Element} el\n * @param  {string} state\n */\n\n\nfunction elSetState(el, state) {\n  if (el) {\n    el.trigger(state);\n\n    if (el.type === 'group') {\n      for (var i = 0; i < el.childCount(); i++) {\n        elSetState(el.childAt(i), state);\n      }\n    }\n  }\n}\n/**\n * @param  {module:echarts/data/List} data\n * @param  {Object} payload\n * @param  {string} state 'normal'|'emphasis'\n * @inner\n */\n\n\nfunction toggleHighlight(data, payload, state) {\n  var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n  if (dataIndex != null) {\n    zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n      elSetState(data.getItemGraphicEl(dataIdx), state);\n    });\n  } else {\n    data.eachItemGraphicEl(function (el) {\n      elSetState(el, state);\n    });\n  }\n} // Enable Chart.extend.\n\n\nclazzUtil.enableClassExtend(Chart, ['dispose']); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(Chart, {\n  registerWhenExtend: true\n});\nvar _default = Chart;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Chart.js\n// module id = 869\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar coordinateSystemCreators = {};\n\nfunction CoordinateSystemManager() {\n  this._coordinateSystems = [];\n}\n\nCoordinateSystemManager.prototype = {\n  constructor: CoordinateSystemManager,\n  create: function (ecModel, api) {\n    var coordinateSystems = [];\n    zrUtil.each(coordinateSystemCreators, function (creater, type) {\n      var list = creater.create(ecModel, api);\n      coordinateSystems = coordinateSystems.concat(list || []);\n    });\n    this._coordinateSystems = coordinateSystems;\n  },\n  update: function (ecModel, api) {\n    zrUtil.each(this._coordinateSystems, function (coordSys) {\n      // FIXME MUST have\n      coordSys.update && coordSys.update(ecModel, api);\n    });\n  },\n  getCoordinateSystems: function () {\n    return this._coordinateSystems.slice();\n  }\n};\n\nCoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n  coordinateSystemCreators[type] = coordinateSystemCreator;\n};\n\nCoordinateSystemManager.get = function (type) {\n  return coordinateSystemCreators[type];\n};\n\nvar _default = CoordinateSystemManager;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/CoordinateSystem.js\n// module id = 872\n// module chunks = 1 2 3 141 142 143 144 145","var numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\nvar roundNumber = numberUtil.round;\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function (start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\n   * Get interval\n   */\n  getInterval: function () {\n    return this._interval;\n  },\n\n  /**\n   * Set interval\n   */\n  setInterval: function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    return helper.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getTicksLabels: function () {\n    var labels = [];\n    var ticks = this.getTicks();\n\n    for (var i = 0; i < ticks.length; i++) {\n      labels.push(this.getLabel(ticks[i]));\n    }\n\n    return labels;\n  },\n\n  /**\n   * @param {number} data\n   * @param {Object} [opt]\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n   * @return {string}\n   */\n  getLabel: function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   *\n   * @param {number} [splitNumber = 5] Desired number of ticks\n   * @param {number} [minInterval]\n   * @param {number} [maxInterval]\n   */\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @param {Object} opt\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\n   * @param {boolean} [opt.fixMin=false]\n   * @param {boolean} [opt.fixMax=false]\n   * @param {boolean} [opt.minInterval]\n   * @param {boolean} [opt.maxInterval]\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Interval.js\n// module id = 873\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _clazz = require(\"./clazz\");\n\nvar parseClassType = _clazz.parseClassType;\nvar base = 0;\nvar DELIMITER = '_';\n/**\n * @public\n * @param {string} type\n * @return {string}\n */\n\nfunction getUID(type) {\n  // Considering the case of crossing js context,\n  // use Math.random to make id as unique as possible.\n  return [type || '', base++, Math.random()].join(DELIMITER);\n}\n/**\n * @inner\n */\n\n\nfunction enableSubTypeDefaulter(entity) {\n  var subTypeDefaulters = {};\n\n  entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n    componentType = parseClassType(componentType);\n    subTypeDefaulters[componentType.main] = defaulter;\n  };\n\n  entity.determineSubType = function (componentType, option) {\n    var type = option.type;\n\n    if (!type) {\n      var componentTypeMain = parseClassType(componentType).main;\n\n      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n        type = subTypeDefaulters[componentTypeMain](option);\n      }\n    }\n\n    return type;\n  };\n\n  return entity;\n}\n/**\n * Topological travel on Activity Network (Activity On Vertices).\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n *\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n *\n * If there is circle dependencey, Error will be thrown.\n *\n */\n\n\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n  /**\n   * @public\n   * @param {Array.<string>} targetNameList Target Component type list.\n   *                                           Can be ['aa', 'bb', 'aa.xx']\n   * @param {Array.<string>} fullNameList By which we can build dependency graph.\n   * @param {Function} callback Params: componentType, dependencies.\n   * @param {Object} context Scope of callback.\n   */\n  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n    if (!targetNameList.length) {\n      return;\n    }\n\n    var result = makeDepndencyGraph(fullNameList);\n    var graph = result.graph;\n    var stack = result.noEntryList;\n    var targetNameSet = {};\n    zrUtil.each(targetNameList, function (name) {\n      targetNameSet[name] = true;\n    });\n\n    while (stack.length) {\n      var currComponentType = stack.pop();\n      var currVertex = graph[currComponentType];\n      var isInTargetNameSet = !!targetNameSet[currComponentType];\n\n      if (isInTargetNameSet) {\n        callback.call(context, currComponentType, currVertex.originalDeps.slice());\n        delete targetNameSet[currComponentType];\n      }\n\n      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n    }\n\n    zrUtil.each(targetNameSet, function () {\n      throw new Error('Circle dependency may exists');\n    });\n\n    function removeEdge(succComponentType) {\n      graph[succComponentType].entryCount--;\n\n      if (graph[succComponentType].entryCount === 0) {\n        stack.push(succComponentType);\n      }\n    } // Consider this case: legend depends on series, and we call\n    // chart.setOption({series: [...]}), where only series is in option.\n    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n    // not be called, but only sereis.mergeOption is called. Thus legend\n    // have no chance to update its local record about series (like which\n    // name of series is available in legend).\n\n\n    function removeEdgeAndAdd(succComponentType) {\n      targetNameSet[succComponentType] = true;\n      removeEdge(succComponentType);\n    }\n  };\n  /**\n   * DepndencyGraph: {Object}\n   * key: conponentType,\n   * value: {\n   *     successor: [conponentTypes...],\n   *     originalDeps: [conponentTypes...],\n   *     entryCount: {number}\n   * }\n   */\n\n\n  function makeDepndencyGraph(fullNameList) {\n    var graph = {};\n    var noEntryList = [];\n    zrUtil.each(fullNameList, function (name) {\n      var thisItem = createDependencyGraphItem(graph, name);\n      var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n      thisItem.entryCount = availableDeps.length;\n\n      if (thisItem.entryCount === 0) {\n        noEntryList.push(name);\n      }\n\n      zrUtil.each(availableDeps, function (dependentName) {\n        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n          thisItem.predecessor.push(dependentName);\n        }\n\n        var thatItem = createDependencyGraphItem(graph, dependentName);\n\n        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n          thatItem.successor.push(name);\n        }\n      });\n    });\n    return {\n      graph: graph,\n      noEntryList: noEntryList\n    };\n  }\n\n  function createDependencyGraphItem(graph, name) {\n    if (!graph[name]) {\n      graph[name] = {\n        predecessor: [],\n        successor: []\n      };\n    }\n\n    return graph[name];\n  }\n\n  function getAvailableDependencies(originalDeps, fullNameList) {\n    var availableDeps = [];\n    zrUtil.each(originalDeps, function (dep) {\n      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n    });\n    return availableDeps;\n  }\n}\n\nexports.getUID = getUID;\nexports.enableSubTypeDefaulter = enableSubTypeDefaulter;\nexports.enableTopologicalTravel = enableTopologicalTravel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/component.js\n// module id = 874\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"./graphic\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\n// Symbol factory\n\n/**\n * Triangle shape\n * @inner\n */\nvar Triangle = graphic.extendShape({\n  type: 'triangle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy + height);\n    path.lineTo(cx - width, cy + height);\n    path.closePath();\n  }\n});\n/**\n * Diamond shape\n * @inner\n */\n\nvar Diamond = graphic.extendShape({\n  type: 'diamond',\n  shape: {\n    cx: 0,\n    cy: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var cx = shape.cx;\n    var cy = shape.cy;\n    var width = shape.width / 2;\n    var height = shape.height / 2;\n    path.moveTo(cx, cy - height);\n    path.lineTo(cx + width, cy);\n    path.lineTo(cx, cy + height);\n    path.lineTo(cx - width, cy);\n    path.closePath();\n  }\n});\n/**\n * Pin shape\n * @inner\n */\n\nvar Pin = graphic.extendShape({\n  type: 'pin',\n  shape: {\n    // x, y on the cusp\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (path, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var w = shape.width / 5 * 3; // Height must be larger than width\n\n    var h = Math.max(w, shape.height);\n    var r = w / 2; // Dist on y with tangent point and circle center\n\n    var dy = r * r / (h - r);\n    var cy = y - h + r + dy;\n    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center\n\n    var dx = Math.cos(angle) * r;\n    var tanX = Math.sin(angle);\n    var tanY = Math.cos(angle);\n    var cpLen = r * 0.6;\n    var cpLen2 = r * 0.7;\n    path.moveTo(x - dx, cy + dy);\n    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);\n    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);\n    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);\n    path.closePath();\n  }\n});\n/**\n * Arrow shape\n * @inner\n */\n\nvar Arrow = graphic.extendShape({\n  type: 'arrow',\n  shape: {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var height = shape.height;\n    var width = shape.width;\n    var x = shape.x;\n    var y = shape.y;\n    var dx = width / 3 * 2;\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + dx, y + height);\n    ctx.lineTo(x, y + height / 4 * 3);\n    ctx.lineTo(x - dx, y + height);\n    ctx.lineTo(x, y);\n    ctx.closePath();\n  }\n});\n/**\n * Map of path contructors\n * @type {Object.<string, module:zrender/graphic/Path>}\n */\n\nvar symbolCtors = {\n  line: graphic.Line,\n  rect: graphic.Rect,\n  roundRect: graphic.Rect,\n  square: graphic.Rect,\n  circle: graphic.Circle,\n  diamond: Diamond,\n  pin: Pin,\n  arrow: Arrow,\n  triangle: Triangle\n};\nvar symbolShapeMakers = {\n  line: function (x, y, w, h, shape) {\n    // FIXME\n    shape.x1 = x;\n    shape.y1 = y + h / 2;\n    shape.x2 = x + w;\n    shape.y2 = y + h / 2;\n  },\n  rect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n  },\n  roundRect: function (x, y, w, h, shape) {\n    shape.x = x;\n    shape.y = y;\n    shape.width = w;\n    shape.height = h;\n    shape.r = Math.min(w, h) / 4;\n  },\n  square: function (x, y, w, h, shape) {\n    var size = Math.min(w, h);\n    shape.x = x;\n    shape.y = y;\n    shape.width = size;\n    shape.height = size;\n  },\n  circle: function (x, y, w, h, shape) {\n    // Put circle in the center of square\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.r = Math.min(w, h) / 2;\n  },\n  diamond: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  pin: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  arrow: function (x, y, w, h, shape) {\n    shape.x = x + w / 2;\n    shape.y = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  },\n  triangle: function (x, y, w, h, shape) {\n    shape.cx = x + w / 2;\n    shape.cy = y + h / 2;\n    shape.width = w;\n    shape.height = h;\n  }\n};\nvar symbolBuildProxies = {};\nzrUtil.each(symbolCtors, function (Ctor, name) {\n  symbolBuildProxies[name] = new Ctor();\n});\nvar SymbolClz = graphic.extendShape({\n  type: 'symbol',\n  shape: {\n    symbolType: '',\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  beforeBrush: function () {\n    var style = this.style;\n    var shape = this.shape; // FIXME\n\n    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n      style.textPosition = ['50%', '40%'];\n      style.textAlign = 'center';\n      style.textVerticalAlign = 'middle';\n    }\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    var symbolType = shape.symbolType;\n    var proxySymbol = symbolBuildProxies[symbolType];\n\n    if (shape.symbolType !== 'none') {\n      if (!proxySymbol) {\n        // Default rect\n        symbolType = 'rect';\n        proxySymbol = symbolBuildProxies[symbolType];\n      }\n\n      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);\n      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n    }\n  }\n}); // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\nfunction symbolPathSetColor(color, innerColor) {\n  if (this.type !== 'image') {\n    var symbolStyle = this.style;\n    var symbolShape = this.shape;\n\n    if (symbolShape && symbolShape.symbolType === 'line') {\n      symbolStyle.stroke = color;\n    } else if (this.__isEmptyBrush) {\n      symbolStyle.stroke = color;\n      symbolStyle.fill = innerColor || '#fff';\n    } else {\n      // FIXME  onlyStroke ?\n      symbolStyle.fill && (symbolStyle.fill = color);\n      symbolStyle.stroke && (symbolStyle.stroke = color);\n    }\n\n    this.dirty(false);\n  }\n}\n/**\n * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n * @param {string} symbolType\n * @param {number} x\n * @param {number} y\n * @param {number} w\n * @param {number} h\n * @param {string} color\n * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,\n *                            for path and image only.\n */\n\n\nfunction createSymbol(symbolType, x, y, w, h, color, keepAspect) {\n  // TODO Support image object, DynamicImage.\n  var isEmpty = symbolType.indexOf('empty') === 0;\n\n  if (isEmpty) {\n    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n  }\n\n  var symbolPath;\n\n  if (symbolType.indexOf('image://') === 0) {\n    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else if (symbolType.indexOf('path://') === 0) {\n    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n  } else {\n    symbolPath = new SymbolClz({\n      shape: {\n        symbolType: symbolType,\n        x: x,\n        y: y,\n        width: w,\n        height: h\n      }\n    });\n  }\n\n  symbolPath.__isEmptyBrush = isEmpty;\n  symbolPath.setColor = symbolPathSetColor;\n  symbolPath.setColor(color);\n  return symbolPath;\n}\n\nexports.createSymbol = createSymbol;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 875\n// module chunks = 1 2 3 141 142 143 144 145","var ORIGIN_METHOD = '\\0__throttleOriginMethod';\nvar RATE = '\\0__throttleRate';\nvar THROTTLE_TYPE = '\\0__throttleType';\n/**\n * @public\n * @param {(Function)} fn\n * @param {number} [delay=0] Unit: ms.\n * @param {boolean} [debounce=false]\n *        true: If call interval less than `delay`, only the last call works.\n *        false: If call interval less than `delay, call works on fixed rate.\n * @return {(Function)} throttled fn.\n */\n\nfunction throttle(fn, delay, debounce) {\n  var currCall;\n  var lastCall = 0;\n  var lastExec = 0;\n  var timer = null;\n  var diff;\n  var scope;\n  var args;\n  var debounceNextCall;\n  delay = delay || 0;\n\n  function exec() {\n    lastExec = new Date().getTime();\n    timer = null;\n    fn.apply(scope, args || []);\n  }\n\n  var cb = function () {\n    currCall = new Date().getTime();\n    scope = this;\n    args = arguments;\n    var thisDelay = debounceNextCall || delay;\n    var thisDebounce = debounceNextCall || debounce;\n    debounceNextCall = null;\n    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n    clearTimeout(timer);\n\n    if (thisDebounce) {\n      timer = setTimeout(exec, thisDelay);\n    } else {\n      if (diff >= 0) {\n        exec();\n      } else {\n        timer = setTimeout(exec, -diff);\n      }\n    }\n\n    lastCall = currCall;\n  };\n  /**\n   * Clear throttle.\n   * @public\n   */\n\n\n  cb.clear = function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  };\n  /**\n   * Enable debounce once.\n   */\n\n\n  cb.debounceNextCall = function (debounceDelay) {\n    debounceNextCall = debounceDelay;\n  };\n\n  return cb;\n}\n/**\n * Create throttle method or update throttle rate.\n *\n * @example\n * ComponentView.prototype.render = function () {\n *     ...\n *     throttle.createOrUpdate(\n *         this,\n *         '_dispatchAction',\n *         this.model.get('throttle'),\n *         'fixRate'\n *     );\n * };\n * ComponentView.prototype.remove = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n * ComponentView.prototype.dispose = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n * @param {number} [rate]\n * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n * @return {Function} throttled function.\n */\n\n\nfunction createOrUpdate(obj, fnAttr, rate, throttleType) {\n  var fn = obj[fnAttr];\n\n  if (!fn) {\n    return;\n  }\n\n  var originFn = fn[ORIGIN_METHOD] || fn;\n  var lastThrottleType = fn[THROTTLE_TYPE];\n  var lastRate = fn[RATE];\n\n  if (lastRate !== rate || lastThrottleType !== throttleType) {\n    if (rate == null || !throttleType) {\n      return obj[fnAttr] = originFn;\n    }\n\n    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');\n    fn[ORIGIN_METHOD] = originFn;\n    fn[THROTTLE_TYPE] = throttleType;\n    fn[RATE] = rate;\n  }\n\n  return fn;\n}\n/**\n * Clear throttle. Example see throttle.createOrUpdate.\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n */\n\n\nfunction clear(obj, fnAttr) {\n  var fn = obj[fnAttr];\n\n  if (fn && fn[ORIGIN_METHOD]) {\n    obj[fnAttr] = fn[ORIGIN_METHOD];\n  }\n}\n\nexports.throttle = throttle;\nexports.createOrUpdate = createOrUpdate;\nexports.clear = clear;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/throttle.js\n// module id = 876\n// module chunks = 1 2 3 141 142 143 144 145","// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1, count2, exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 877\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"../core/util\");\n\nvar Style = require(\"./Style\");\n\nvar Element = require(\"../Element\");\n\nvar RectText = require(\"./mixin/RectText\");\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n\n  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Displayable Painter \n   * Dirty flag. From which painter will determine if this displayable object needs brush\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * true\n   * If ignore drawing of the displayable object. Mouse event will still be triggered\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * zlevelcanvas\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * \n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {number}\n   */\n  progressive: -1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * \n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * \n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   *  x, y \n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   *  x, y \n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * \n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * \n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO,  bind \n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  }\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 878\n// module chunks = 1 2 3 141 142 143 144 145","/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 879\n// module chunks = 1 2 3 141 142 143 144 145","var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      !image && (image = new Image());\n      image.onload = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/image.js\n// module id = 880\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../echarts\");\n\nrequire(\"./axisPointer\");\n\nrequire(\"./tooltip/TooltipModel\");\n\nrequire(\"./tooltip/TooltipView\");\n\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\necharts.registerAction({\n  type: 'showTip',\n  event: 'showTip',\n  update: 'tooltip:manuallyShowTip'\n}, // noop\nfunction () {});\necharts.registerAction({\n  type: 'hideTip',\n  event: 'hideTip',\n  update: 'tooltip:manuallyHideTip'\n}, // noop\nfunction () {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip.js\n// module id = 881\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _model = require(\"../../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/**\n * Complete dimensions by data (guess dimension).\n */\nvar each = zrUtil.each;\nvar isString = zrUtil.isString;\nvar defaults = zrUtil.defaults;\nvar OTHER_DIMS = {\n  tooltip: 1,\n  label: 1,\n  itemName: 1\n};\n/**\n * Complete the dimensions array, by user defined `dimension` and `encode`,\n * and guessing from the data structure.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: []}, ...] can be specified to give names.\n * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n *                      If not specified, extra dim names will be:\n *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<Object>} [{\n *      name: string mandatory,\n *      coordDim: string mandatory,\n *      coordDimIndex: number mandatory,\n *      type: string optional,\n *      tooltipName: string optional,\n *      otherDims: {\n *          tooltip: number optional,\n *          label: number optional\n *      },\n *      isExtraCoord: boolean true or undefined.\n *      other props ...\n * }]\n */\n\nfunction completeDimensions(sysDims, data, opt) {\n  data = data || [];\n  opt = opt || {};\n  sysDims = (sysDims || []).slice();\n  var dimsDef = (opt.dimsDef || []).slice();\n  var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n  var dataDimNameMap = zrUtil.createHashMap();\n  var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate;\n\n  var result = [];\n  var dimCount = opt.dimCount;\n\n  if (dimCount == null) {\n    var value0 = retrieveValue(data[0]);\n    dimCount = Math.max(zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length);\n    each(sysDims, function (sysDimItem) {\n      var sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n    });\n  } // Apply user defined dims (`name` and `type`) and init result.\n\n\n  for (var i = 0; i < dimCount; i++) {\n    var dimDefItem = isString(dimsDef[i]) ? {\n      name: dimsDef[i]\n    } : dimsDef[i] || {};\n    var userDimName = dimDefItem.name;\n    var resultItem = result[i] = {\n      otherDims: {}\n    }; // Name will be applied later for avoiding duplication.\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      // Only if `series.dimensions` is defined in option, tooltipName\n      // will be set, and dimension will be diplayed vertically in\n      // tooltip by default.\n      resultItem.name = resultItem.tooltipName = userDimName;\n      dataDimNameMap.set(userDimName, i);\n    }\n\n    dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n  } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n\n\n  encodeDef.each(function (dataDims, coordDim) {\n    dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      // The input resultDimIdx can be dim name or index.\n      isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        dataDims[coordDimIndex] = resultDimIdx;\n        applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItem, sysDimIndex) {\n    var coordDim;\n    var sysDimItem;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n\n    if (isString(sysDimItem)) {\n      coordDim = sysDimItem;\n      sysDimItem = {};\n    } else {\n      coordDim = sysDimItem.name;\n      sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < result.length && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = result[resultDimIdx];\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n      }\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  }); // Make sure the first extra dim is 'value'.\n\n  var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props.\n\n  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n    var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n    var coordDim = resultItem.coordDim;\n    coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);\n    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));\n    resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');\n  }\n\n  return result;\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (OTHER_DIMS[coordDim]) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n\n  function genName(name, map, fromZero) {\n    if (fromZero || map.get(name) != null) {\n      var i = 0;\n\n      while (map.get(name + i) != null) {\n        i++;\n      }\n\n      name += i;\n    }\n\n    map.set(name, true);\n    return name;\n  }\n} // The rule should not be complex, otherwise user might not\n// be able to known where the data is wrong.\n\n\nvar guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n  for (var i = 0, len = data.length; i < len; i++) {\n    var value = retrieveValue(data[i]);\n\n    if (!zrUtil.isArray(value)) {\n      return false;\n    }\n\n    var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n\n    if (value != null && isFinite(value) && value !== '') {\n      return false;\n    } else if (isString(value) && value !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction retrieveValue(o) {\n  return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;\n}\n\nvar _default = completeDimensions;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 882\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar List = require(\"../../data/List\");\n\nvar completeDimensions = require(\"../../data/helper/completeDimensions\");\n\nvar _model = require(\"../../util/model\");\n\nvar getDataItemValue = _model.getDataItemValue;\nvar converDataValue = _model.converDataValue;\nvar isDataItemOption = _model.isDataItemOption;\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nfunction firstDataNotNull(data) {\n  var i = 0;\n\n  while (i < data.length && data[i] == null) {\n    i++;\n  }\n\n  return data[i];\n}\n\nfunction ifNeedCompleteOrdinalData(data) {\n  var sampleItem = firstDataNotNull(data);\n  return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));\n}\n/**\n * Helper function to create a list from option data\n */\n\n\nfunction createListFromArray(data, seriesModel, ecModel) {\n  // If data is undefined\n  data = data || [];\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var creator = creators[coordSysName];\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var completeDimOpt = {\n    encodeDef: seriesModel.get('encode'),\n    dimsDef: seriesModel.get('dimensions')\n  }; // FIXME\n\n  var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n  var dimensions = axesInfo && axesInfo.dimensions;\n\n  if (!dimensions) {\n    // Get dimensions from registered coordinate system\n    dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n  }\n\n  var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n  var list = new List(dimensions, seriesModel);\n  var nameList = createNameList(axesInfo, data);\n  var categories = {};\n  var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // If any dataItem is like { value: 10 }\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    } // Use dataIndex as ordinal value in categoryAxis\n\n\n    return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n  } : function (itemOpt, dimName, dataIndex, dimIndex) {\n    var value = getDataItemValue(itemOpt);\n    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 }\n\n    if (isDataItemOption(itemOpt)) {\n      list.hasItemOption = true;\n    }\n\n    var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\n    if (categoryAxesModels && categoryAxesModels[dimName]) {\n      // If given value is a category string\n      if (typeof val === 'string') {\n        // Lazy get categories\n        categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();\n        val = zrUtil.indexOf(categories[dimName], val);\n\n        if (val < 0 && !isNaN(val)) {\n          // In case some one write '1', '2' istead of 1, 2\n          val = +val;\n        }\n      }\n    }\n\n    return val;\n  };\n  list.hasItemOption = false;\n  list.initData(data, nameList, dimValueGetter);\n  return list;\n}\n\nfunction isStackable(axisType) {\n  return axisType !== 'category' && axisType !== 'time';\n}\n\nfunction getDimTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\n/**\n * Creaters for each coord system.\n */\n\n\nvar creators = {\n  cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n    var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n      return ecModel.queryComponents({\n        mainType: name,\n        index: seriesModel.get(name + 'Index'),\n        id: seriesModel.get(name + 'Id')\n      })[0];\n    });\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var xAxisType = xAxisModel.get('type');\n    var yAxisType = yAxisModel.get('type');\n    var dimensions = [{\n      name: 'x',\n      type: getDimTypeByAxis(xAxisType),\n      stackable: isStackable(xAxisType)\n    }, {\n      name: 'y',\n      // If two category axes\n      type: getDimTypeByAxis(yAxisType),\n      stackable: isStackable(yAxisType)\n    }];\n    var isXAxisCateogry = xAxisType === 'category';\n    var isYAxisCategory = yAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isXAxisCateogry) {\n      categoryAxesModels.x = xAxisModel;\n    }\n\n    if (isYAxisCategory) {\n      categoryAxesModels.y = yAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n    var singleAxisModel = ecModel.queryComponents({\n      mainType: 'singleAxis',\n      index: seriesModel.get('singleAxisIndex'),\n      id: seriesModel.get('singleAxisId')\n    })[0];\n    var singleAxisType = singleAxisModel.get('type');\n    var isCategory = singleAxisType === 'category';\n    var dimensions = [{\n      name: 'single',\n      type: getDimTypeByAxis(singleAxisType),\n      stackable: isStackable(singleAxisType)\n    }];\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isCategory) {\n      categoryAxesModels.single = singleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isCategory ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  polar: function (data, seriesModel, ecModel, completeDimOpt) {\n    var polarModel = ecModel.queryComponents({\n      mainType: 'polar',\n      index: seriesModel.get('polarIndex'),\n      id: seriesModel.get('polarId')\n    })[0];\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var radiusAxisType = radiusAxisModel.get('type');\n    var angleAxisType = angleAxisModel.get('type');\n    var dimensions = [{\n      name: 'radius',\n      type: getDimTypeByAxis(radiusAxisType),\n      stackable: isStackable(radiusAxisType)\n    }, {\n      name: 'angle',\n      type: getDimTypeByAxis(angleAxisType),\n      stackable: isStackable(angleAxisType)\n    }];\n    var isAngleAxisCateogry = angleAxisType === 'category';\n    var isRadiusAxisCateogry = radiusAxisType === 'category';\n    dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    var categoryAxesModels = {};\n\n    if (isRadiusAxisCateogry) {\n      categoryAxesModels.radius = radiusAxisModel;\n    }\n\n    if (isAngleAxisCateogry) {\n      categoryAxesModels.angle = angleAxisModel;\n    }\n\n    return {\n      dimensions: dimensions,\n      categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,\n      categoryAxesModels: categoryAxesModels\n    };\n  },\n  geo: function (data, seriesModel, ecModel, completeDimOpt) {\n    // TODO Region\n    // \n    return {\n      dimensions: completeDimensions([{\n        name: 'lng'\n      }, {\n        name: 'lat'\n      }], data, completeDimOpt)\n    };\n  }\n};\n\nfunction createNameList(result, data) {\n  var nameList = [];\n  var categoryDim = result && result.dimensions[result.categoryIndex];\n  var categoryAxisModel;\n\n  if (categoryDim) {\n    categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n  }\n\n  if (categoryAxisModel) {\n    // FIXME Two category axis\n    var categories = categoryAxisModel.getCategories();\n\n    if (categories) {\n      var dataLen = data.length; // Ordered data is given explicitly like\n      // [[3, 0.2], [1, 0.3], [2, 0.15]]\n      // or given scatter data,\n      // pick the category\n\n      if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n        nameList = [];\n\n        for (var i = 0; i < dataLen; i++) {\n          nameList[i] = categories[data[i][result.categoryIndex || 0]];\n        }\n      } else {\n        nameList = categories.slice(0);\n      }\n    }\n  }\n\n  return nameList;\n}\n\nvar _default = createListFromArray;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/createListFromArray.js\n// module id = 883\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar barLayoutGrid = require(\"../layout/barGrid\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./bar/BarSeries\");\n\nrequire(\"./bar/BarView\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar.js\n// module id = 884\n// module chunks = 1 2 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nfunction _default(finder, ecModel) {\n  var point = [];\n  var seriesIndex = finder.seriesIndex;\n  var seriesModel;\n\n  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n    return {\n      point: []\n    };\n  }\n\n  var data = seriesModel.getData();\n  var dataIndex = modelUtil.queryDataIndex(data, finder);\n\n  if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n    return {\n      point: []\n    };\n  }\n\n  var el = data.getItemGraphicEl(dataIndex);\n  var coordSys = seriesModel.coordinateSystem;\n\n  if (seriesModel.getTooltipPosition) {\n    point = seriesModel.getTooltipPosition(dataIndex) || [];\n  } else if (coordSys && coordSys.dataToPoint) {\n    point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {\n      return seriesModel.coordDimToDataDim(dim)[0];\n    }), dataIndex, true)) || [];\n  } else if (el) {\n    // Use graphic bounding rect\n    var rect = el.getBoundingRect().clone();\n    rect.applyTransform(el.transform);\n    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n\n  return {\n    point: point,\n    el: el\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/findPointFromSeries.js\n// module id = 885\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar get = modelUtil.makeGetter();\nvar each = zrUtil.each;\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\n\nfunction register(key, api, handler) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  get(zr).records || (get(zr).records = {});\n  initGlobalListeners(zr, api);\n  var record = get(zr).records[key] || (get(zr).records[key] = {});\n  record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n  if (get(zr).initialized) {\n    return;\n  }\n\n  get(zr).initialized = true;\n  useHandler('click', zrUtil.curry(doEnter, 'click'));\n  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);\n\n  useHandler('globalout', onLeave);\n\n  function useHandler(eventType, cb) {\n    zr.on(eventType, function (e) {\n      var dis = makeDispatchAction(api);\n      each(get(zr).records, function (record) {\n        record && cb(record, e, dis.dispatchAction);\n      });\n      dispatchTooltipFinally(dis.pendings, api);\n    });\n  }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n  var showLen = pendings.showTip.length;\n  var hideLen = pendings.hideTip.length;\n  var actuallyPayload;\n\n  if (showLen) {\n    actuallyPayload = pendings.showTip[showLen - 1];\n  } else if (hideLen) {\n    actuallyPayload = pendings.hideTip[hideLen - 1];\n  }\n\n  if (actuallyPayload) {\n    actuallyPayload.dispatchAction = null;\n    api.dispatchAction(actuallyPayload);\n  }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n  record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n  record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n  var pendings = {\n    showTip: [],\n    hideTip: []\n  }; // FIXME\n  // better approach?\n  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n  // So we have to add \"final stage\" to merge those dispatched actions.\n\n  var dispatchAction = function (payload) {\n    var pendingList = pendings[payload.type];\n\n    if (pendingList) {\n      pendingList.push(payload);\n    } else {\n      payload.dispatchAction = dispatchAction;\n      api.dispatchAction(payload);\n    }\n  };\n\n  return {\n    dispatchAction: dispatchAction,\n    pendings: pendings\n  };\n}\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction unregister(key, api) {\n  if (env.node) {\n    return;\n  }\n\n  var zr = api.getZr();\n  var record = (get(zr).records || {})[key];\n\n  if (record) {\n    get(zr).records[key] = null;\n  }\n}\n\nexports.register = register;\nexports.unregister = unregister;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/globalListener.js\n// module id = 886\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar AxisBuilder = require(\"../axis/AxisBuilder\");\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\n\nfunction buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get('label.precision'),\n    formatter: axisPointerModel.get('label.formatter')\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get('axisLine.lineStyle.color');\n  }\n\n  elOption.label = {\n    shape: {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      r: labelModel.get('borderRadius')\n    },\n    position: position.slice(),\n    // TODO: rich\n    style: {\n      text: text,\n      textFont: font,\n      textFill: labelModel.getTextColor(),\n      textPosition: 'inside',\n      fill: bgColor,\n      stroke: labelModel.get('borderColor') || 'transparent',\n      lineWidth: labelModel.get('borderWidth') || 0,\n      shadowBlur: labelModel.get('shadowBlur'),\n      shadowColor: labelModel.get('shadowColor'),\n      shadowOffsetX: labelModel.get('shadowOffsetX'),\n      shadowOffsetY: labelModel.get('shadowOffsetY')\n    },\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\n\n\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which\n  // helps to debounce when when moving label.\n  value, {\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params = {\n      value: axisHelper.getAxisRawValue(axis, value),\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params);\n    }\n  }\n\n  return text;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\n\n\nfunction getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\n\n\nfunction makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}\n\nexports.buildElStyle = buildElStyle;\nexports.buildLabelElOption = buildLabelElOption;\nexports.getValueLabel = getValueLabel;\nexports.getTransformedPosition = getTransformedPosition;\nexports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;\nexports.makeLineShape = makeLineShape;\nexports.makeRectShape = makeRectShape;\nexports.makeSectorShape = makeSectorShape;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/viewHelper.js\n// module id = 887\n// module chunks = 1 2 3 141 142 143 144 145","var _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar PI = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n}\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.labelInterval] Default label interval when label\n *                                     interval from model is null or 'auto'.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'line',\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    })));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);\n          symbol.attr({\n            rotation: item[0],\n            position: item[1],\n            silent: true\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: labelLayout.textAlign,\n      textVerticalAlign: labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction isSilent(axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n/**\n * @static\n */\n\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {\n  if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n    return false;\n  } // FIXME\n  // Have not consider label overlap (if label is too long) yet.\n\n\n  var rawTick;\n  var scale = axis.scale;\n  return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));\n};\n/**\n * @static\n */\n\n\nvar getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n  var interval = model.get('interval');\n\n  if (interval == null || interval == 'auto') {\n    interval = labelInterval;\n  }\n\n  return interval;\n};\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var tickInterval = getInterval(tickModel, opt.labelInterval);\n  var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME\n  // Corresponds to ticksCoords ?\n\n  var ticks = axis.scale.getTicks();\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n  var ticksCnt = ticksCoords.length;\n\n  for (var i = 0; i < ticksCnt; i++) {\n    // Only ordinal scale support tick interval\n    if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {\n      continue;\n    }\n\n    var tickCoord = ticksCoords[i];\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n      // Id for animation\n      anid: 'tick_' + ticks[i],\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    }));\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var ticks = axis.scale.getTicks();\n  var labels = axisModel.getFormattedLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var categoryData = axisModel.get('data');\n  var labelEls = [];\n  var silent = isSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n  each(ticks, function (tickVal, index) {\n    if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {\n      return;\n    }\n\n    var itemLabelModel = labelModel;\n\n    if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n      itemLabelModel = new Model(categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickVal);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var labelStr = axis.scale.getLabel(tickVal);\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickVal,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: labels[index],\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always returns labelStr.\n      // But in interval scale labelStr is like '223,445', which maked\n      // user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = labelStr;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisBuilder.js\n// module id = 888\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar axisPointerModelHelper = require(\"../axisPointer/modelHelper\");\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = echarts.extendComponentView({\n  type: 'axis',\n\n  /**\n   * @private\n   */\n  _axisPointer: null,\n\n  /**\n   * @protected\n   * @type {string}\n   */\n  axisPointerClass: null,\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    // FIXME\n    // This process should proformed after coordinate systems updated\n    // (axis scale updated), and should be performed each time update.\n    // So put it here temporarily, although it is not appropriate to\n    // put a model-writing procedure in `view`.\n    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n    AxisView.superApply(this, 'render', arguments);\n    updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n  },\n\n  /**\n   * Action handler.\n   * @public\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/model/Global} ecModel\n   * @param {module:echarts/ExtensionAPI} api\n   * @param {Object} payload\n   */\n  updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n    updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    var axisPointer = this._axisPointer;\n    axisPointer && axisPointer.remove(api);\n    AxisView.superApply(this, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    disposeAxisPointer(this, api);\n    AxisView.superApply(this, 'dispose', arguments);\n  }\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n  var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n\n  if (!Clazz) {\n    return;\n  }\n\n  var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n  axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n  var axisPointer = axisView._axisPointer;\n  axisPointer && axisPointer.dispose(ecModel, api);\n  axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n  axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n  return type && axisPointerClazz[type];\n};\n\nvar _default = AxisView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisView.js\n// module id = 889\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, labelInterval, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n  opt = opt || {};\n  var grid = gridModel.coordinateSystem;\n  var axis = axisModel.axis;\n  var layout = {};\n  var rawAxisPosition = axis.position;\n  var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n  var axisDim = axis.dim;\n  var rect = grid.getRect();\n  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n  var idx = {\n    left: 0,\n    right: 1,\n    top: 0,\n    bottom: 1,\n    onZero: 2\n  };\n  var axisOffset = axisModel.get('offset') || 0;\n  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n  if (axis.onZero) {\n    var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);\n    var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));\n    posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n  } // Axis position\n\n\n  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation\n\n  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim\n\n  var dirMap = {\n    top: -1,\n    bottom: 1,\n    left: -1,\n    right: 1\n  };\n  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n  layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n  if (axisModel.get('axisTick.inside')) {\n    layout.tickDirection = -layout.tickDirection;\n  }\n\n  if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n    layout.labelDirection = -layout.labelDirection;\n  } // Special label rotation\n\n\n  var labelRotate = axisModel.get('axisLabel.rotate');\n  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // label interval when auto mode.\n\n  layout.labelInterval = axis.getLabelInterval(); // Over splitLine and splitArea\n\n  layout.z2 = 1;\n  return layout;\n}\n\nexports.layout = layout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/cartesianAxisHelper.js\n// module id = 890\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar axisHelper = require(\"./axisHelper\");\n\nvar linearMap = numberUtil.linearMap;\n\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n\nvar normalizedExtent = [0, 1];\n/**\n * @name module:echarts/coord/CartesianAxis\n * @constructor\n */\n\nvar Axis = function (dim, scale, extent) {\n  /**\n   * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n   * @type {string}\n   */\n  this.dim = dim;\n  /**\n   * Axis scale\n   * @type {module:echarts/coord/scale/*}\n   */\n\n  this.scale = scale;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  this._extent = extent || [0, 0];\n  /**\n   * @type {boolean}\n   */\n\n  this.inverse = false;\n  /**\n   * Usually true when axis has a ordinal scale\n   * @type {boolean}\n   */\n\n  this.onBand = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._labelInterval;\n};\n\nAxis.prototype = {\n  constructor: Axis,\n\n  /**\n   * If axis extent contain given coord\n   * @param {number} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  },\n\n  /**\n   * If axis extent contain given data\n   * @param {number} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.contain(this.dataToCoord(data));\n  },\n\n  /**\n   * Get coord extent.\n   * @return {Array.<number>}\n   */\n  getExtent: function () {\n    return this._extent.slice();\n  },\n\n  /**\n   * Get precision used for formatting\n   * @param {Array.<number>} [dataExtent]\n   * @return {number}\n   */\n  getPixelPrecision: function (dataExtent) {\n    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n  },\n\n  /**\n   * Set coord extent\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  },\n\n  /**\n   * Convert data to coord. Data is the rank if it has a ordinal scale\n   * @param {number} data\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  dataToCoord: function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    return linearMap(data, normalizedExtent, extent, clamp);\n  },\n\n  /**\n   * Convert coord to data. Data is the rank if it has a ordinal scale\n   * @param {number} coord\n   * @param  {boolean} clamp\n   * @return {number}\n   */\n  coordToData: function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n\n    var t = linearMap(coord, extent, normalizedExtent, clamp);\n    return this.scale.scale(t);\n  },\n\n  /**\n   * Convert pixel point to data in axis\n   * @param {Array.<number>} point\n   * @param  {boolean} clamp\n   * @return {number} data\n   */\n  pointToData: function (point, clamp) {// Should be implemented in derived class if necessary.\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicksCoords: function (alignWithLabel) {\n    if (this.onBand && !alignWithLabel) {\n      var bands = this.getBands();\n      var coords = [];\n\n      for (var i = 0; i < bands.length; i++) {\n        coords.push(bands[i][0]);\n      }\n\n      if (bands[i - 1]) {\n        coords.push(bands[i - 1][1]);\n      }\n\n      return coords;\n    } else {\n      return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n    }\n  },\n\n  /**\n   * Coords of labels are on the ticks or on the middle of bands\n   * @return {Array.<number>}\n   */\n  getLabelsCoords: function () {\n    return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n  },\n\n  /**\n   * Get bands.\n   *\n   * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n   * |---1---|---2---|---3---|---4---|.\n   *\n   * @return {Array}\n   */\n  // FIXME Situation when labels is on ticks\n  getBands: function () {\n    var extent = this.getExtent();\n    var bands = [];\n    var len = this.scale.count();\n    var start = extent[0];\n    var end = extent[1];\n    var span = end - start;\n\n    for (var i = 0; i < len; i++) {\n      bands.push([span * i / len + start, span * (i + 1) / len + start]);\n    }\n\n    return bands;\n  },\n\n  /**\n   * Get width of band\n   * @return {number}\n   */\n  getBandWidth: function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\n\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  },\n\n  /**\n   * @abstract\n   * @return {boolean} Is horizontal\n   */\n  isHorizontal: null,\n\n  /**\n   * @abstract\n   * @return {number} Get axis rotate, by degree.\n   */\n  getRotate: null,\n\n  /**\n   * Get interval of the axis label.\n   * To get precise result, at least one of `getRotate` and `isHorizontal`\n   * should be implemented.\n   * @return {number}\n   */\n  getLabelInterval: function () {\n    var labelInterval = this._labelInterval;\n\n    if (!labelInterval) {\n      var axisModel = this.model;\n      var labelModel = axisModel.getModel('axisLabel');\n      labelInterval = labelModel.get('interval');\n\n      if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {\n        labelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));\n      }\n\n      this._labelInterval = labelInterval;\n    }\n\n    return labelInterval;\n  }\n};\nvar _default = Axis;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/Axis.js\n// module id = 891\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisHelper = require(\"./axisHelper\");\n\nfunction getName(obj) {\n  if (zrUtil.isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\n\nvar _default = {\n  /**\n   * Format labels\n   * @return {Array.<string>}\n   */\n  getFormattedLabels: function () {\n    return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));\n  },\n\n  /**\n   * Get categories\n   */\n  getCategories: function () {\n    return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n   */\n  getMin: function (origin) {\n    var option = this.option;\n    var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;\n\n    if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min)) {\n      min = this.axis.scale.parse(min);\n    }\n\n    return min;\n  },\n\n  /**\n   * @param {boolean} origin\n   * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n   */\n  getMax: function (origin) {\n    var option = this.option;\n    var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;\n\n    if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max)) {\n      max = this.axis.scale.parse(max);\n    }\n\n    return max;\n  },\n\n  /**\n   * @return {boolean}\n   */\n  getNeedCrossZero: function () {\n    var option = this.option;\n    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;\n  },\n\n  /**\n   * Should be implemented by each axis model if necessary.\n   * @return {module:echarts/model/Component} coordinate system model\n   */\n  getCoordSysModel: zrUtil.noop,\n\n  /**\n   * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n   * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n   */\n  setRange: function (rangeStart, rangeEnd) {\n    this.option.rangeStart = rangeStart;\n    this.option.rangeEnd = rangeEnd;\n  },\n\n  /**\n   * Reset range\n   */\n  resetRange: function () {\n    // rangeStart and rangeEnd is readonly.\n    this.option.rangeStart = this.option.rangeEnd = null;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 892\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 893\n// module chunks = 1 2 3 141 142 143 144 145","var _clazz = require(\"../../util/clazz\");\n\nvar set = _clazz.set;\nvar get = _clazz.get;\nvar _default = {\n  clearColorPalette: function () {\n    set(this, 'colorIdx', 0);\n    set(this, 'colorNameMap', {});\n  },\n  getColorFromPalette: function (name, scope) {\n    scope = scope || this;\n    var colorIdx = get(scope, 'colorIdx') || 0;\n    var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {}); // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n\n    if (colorNameMap.hasOwnProperty(name)) {\n      return colorNameMap[name];\n    }\n\n    var colorPalette = this.get('color', true) || [];\n\n    if (!colorPalette.length) {\n      return;\n    }\n\n    var color = colorPalette[colorIdx];\n\n    if (name) {\n      colorNameMap[name] = color;\n    }\n\n    set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n    return color;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/colorPalette.js\n// module id = 894\n// module chunks = 1 2 3 141 142 143 144 145","var numberUtil = require(\"../util/number\");\n\n/**\n * For testable.\n */\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nfunction intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {\n  var ticks = []; // If interval is 0, return [];\n\n  if (!interval) {\n    return ticks;\n  } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n  var safeLimit = 10000;\n\n  if (extent[0] < niceTickExtent[0]) {\n    ticks.push(extent[0]);\n  }\n\n  var tick = niceTickExtent[0];\n\n  while (tick <= niceTickExtent[1]) {\n    ticks.push(tick); // Avoid rounding error\n\n    tick = roundNumber(tick + interval, intervalPrecision);\n\n    if (tick === ticks[ticks.length - 1]) {\n      // Consider out of safe float point, e.g.,\n      // -3711126.9907707 + 2e-10 === -3711126.9907707\n      break;\n    }\n\n    if (ticks.length > safeLimit) {\n      return [];\n    }\n  } // Consider this case: the last item of ticks is smaller\n  // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n  if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n    ticks.push(extent[1]);\n  }\n\n  return ticks;\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;\nexports.intervalScaleGetTicks = intervalScaleGetTicks;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/helper.js\n// module id = 895\n// module chunks = 1 2 3 141 142 143 144 145","var guid = require(\"./core/guid\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar Transformable = require(\"./mixin/Transformable\");\n\nvar Animatable = require(\"./mixin/Animatable\");\n\nvar zrUtil = require(\"./core/util\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * \n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * \n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender  element  zrender \n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * true\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * (shape) Group \n   * \n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // \n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // \n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 896\n// module chunks = 1 2 3 141 142 143 144 145","var Clip = require(\"./Clip\");\n\nvar color = require(\"../tool/color\");\n\nvar _util = require(\"../core/util\");\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim == 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value == 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * \n   * @param  {number} time ms\n   * @param  {Object} props key-value\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * \n   * @param  {string|Function} [easing]\n   *         {@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * \n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * \n   * @param  {number} time ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * \n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 897\n// module chunks = 1 2 3 141 142 143 144 145","var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 898\n// module chunks = 1 2 3 141 142 143 144 145","var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 899\n// module chunks = 1 2 3 141 142 143 144 145","function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0;\n  return x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 900\n// module chunks = 1 2 3 141 142 143 144 145","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 901\n// module chunks = 1 2 3 141 142 143 144 145","var vec2 = require(\"./vector\");\n\nvar curve = require(\"./curve\");\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * `min``max`\n * @module zrender/core/bbox\n * @param {Array<Object>} points \n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * (p0, p1, p2, p3)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * (p0, p1, p2)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * `min``max`\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 902\n// module chunks = 1 2 3 141 142 143 144 145","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 903\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../config\");\n\nvar debugMode = _config.debugMode;\n\nvar log = function () {};\n\nif (debugMode === 1) {\n  log = function () {\n    for (var k in arguments) {\n      throw new Error(arguments[k]);\n    }\n  };\n} else if (debugMode > 1) {\n  log = function () {\n    for (var k in arguments) {\n      console.log(arguments[k]);\n    }\n  };\n}\n\nvar _default = log;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 904\n// module chunks = 1 2 3 141 142 143 144 145","var Displayable = require(\"./Displayable\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar imageHelper = require(\"./helper/image\");\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // \n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    this.restoreTransform(ctx); // Draw rect text\n\n    if (style.text != null) {\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 905\n// module chunks = 1 2 3 141 142 143 144 145","var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 906\n// module chunks = 1 2 3 141 142 143 144 145","var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n  this.extendFrom(opts, false);\n  this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  }\n\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {module:zrender/graphic/Displayable}\n   */\n  host: null,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {Array.<number>}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only useful in Path and Image element\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image\n   * Only useful in Path and Image element and transformText is false.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation, like [10, 40].\n   * Based on x, y of rect.\n   * Useful in label rotation of circular symbol.\n   * By default, this origin is textPosition.\n   * Can be 'center'.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style;\n    var firstDraw = !prevStyle;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = style[styleName] || prop[1];\n      }\n    }\n\n    if (firstDraw || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (firstDraw || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (firstDraw || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (firstDraw || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 907\n// module chunks = 1 2 3 141 142 143 144 145","var smoothSpline = require(\"./smoothSpline\");\n\nvar smoothBezier = require(\"./smoothBezier\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 908\n// module chunks = 1 2 3 141 142 143 144 145","function buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\nexports.buildPath = buildPath;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 909\n// module chunks = 1 2 3 141 142 143 144 145","var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n  var textPadding = style.textPadding;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n  var needDrawBg = needDrawBackground(style);\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, font);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  }\n\n  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n  }\n\n  for (var i = 0; i < textLines.length; i++) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[i], textX, textY);\n    textFill && ctx.fillText(textLines[i], textX, textY);\n    textY += lineHeight;\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirty) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(outerHeight, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n    ctx.fill();\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n    ctx.stroke();\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  return {\n    baseX: baseX,\n    baseY: baseY,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction setCtx(ctx, prop, value) {\n  // FIXME ??? performance try\n  // if (ctx.__currentValues[prop] !== value) {\n  // ctx[prop] = ctx.__currentValues[prop] = value;\n  ctx[prop] = value; // }\n\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.needDrawText = needDrawText;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/text.js\n// module id = 910\n// module chunks = 1 2 3 141 142 143 144 145","var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * \n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * \n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * \n * , position, rotation, scaletransformtransform\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // \n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // \n\n\n  this.transform = m;\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * transformcontext\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n/**\n * `transform``position`, `rotation`, `scale`\n */\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function () {\n  var m = this.transform;\n\n  if (!m) {\n    return [1, 1];\n  }\n\n  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  return [sx, sy];\n};\n/**\n *  shape \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 911\n// module chunks = 1 2 3 141 142 143 144 145","var guid = require(\"./core/guid\");\n\nvar env = require(\"./core/env\");\n\nvar zrUtil = require(\"./core/util\");\n\nvar Handler = require(\"./Handler\");\n\nvar Storage = require(\"./Storage\");\n\nvar Painter = require(\"./Painter\");\n\nvar Animation = require(\"./animation/Animation\");\n\nvar HandlerProxy = require(\"./dom/HandlerProxy\");\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRendermap\n\n/**\n * @type {string}\n */\n\nvar version = '3.7.4';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; //  storage.delFromStorage, \n  // FIXME ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * \n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * \n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * \n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    this.painter.configLayer(zLevel, config);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = false;\n    this.painter.refresh();\n    /**\n     * Avoid trigger zr.refresh in Element#beforeUpdate hook\n     */\n\n    this._needsRefresh = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    if (this._needsRefresh) {\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      this.refreshHoverImmediately();\n    }\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      this.painter.addHover(el, style);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default']  crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 912\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../echarts\");\n\nrequire(\"./legend/LegendModel\");\n\nrequire(\"./legend/legendAction\");\n\nrequire(\"./legend/LegendView\");\n\nvar legendFilter = require(\"./legend/legendFilter\");\n\nvar Component = require(\"../model/Component\");\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend.js\n// module id = 914\n// module chunks = 1 2 3 141","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 915\n// module chunks = 1 2 3 141 142 143 144 145","var env = require(\"../../core/env\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 916\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/gridSimple.js\n// module id = 917\n// module chunks = 1 2 3 141 142 143 144 145","<template>\r\n    <div ref=\"formHeight\">\r\n        <el-card class=\"box-card__form console-width-12\">\r\n            <!---->\r\n            <el-form class=\"filterform cf\" :label-width=\"conditionWdith\" @keyup.enter.native=\"onSearchButtonClick\">\r\n                <el-form-item v-for=\"(field,index) in fieldValues\" :key=\"index\" :label=\"field.name\">\r\n                    <el-date-picker\r\n                        v-model=\"field.value\"\r\n                        align=\"right\"\r\n                        type=\"date\"\r\n                        format=\"yyyy-MM-dd\"\r\n                        v-if=\"field.type === 'date'\">\r\n                    </el-date-picker>\r\n                    <el-date-picker\r\n                        v-model=\"field.value\"\r\n                        type=\"daterange\"\r\n                        align=\"right\"\r\n                        :picker-options=\"pickerOptions\"\r\n                        v-if=\"field.type === 'daterange'\">\r\n                    </el-date-picker>\r\n                    <!--  -->\r\n                    <el-date-picker\r\n                        class=\"framewidth\"\r\n                        v-model=\"field.value\"\r\n                        type=\"datetimerange\"\r\n                        align=\"right\"\r\n                        format=\"yyyy-MM-dd HH:mm\"\r\n                        :picker-options=\"pickerOptionsI\"\r\n                        v-if=\"field.type === 'datetimerange'\">\r\n                    </el-date-picker>\r\n                    <!--  -->\r\n                    <el-date-picker\r\n                        v-model=\"field.value\"\r\n                        type=\"forbidden_daterange\"\r\n                        align=\"right\"\r\n                        :readonly=\"true\"\r\n                        :picker-options=\"pickerOptions\"\r\n                        v-if=\"field.type === 'forbidden_daterange'\">\r\n                    </el-date-picker>\r\n                    <el-select v-model=\"field.value\" v-if=\"field.type === 'select'\" class=\"framewidth\" clearable>\r\n                        <el-option\r\n                            v-for=\"item in field.label\"\r\n                            :label=\"item.label\"\r\n                            :value=\"item.value\"\r\n                            :key=\"item.value\">\r\n                        </el-option>\r\n                    </el-select>\r\n                    <el-select v-model=\"field.value\" multiple collapse-tags placeholder=\"\" v-if=\"field.type === 'select-many'\" class=\"framewidth\" clearable>\r\n                        <el-option\r\n                            v-for=\"item in field.label\"\r\n                            :label=\"item.label\"\r\n                            :value=\"item.value\"\r\n                            :key=\"item.value\">\r\n                        </el-option>\r\n                    </el-select>\r\n                    <el-input v-model=\"field.value\" :placeholder=\"field.name\" v-if=\"field.type === null || field.type === 'string'\" class=\"framewidth\"></el-input>\r\n                    <el-checkbox v-model=\"field.value\" :label=\"field.label\" :true-label=\"1\"  v-if=\"field.type === 'checkbox'\" class=\"framewidth\"></el-checkbox>\r\n                </el-form-item>\r\n                <el-form-item v-if=\"multi==='A'\" label=\"\">\r\n                    <el-input v-model=\"a_val\" class=\"inputwidth\" v-if=\"multi==='A'\">\r\n                        <el-select v-model=\"a_type\" slot=\"prepend\" class=\"selectwidth\">\r\n                            <el-option label=\"\" :value=\"1\"></el-option>\r\n                            <el-option label=\"\" :value=\"2\"></el-option>\r\n                        </el-select>\r\n                    </el-input>\r\n                </el-form-item>\r\n                <el-form-item>\r\n                    <el-button @click=\"onSearchButtonClick\" class=\"ui-color3\"></el-button>\r\n                    <el-button class=\"ui-color2\" @click=\"onRestButtonClick\"></el-button>\r\n                    <!--<el-button class=\"ui-color2\" @click=\"init\" title=\"\"><i class=\"fa fa-refresh\"></i></el-button>-->\r\n                </el-form-item>\r\n            </el-form>\r\n        </el-card>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        props: {\r\n            multi: {\r\n                type: String\r\n            },\r\n            fields: Array,\r\n            paramVersion: {\r\n                type: String,\r\n                default() {\r\n                    return \"v2\"\r\n                }\r\n            },\r\n            isWithExts: {\r\n                type: Boolean,\r\n                default() {\r\n                    return true\r\n                }\r\n            }\r\n\r\n        },\r\n        mounted() {\r\n            if(this.$store.state.resolution === 'low'){\r\n                this.conditionWdith = '80px';\r\n            }\r\n            this.getDivHeight();\r\n        },\r\n        data() {\r\n            const _this = this;\r\n            return {\r\n                conditionWdith:'85px',\r\n                a_type: 1,\r\n                a_val: null,\r\n                fieldValues : !this.fields ? [] : _.map(this.fields, function (e){ return _.extend({value:null},e) }),\r\n                pickerOptions: {\r\n                    shortcuts: [\r\n                        {\r\n                            text: '',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(0);\r\n                                const end = _this.recentDate(0);\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        }, {\r\n                            text: '',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(1);\r\n                                const end = _this.recentDate(1);\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        },\r\n                        {\r\n                            text: '1',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(-1);\r\n                                const end = _this.recentDate(1);\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        },\r\n                        {\r\n                            text: '2',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(-2);\r\n                                const end = _this.recentDate(2);\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        },\r\n                        {\r\n                            text: '',\r\n                            onClick(picker) {\r\n                                const start = _this.formatDate((new Date().getTime() - 3600 * 1000 * 24 * ((new Date().getDate()) - 1)), 'yy-mm-dd');\r\n                                const end = _this.formatDate((new Date().getTime() - 3600 * 1000 * 24 * ((new Date().getDate()) - 1)) + 3600 * 1000 * 24 *(_this.$store.state.daycount-1), 'yy-mm-dd');\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                pickerOptionsI: {\r\n                    shortcuts: [\r\n                        {\r\n                            text: '',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(0)+' 00:00:00';\r\n                                const end = _this.recentDate(0)+' 23:59:59';\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        }, {\r\n                            text: '',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(1)+' 00:00:00';\r\n                                const end = _this.recentDate(1)+' 23:59:59';\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        },\r\n                        {\r\n                            text: '1',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(-1)+' 00:00:00';\r\n                                const end = _this.recentDate(1)+' 23:59:59';\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        },\r\n                        {\r\n                            text: '2',\r\n                            onClick(picker) {\r\n                                const start = _this.recentDate(-2)+' 00:00:00';\r\n                                const end = _this.recentDate(2)+' 23:59:59';\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        },\r\n                        {\r\n                            text: '',\r\n                            onClick(picker) {\r\n                                const start = _this.formatDate((new Date().getTime() - 3600 * 1000 * 24 * ((new Date().getDate()) - 1)), 'yy-mm-dd')+' 00:00:00';\r\n                                const end = _this.formatDate((new Date().getTime() - 3600 * 1000 * 24 * ((new Date().getDate()) - 1)) + 3600 * 1000 * 24 *(_this.$store.state.daycount-1), 'yy-mm-dd')+' 23:59:59';\r\n                                picker.$emit('pick', [start, end]);\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n        },\r\n        methods: {\r\n            //\r\n            init(){\r\n               this.onSearchButtonClick();\r\n            },\r\n            getDivHeight(){\r\n                return  this.$refs.formHeight.offsetHeight;\r\n            },\r\n            //\r\n            onSearchButtonClick(){\r\n                const _this = this;\r\n                let tmpParmas = {};\r\n                let tmpParmasII = \"\";\r\n                let a='',b='',temp='',c='';\r\n                //this.$emit('toggleSearch');\r\n                //search Object\r\n                _.each(_this.fieldValues, function (node, index) {\r\n                    if(node.fieldName) {\r\n                        tmpParmas[node.fieldName] = node.value instanceof Date ? _this.formatDate(node.value, 'hms') : node.value;\r\n                    }\r\n                    if(node.fieldName === 'dateRange' || 'forbidden_daterange') {\r\n                        if(tmpParmas['dateRange']){\r\n                            tmpParmas['builddate_ge_date'] = _this.formatDate(tmpParmas['dateRange'][0], 'yy-mm-dd');\r\n                            tmpParmas['builddate_le_date'] = _this.formatDate(tmpParmas['dateRange'][1], 'yy-mm-dd');\r\n                        }\r\n                        if (node.fieldName=== 'forbidden_daterange'){\r\n                            if(tmpParmas['forbidden_daterange']){\r\n                                tmpParmas['builddate_ge_date'] = _this.formatDate(tmpParmas['forbidden_daterange'][0], 'yy-mm-dd');\r\n                                tmpParmas['builddate_le_date'] = _this.formatDate(tmpParmas['forbidden_daterange'][1], 'yy-mm-dd');\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                this.$emit('search', this.isWithExts ? { exts : tmpParmas } : tmpParmas );\r\n\r\n                //searchII String\r\n                if(this.fieldValues[0].type === 'daterange'){\r\n                    if(this.a_val){\r\n                        if(this.a_type === 2){\r\n                            c += 'balanceprice_ne='+this.a_val\r\n                        }else{\r\n                            c += 'balanceprice='+this.a_val;\r\n                        }\r\n                    }\r\n                    for(let index=1; index<this.fieldValues.length; index++){\r\n                        if(tmpParmas['datehandle'] && this.fieldValues[0].value){\r\n                            temp = this.fieldValues[index].value||'';\r\n                            a += this.fieldValues[index].fieldName + '=' + temp + '&';\r\n                            b = this.fieldValues[0].label+'_ge_date' + '=' + _this.formatDate(tmpParmas['datehandle'][0], 'yy-mm-dd') + '&'\r\n                                + this.fieldValues[0].label+'_le_date' + '=' + _this.formatDate(tmpParmas['datehandle'][1], 'yy-mm-dd') + '&';\r\n                            if(tmpParmas['datehandle'][0]===null) {\r\n                                temp = this.fieldValues[index].value||'';\r\n                                a += this.fieldValues[index].fieldName + '=' + temp + '&';\r\n                                b = '';\r\n                            }\r\n                        }\r\n                    }\r\n                    b?tmpParmasII = a+b+c:tmpParmasII = a+c;\r\n                }\r\n                if(this.fieldValues[0].type === 'select'){\r\n                    for(let index=2; index<this.fieldValues.length; index++) {\r\n                        temp = this.fieldValues[index].value||'';\r\n                        a += this.fieldValues[index].fieldName + '=' + temp + '&';\r\n                        if(tmpParmas['datehandle'] && this.fieldValues[0].value){\r\n                            b = this.fieldValues[0].value + '_ge_date'+'=' + _this.formatDate(tmpParmas['datehandle'][0], 'ymdhM') + '&'\r\n                                + this.fieldValues[0].value + '_le_date'+'=' + _this.formatDate(tmpParmas['datehandle'][1], 'ymdhM') + '&';\r\n                        }\r\n                    }\r\n                    tmpParmasII = a + b;\r\n                }\r\n                tmpParmasII = (tmpParmasII.substring(tmpParmasII.length-1) === '&')?tmpParmasII.substring(0,tmpParmasII.length-1):tmpParmasII;\r\n                this.$emit('searchII',tmpParmasII );\r\n            },\r\n\r\n            //\r\n            onRestButtonClick(){\r\n                for(let i = 0 ; i < this.fieldValues.length; i ++) {\r\n                    if(this.fieldValues[i].fieldName === 'forbidden_daterange'){\r\n\r\n                    }else{\r\n                         this.fieldValues[i].value = '';\r\n                    }\r\n                }\r\n                this.a_val = '';\r\n                this.$emit('reset');\r\n                this.sdate = null;\r\n                this.edate = null;\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n\r\n<style lang=\"less\" scoped>\r\n    .inputwidth{\r\n        width: 220px;\r\n    }\r\n\r\n    .selectwidth{\r\n      width: 91px;\r\n    }\r\n\r\n    .framewidth{\r\n        width: 220px;\r\n    }\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// ZLCommonSearch.vue?571f8774","<template>\r\n    <div class=\"percent-table\">\r\n        <el-table  border v-loading=\"isLoading\" v-if=\"$store.state.resolution === 'high'\" highlight-current-row @select=\"ischeckbox\" @select-all=\"ischeckbox\" :data=\"tableData\" class=\"adjust-table ui-color4\" :height=\"tabHeight\">\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                type=\"selection\"\r\n                width=\"35\"\r\n                v-if=\"item.type === 'select'\"\r\n                align=\"center\">\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                width=\"55\"\r\n                v-if=\"item.type === 'checkbox'\"\r\n                align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <el-checkbox v-model=\"item.value\" @change=\"checkChange(item.value)\" :disabled=\"scope.$index===0?false:true\"></el-checkbox>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                :width=\"item.width\"\r\n                :prop=\"item.name\"\r\n                :label=\"item.label\"\r\n                v-if=\"item.type === 'normal'\"\r\n                :formatter=\"item.formatter?format:null\"\r\n                align=\"center\"\r\n                sortable\r\n                :filters=\"item.tagFilter?tagSearch:null\"\r\n                :filter-method=\"item.tagFilter?filterTag:null\">\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                :width=\"item.width\"\r\n                :prop=\"item.name\"\r\n                :label=\"item.label\"\r\n                v-if=\"item.type === 'hovernormal'\"\r\n                :formatter=\"item.formatter?format:null\"\r\n                align=\"center\"\r\n                :filters=\"item.tagFilter?tagSearch:null\"\r\n                :filter-method=\"item.tagFilter?filterTag:null\">\r\n                <template slot-scope=\"scope\">\r\n                    <el-tooltip trigger=\"hover\" placement=\"top\" effect=\"dark\">\r\n                        <div slot=\"content\" class=\"name-wrapper\">\r\n                            {{ scope.row.item }}\r\n                        </div>\r\n                        <el-tag class='custom-tag'>{{ scope.row.item }}</el-tag>\r\n                    </el-tooltip>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                :width=\"item.width\"\r\n                 :label=\"item.label\"\r\n                v-if=\"item.type === 'button'\"\r\n                align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <slot v-for=\"b in item.buttons\">\r\n                        <el-button type=\"text\" @click=\"buttonClick(b.name,scope.$index, tableData)\">{{b.label}}</el-button>\r\n                        <!--  <span class=\"color-2\">|&nbsp;</span>-->\r\n                    </slot>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                    v-for=\"(item,index) in arrValues\"\r\n                    :key=\"index\"\r\n                    :width=\"item.width\"\r\n                    :label=\"item.label\"\r\n                    v-if=\"item.type === 'isbutton'\"\r\n                    align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <slot v-for=\"b in item.buttons\">\r\n                        <el-button type=\"text\" @click=\"buttonClickI(b.name,scope.$index, tableData)\" :disabled=\"isbutton\">{{b.label}}</el-button>\r\n                    </slot>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                    v-for=\"(item,index) in arrValues\"\r\n                    :key=\"index\"\r\n                    :width=\"item.width\"\r\n                    :label=\"item.label\"\r\n                    v-if=\"item.type === 'choose'\"\r\n                    align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <slot>\r\n                        <el-checkbox-group v-model=\"scope.row.checkList\">\r\n                            <el-checkbox v-for=\"c in item.chooses\" :key=\"c.name\" :label=\"c.code\">{{c.label}}</el-checkbox>\r\n                        </el-checkbox-group>\r\n                    </slot>\r\n                </template>\r\n            </el-table-column>\r\n        </el-table>\r\n\r\n        <el-table  border v-loading=\"isLoading\"  v-else highlight-current-row @select-all=\"ischeckbox\" @select=\"ischeckbox\" :data=\"tableData\" class=\"ui-color4 adjust-table\" :height=\"tabHeight\">\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                type=\"selection\"\r\n                width=\"35\"\r\n                v-if=\"item.type === 'select'\"\r\n                align=\"center\">\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                width=\"55\"\r\n                v-if=\"item.type === 'checkbox'\"\r\n                align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <el-checkbox v-model=\"item.value\" @change=\"checkChange(item.value)\" :disabled=\"scope.$index===0?false:true\"></el-checkbox>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                :width=\"item.widthI\"\r\n                :prop=\"item.name\"\r\n                :label=\"item.label\"\r\n                v-if=\"item.type === 'normal'\"\r\n                :formatter=\"item.formatter?format:null\"\r\n                align=\"center\"\r\n                sortable\r\n                :filters=\"item.tagFilter?tagSearch:null\"\r\n                :filter-method=\"item.tagFilter?filterTag:null\">\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                v-for=\"(item,index) in arrValues\"\r\n                :key=\"index\"\r\n                :width=\"item.widthI\"\r\n                :label=\"item.label\"\r\n                v-if=\"item.type === 'button'\"\r\n                align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <slot v-for=\"b in item.buttons\">\r\n                        <el-button type=\"text\" @click=\"buttonClick(b.name,scope.$index, tableData)\">{{b.label}}</el-button>\r\n                    </slot>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                    v-for=\"(item,index) in arrValues\"\r\n                    :key=\"index\"\r\n                    :width=\"item.widthI\"\r\n                    :label=\"item.label\"\r\n                    v-if=\"item.type === 'isbutton'\"\r\n                    align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <slot v-for=\"b in item.buttons\">\r\n                        <el-button type=\"text\" @click=\"buttonClick(b.name,scope.$index, tableData)\">{{b.label}}</el-button>\r\n                    </slot>\r\n                </template>\r\n            </el-table-column>\r\n\r\n            <el-table-column\r\n                    v-for=\"(item,index) in arrValues\"\r\n                    :key=\"index\"\r\n                    :width=\"item.widthI\"\r\n                    :label=\"item.label\"\r\n                    v-if=\"item.type === 'choose'\"\r\n                    align=\"center\">\r\n                <template slot-scope=\"scope\">\r\n                    <slot v-for=\"c in item.chooses\">\r\n                        <el-checkbox>{{c.label}}</el-checkbox>\r\n                    </slot>\r\n                </template>\r\n            </el-table-column>\r\n        </el-table>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        props: {\r\n            tableData: Array,\r\n            itemValues: Array,\r\n            tabHeight: Number,\r\n            isLoading:Boolean\r\n        },\r\n        data() {\r\n            return {\r\n                isbutton:false,\r\n                buttontype:null,\r\n                arrValues: this.itemValues||[],\r\n                //tabHeight:610,\r\n                inboxcdData: [],\r\n                tagSearch:[],\r\n                checkList:['0','1']\r\n            }\r\n        },\r\n        watch:{\r\n            'tableData':'getTableData'\r\n        },\r\n\r\n        mounted() {\r\n            this.jungleHeight();\r\n            this.getHeight();\r\n        },\r\n        methods: {\r\n            //\r\n            buttonClick(type,index,data) {\r\n                if(type === 'edit') {\r\n                    this.$emit('show',type,index,data);\r\n                }else if(type === 'delete') {\r\n                    this.$emit('delete',index,data)\r\n                }else if(type === 'editRoute'){\r\n                    this.$emit('editRoute',index,data);\r\n                }else if(type === 'detail') {\r\n                    this.$emit('detail',index,data)\r\n                }else {\r\n                    console.log(type)\r\n                }\r\n            },\r\n\r\n            buttonClickI(type,index,data){\r\n                if(type === 'edit') {\r\n                    this.$emit('show',type,index,data);\r\n                }else if(type === 'delete') {\r\n                    this.$emit('delete',index,data)\r\n                }else if(type === 'editRoute'){\r\n                    this.$emit('editRoute',index,data);\r\n                } else {\r\n                    console.log(type)\r\n                }\r\n            },\r\n            checkChange(row) {\r\n                //this.$emit('ischeckbox',row)\r\n            },\r\n\r\n            //\r\n            getHeight(val){\r\n                //this.tabHeight = val;\r\n            },\r\n\r\n            //\r\n            filterTag(value, row){\r\n                return row.clientname === value;\r\n            },\r\n\r\n            //tagSearch\r\n            getTableData(){\r\n                const _this = this;\r\n                this.tagSearch = [];\r\n                for(let i=0; i<this.tableData.length; i++){\r\n                    this.tagSearch.push({text:this.tableData[i].clientname,value:this.tableData[i].clientname});\r\n                }\r\n                this.tagSearch = _this.reduceObj(this.tagSearch,'text');\r\n            },\r\n\r\n            //\r\n            ischeckbox(row){\r\n                this.inboxcdData = [];\r\n                if(row.length){\r\n                    for(let i=0; i<row.length; i++){\r\n                        this.inboxcdData.push(row[i].inboxcd)\r\n                    }\r\n                }\r\n                this.$emit('getcheckbox',this.inboxcdData)\r\n            },\r\n\r\n            //\r\n            getIsbutton(){\r\n                let tempData = this.tableData;\r\n                // this.isbutton =true;\r\n                // if(this.arrValues[6].buttons.label === ''){\r\n                //     this.isbutton = true;\r\n                // }\r\n                // for(let index in tempData) {\r\n                //     if (tempData[index].status === '') {\r\n                //         this.isbutton =true;\r\n                //         console.log(222)\r\n                //     }else if(tempData[index].status === ''){\r\n                //         //this.tableData[index].status = ''\r\n                //     }else if(tempData[index].status === ''){\r\n                //         //this.tableData[index].status = ''\r\n                //     }\r\n                // }\r\n            },\r\n\r\n            handleSelectionChange(val) {\r\n                console.log(val)\r\n            },\r\n\r\n            jungleHeight(){\r\n                if(this.$store.state.resolution === 'high'){\r\n                    //this.tabHeight = 610;\r\n                }else if(this.$store.state.resolution === 'low'){\r\n                   // this.tabHeight = 460;\r\n                }\r\n            },\r\n\r\n            //-- \r\n            format(row,column,cellValue) {\r\n                return this.formatDate(cellValue,'ymdhM');\r\n            }\r\n        }\r\n    }\r\n</script>\n\n\n// WEBPACK FOOTER //\n// ZLCommonTable.vue?6b44e5eb","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".inputwidth[data-v-39b0517a]{width:220px}.selectwidth[data-v-39b0517a]{width:91px}.framewidth[data-v-39b0517a]{width:220px}\", \"\", {\"version\":3,\"sources\":[\"F:/pc_project/erp-aluminium/yunerp/src/components/ZLCommonSearch.vue\"],\"names\":[],\"mappings\":\"AACA,6BACE,WAAa,CACd,AACD,8BACE,UAAY,CACb,AACD,6BACE,WAAa,CACd\",\"file\":\"ZLCommonSearch.vue\",\"sourcesContent\":[\"\\n.inputwidth[data-v-39b0517a] {\\n  width: 220px;\\n}\\n.selectwidth[data-v-39b0517a] {\\n  width: 91px;\\n}\\n.framewidth[data-v-39b0517a] {\\n  width: 220px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-39b0517a\",\"scoped\":true,\"hasInlineConfig\":false}!./~/less-loader/dist/cjs.js?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/ZLCommonSearch.vue\n// module id = 924\n// module chunks = 2 93 94 95 96 97 99 100","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel']; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\nfunction ExtensionAPI(chartInstance) {\n  zrUtil.each(echartsAPIList, function (name) {\n    this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n  }, this);\n}\n\nvar _default = ExtensionAPI;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/ExtensionAPI.js\n// module id = 925\n// module chunks = 1 2 3 141 142 143 144 145","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 926\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisPointerModelHelper = require(\"./axisPointer/modelHelper\");\n\nvar axisTrigger = require(\"./axisPointer/axisTrigger\");\n\nrequire(\"./axisPointer/AxisPointerModel\");\n\nrequire(\"./axisPointer/AxisPointerView\");\n\nrequire(\"./axisPointer/CartesianAxisPointer\");\n\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\necharts.registerPreprocessor(function (option) {\n  // Always has a global axisPointerModel for default setting.\n  if (option) {\n    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n    var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link\n    // is not set, remain null/undefined, otherwise it will\n    // override existent link setting.\n\n    if (link && !zrUtil.isArray(link)) {\n      option.axisPointer.link = [link];\n    }\n  }\n}); // This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n  // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n  // allAxesInfo should be updated when setOption performed.\n  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);\n}); // Broadcast to all views.\n\necharts.registerAction({\n  type: 'updateAxisPointer',\n  event: 'updateAxisPointer',\n  update: ':updateAxisPointer'\n}, axisTrigger);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer.js\n// module id = 927\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../../echarts\");\n\nvar AxisPointerModel = echarts.extendComponentModel({\n  type: 'axisPointer',\n  coordSysAxesInfo: null,\n  defaultOption: {\n    // 'auto' means that show when triggered by tooltip or handle.\n    show: 'auto',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: null,\n    // set default in AxisPonterView.js\n    zlevel: 0,\n    z: 50,\n    type: 'line',\n    // axispointer triggered by tootip determine snap automatically,\n    // see `modelHelper`.\n    snap: false,\n    triggerTooltip: true,\n    value: null,\n    status: null,\n    // Init value depends on whether handle is used.\n    // [group0, group1, ...]\n    // Each group can be: {\n    //      mapper: function () {},\n    //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n    //      xAxisId: ...,\n    //      yAxisName: ...,\n    //      angleAxisIndex: ...\n    // }\n    // mapper: can be ignored.\n    //      input: {axisInfo, value}\n    //      output: {axisInfo, value}\n    link: [],\n    // Do not set 'auto' here, otherwise global animation: false\n    // will not effect at this axispointer.\n    animation: null,\n    animationDurationUpdate: 200,\n    lineStyle: {\n      color: '#aaa',\n      width: 1,\n      type: 'solid'\n    },\n    shadowStyle: {\n      color: 'rgba(150,150,150,0.3)'\n    },\n    label: {\n      show: true,\n      formatter: null,\n      // string | Function\n      precision: 'auto',\n      // Or a number like 0, 1, 2 ...\n      margin: 3,\n      color: '#fff',\n      padding: [5, 7, 5, 7],\n      backgroundColor: 'auto',\n      // default: axis line color\n      borderColor: null,\n      borderWidth: 0,\n      shadowBlur: 3,\n      shadowColor: '#aaa' // Considering applicability, common style should\n      // better not have shadowOffset.\n      // shadowOffsetX: 0,\n      // shadowOffsetY: 2\n\n    },\n    handle: {\n      show: false,\n      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n      // jshint ignore:line\n      size: 45,\n      // handle margin is from symbol center to axis, which is stable when circular move.\n      margin: 50,\n      // color: '#1b8bbd'\n      // color: '#2f4554'\n      color: '#333',\n      shadowBlur: 3,\n      shadowColor: '#aaa',\n      shadowOffsetX: 0,\n      shadowOffsetY: 2,\n      // For mobile performance\n      throttle: 40\n    }\n  }\n});\nvar _default = AxisPointerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/AxisPointerModel.js\n// module id = 928\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../../echarts\");\n\nvar globalListener = require(\"./globalListener\");\n\nvar AxisPointerView = echarts.extendComponentView({\n  type: 'axisPointer',\n  render: function (globalAxisPointerModel, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable\n    // AxisPointerView to be independent to Tooltip.\n\n    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n        dispatchAction({\n          type: 'updateAxisPointer',\n          currTrigger: currTrigger,\n          x: e && e.offsetX,\n          y: e && e.offsetY\n        });\n      }\n    });\n  },\n\n  /**\n   * @override\n   */\n  remove: function (ecModel, api) {\n    globalListener.unregister(api.getZr(), 'axisPointer');\n    AxisPointerView.superApply(this._model, 'remove', arguments);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function (ecModel, api) {\n    globalListener.unregister('axisPointer', api);\n    AxisPointerView.superApply(this._model, 'dispose', arguments);\n  }\n});\nvar _default = AxisPointerView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/AxisPointerView.js\n// module id = 929\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar clazzUtil = require(\"../../util/clazz\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar axisPointerModelHelper = require(\"./modelHelper\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar get = modelUtil.makeGetter();\nvar clone = zrUtil.clone;\nvar bind = zrUtil.bind;\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\n\nfunction BaseAxisPointer() {}\n\nBaseAxisPointer.prototype = {\n  /**\n   * @private\n   */\n  _group: null,\n\n  /**\n   * @private\n   */\n  _lastGraphicKey: null,\n\n  /**\n   * @private\n   */\n  _handle: null,\n\n  /**\n   * @private\n   */\n  _dragging: false,\n\n  /**\n   * @private\n   */\n  _lastValue: null,\n\n  /**\n   * @private\n   */\n  _lastStatus: null,\n\n  /**\n   * @private\n   */\n  _payloadInfo: null,\n\n  /**\n   * In px, arbitrary value. Do not set too small,\n   * no animation is ok for most cases.\n   * @protected\n   */\n  animationThreshold: 15,\n\n  /**\n   * @implement\n   */\n  render: function (axisModel, axisPointerModel, api, forceRender) {\n    var value = axisPointerModel.get('value');\n    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not\n    // be replaced when user calling setOption in not merge mode.\n\n    this._axisModel = axisModel;\n    this._axisPointerModel = axisPointerModel;\n    this._api = api; // Optimize: `render` will be called repeatly during mouse move.\n    // So it is power consuming if performing `render` each time,\n    // especially on mobile device.\n\n    if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n      return;\n    }\n\n    this._lastValue = value;\n    this._lastStatus = status;\n    var group = this._group;\n    var handle = this._handle;\n\n    if (!status || status === 'hide') {\n      // Do not clear here, for animation better.\n      group && group.hide();\n      handle && handle.hide();\n      return;\n    }\n\n    group && group.show();\n    handle && handle.show(); // Otherwise status is 'show'\n\n    var elOption = {};\n    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.\n\n    var graphicKey = elOption.graphicKey;\n\n    if (graphicKey !== this._lastGraphicKey) {\n      this.clear(api);\n    }\n\n    this._lastGraphicKey = graphicKey;\n    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n    if (!group) {\n      group = this._group = new graphic.Group();\n      this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n      this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n      api.getZr().add(group);\n    } else {\n      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n      this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n    }\n\n    updateMandatoryProps(group, axisPointerModel, true);\n\n    this._renderHandle(value);\n  },\n\n  /**\n   * @implement\n   */\n  remove: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @implement\n   */\n  dispose: function (api) {\n    this.clear(api);\n  },\n\n  /**\n   * @protected\n   */\n  determineAnimation: function (axisModel, axisPointerModel) {\n    var animation = axisPointerModel.get('animation');\n    var axis = axisModel.axis;\n    var isCategoryAxis = axis.type === 'category';\n    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.\n\n    if (!useSnap && !isCategoryAxis) {\n      return false;\n    }\n\n    if (animation === 'auto' || animation == null) {\n      var animationThreshold = this.animationThreshold;\n\n      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n        return true;\n      } // It is important to auto animation when snap used. Consider if there is\n      // a dataZoom, animation will be disabled when too many points exist, while\n      // it will be enabled for better visual effect when little points exist.\n\n\n      if (useSnap) {\n        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n        var axisExtent = axis.getExtent(); // Approximate band width\n\n        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n      }\n\n      return false;\n    }\n\n    return animation === true;\n  },\n\n  /**\n   * add {pointer, label, graphicKey} to elOption\n   * @protected\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.\n  },\n\n  /**\n   * @protected\n   */\n  createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n    var pointerOption = elOption.pointer;\n\n    if (pointerOption) {\n      var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));\n      group.add(pointerEl);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n    if (elOption.label) {\n      var labelEl = get(group).labelEl = new graphic.Rect(clone(elOption.label));\n      group.add(labelEl);\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updatePointerEl: function (group, elOption, updateProps) {\n    var pointerEl = get(group).pointerEl;\n\n    if (pointerEl) {\n      pointerEl.setStyle(elOption.pointer.style);\n      updateProps(pointerEl, {\n        shape: elOption.pointer.shape\n      });\n    }\n  },\n\n  /**\n   * @protected\n   */\n  updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n    var labelEl = get(group).labelEl;\n\n    if (labelEl) {\n      labelEl.setStyle(elOption.label.style);\n      updateProps(labelEl, {\n        // Consider text length change in vertical axis, animation should\n        // be used on shape, otherwise the effect will be weird.\n        shape: elOption.label.shape,\n        position: elOption.label.position\n      });\n      updateLabelShowHide(labelEl, axisPointerModel);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _renderHandle: function (value) {\n    if (this._dragging || !this.updateHandleTransform) {\n      return;\n    }\n\n    var axisPointerModel = this._axisPointerModel;\n\n    var zr = this._api.getZr();\n\n    var handle = this._handle;\n    var handleModel = axisPointerModel.getModel('handle');\n    var status = axisPointerModel.get('status');\n\n    if (!handleModel.get('show') || !status || status === 'hide') {\n      handle && zr.remove(handle);\n      this._handle = null;\n      return;\n    }\n\n    var isInit;\n\n    if (!this._handle) {\n      isInit = true;\n      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {\n        cursor: 'move',\n        draggable: true,\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n        drift: bind(this._onHandleDragMove, this),\n        ondragend: bind(this._onHandleDragEnd, this)\n      });\n      zr.add(handle);\n    }\n\n    updateMandatoryProps(handle, axisPointerModel, false); // update style\n\n    var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position\n\n    var handleSize = handleModel.get('size');\n\n    if (!zrUtil.isArray(handleSize)) {\n      handleSize = [handleSize, handleSize];\n    }\n\n    handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n    this._moveHandleToValue(value, isInit);\n  },\n\n  /**\n   * @private\n   */\n  _moveHandleToValue: function (value, isInit) {\n    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragMove: function (dx, dy) {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    this._dragging = true; // Persistent for throttle.\n\n    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n    this._payloadInfo = trans;\n    handle.stopAnimation();\n    handle.attr(getHandleTransProps(trans));\n    get(handle).lastProp = null;\n\n    this._doDispatchAxisPointer();\n  },\n\n  /**\n   * Throttled method.\n   * @private\n   */\n  _doDispatchAxisPointer: function () {\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var payloadInfo = this._payloadInfo;\n    var axisModel = this._axisModel;\n\n    this._api.dispatchAction({\n      type: 'updateAxisPointer',\n      x: payloadInfo.cursorPoint[0],\n      y: payloadInfo.cursorPoint[1],\n      tooltipOption: payloadInfo.tooltipOption,\n      axesInfo: [{\n        axisDim: axisModel.axis.dim,\n        axisIndex: axisModel.componentIndex\n      }]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _onHandleDragEnd: function (moveAnimation) {\n    this._dragging = false;\n    var handle = this._handle;\n\n    if (!handle) {\n      return;\n    }\n\n    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with\n    // axisPointer. So move handle to align the exact value position when\n    // drag ended.\n\n\n    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle\n    // button, and will be hidden after finger left handle button.\n\n\n    this._api.dispatchAction({\n      type: 'hideTip'\n    });\n  },\n\n  /**\n   * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {number} value\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0}\n   */\n  getHandleTransform: null,\n\n  /**\n   * * Should be implemenented by sub-class if support `handle`.\n   * @protected\n   * @param {Object} transform {position, rotation}\n   * @param {Array.<number>} delta [dx, dy]\n   * @param {module:echarts/model/Model} axisModel\n   * @param {module:echarts/model/Model} axisPointerModel\n   * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n   */\n  updateHandleTransform: null,\n\n  /**\n   * @private\n   */\n  clear: function (api) {\n    this._lastValue = null;\n    this._lastStatus = null;\n    var zr = api.getZr();\n    var group = this._group;\n    var handle = this._handle;\n\n    if (zr && group) {\n      this._lastGraphicKey = null;\n      group && zr.remove(group);\n      handle && zr.remove(handle);\n      this._group = null;\n      this._handle = null;\n      this._payloadInfo = null;\n    }\n  },\n\n  /**\n   * @protected\n   */\n  doClear: function () {// Implemented by sub-class if necessary.\n  },\n\n  /**\n   * @protected\n   * @param {Array.<number>} xy\n   * @param {Array.<number>} wh\n   * @param {number} [xDimIndex=0] or 1\n   */\n  buildLabel: function (xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n      x: xy[xDimIndex],\n      y: xy[1 - xDimIndex],\n      width: wh[xDimIndex],\n      height: wh[1 - xDimIndex]\n    };\n  }\n};\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\nfunction updateProps(animationModel, moveAnimation, el, props) {\n  // Animation optimize.\n  if (!propsEqual(get(el).lastProp, props)) {\n    get(el).lastProp = props;\n    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n  }\n}\n\nfunction propsEqual(lastProps, newProps) {\n  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n    var equals = true;\n    zrUtil.each(newProps, function (item, key) {\n      equals = equals && propsEqual(lastProps[key], item);\n    });\n    return !!equals;\n  } else {\n    return lastProps === newProps;\n  }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n  labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n  return {\n    position: trans.position.slice(),\n    rotation: trans.rotation || 0\n  };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n  var z = axisPointerModel.get('z');\n  var zlevel = axisPointerModel.get('zlevel');\n  group && group.traverse(function (el) {\n    if (el.type !== 'group') {\n      z != null && (el.z = z);\n      zlevel != null && (el.zlevel = zlevel);\n      el.silent = silent;\n    }\n  });\n}\n\nclazzUtil.enableClassExtend(BaseAxisPointer);\nvar _default = BaseAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/BaseAxisPointer.js\n// module id = 930\n// module chunks = 1 2 3 141 142 143 144 145","var graphic = require(\"../../util/graphic\");\n\nvar BaseAxisPointer = require(\"./BaseAxisPointer\");\n\nvar viewHelper = require(\"./viewHelper\");\n\nvar cartesianAxisHelper = require(\"../axis/cartesianAxisHelper\");\n\nvar AxisView = require(\"../axis/AxisView\");\n\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n  /**\n   * @override\n   */\n  makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisPointerType = axisPointerModel.get('type');\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n    if (axisPointerType && axisPointerType !== 'none') {\n      var elStyle = viewHelper.buildElStyle(axisPointerModel);\n      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);\n      pointerOption.style = elStyle;\n      elOption.graphicKey = pointerOption.type;\n      elOption.pointer = pointerOption;\n    }\n\n    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n  },\n\n  /**\n   * @override\n   */\n  getHandleTransform: function (value, axisModel, axisPointerModel) {\n    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n      labelInside: false\n    });\n    layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n    return {\n      position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n    };\n  },\n\n  /**\n   * @override\n   */\n  updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n    var axis = axisModel.axis;\n    var grid = axis.grid;\n    var axisExtent = axis.getGlobalExtent(true);\n    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n    var dimIndex = axis.dim === 'x' ? 0 : 1;\n    var currPosition = transform.position;\n    currPosition[dimIndex] += delta[dimIndex];\n    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n    var cursorPoint = [cursorOtherValue, cursorOtherValue];\n    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.\n\n    var tooltipOptions = [{\n      verticalAlign: 'middle'\n    }, {\n      align: 'center'\n    }];\n    return {\n      position: currPosition,\n      rotation: transform.rotation,\n      cursorPoint: cursorPoint,\n      tooltipOption: tooltipOptions[dimIndex]\n    };\n  }\n});\n\nfunction getCartesian(grid, axis) {\n  var opt = {};\n  opt[axis.dim + 'AxisIndex'] = axis.index;\n  return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n  line: function (axis, pixelValue, otherExtent, elStyle) {\n    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n    graphic.subPixelOptimizeLine({\n      shape: targetShape,\n      style: elStyle\n    });\n    return {\n      type: 'Line',\n      shape: targetShape\n    };\n  },\n  shadow: function (axis, pixelValue, otherExtent, elStyle) {\n    var bandWidth = axis.getBandWidth();\n    var span = otherExtent[1] - otherExtent[0];\n    return {\n      type: 'Rect',\n      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n    };\n  }\n};\n\nfunction getAxisDimIndex(axis) {\n  return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\nvar _default = CartesianAxisPointer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n// module id = 931\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar modelHelper = require(\"./modelHelper\");\n\nvar findPointFromSeries = require(\"./findPointFromSeries\");\n\nvar each = zrUtil.each;\nvar curry = zrUtil.curry;\nvar get = modelUtil.makeGetter();\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\n\nfunction _default(payload, ecModel, api) {\n  var currTrigger = payload.currTrigger;\n  var point = [payload.x, payload.y];\n  var finder = payload;\n  var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending\n  // See #6121. But we are not able to reproduce it yet.\n\n  if (!coordSysAxesInfo) {\n    return;\n  }\n\n  if (illegalPoint(point)) {\n    // Used in the default behavior of `connection`: use the sample seriesIndex\n    // and dataIndex. And also used in the tooltipView trigger.\n    point = findPointFromSeries({\n      seriesIndex: finder.seriesIndex,\n      // Do not use dataIndexInside from other ec instance.\n      // FIXME: auto detect it?\n      dataIndex: finder.dataIndex\n    }, ecModel).point;\n  }\n\n  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n  // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n  // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n  // and dataIndex.\n\n  var inputAxesInfo = finder.axesInfo;\n  var axesInfo = coordSysAxesInfo.axesInfo;\n  var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n  var outputFinder = {};\n  var showValueMap = {};\n  var dataByCoordSys = {\n    list: [],\n    map: {}\n  };\n  var updaters = {\n    showPointer: curry(showPointer, showValueMap),\n    showTooltip: curry(showTooltip, dataByCoordSys)\n  }; // Process for triggered axes.\n\n  each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n    // If a point given, it must be contained by the coordinate system.\n    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n      var axis = axisInfo.axis;\n      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.\n\n      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n        var val = inputAxisInfo && inputAxisInfo.value;\n\n        if (val == null && !isIllegalPoint) {\n          val = axis.pointToData(point);\n        }\n\n        val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n      }\n    });\n  }); // Process for linked axes.\n\n  var linkTriggers = {};\n  each(axesInfo, function (tarAxisInfo, tarKey) {\n    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.\n\n    if (linkGroup && !showValueMap[tarKey]) {\n      each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.\n\n        if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n          var val = srcValItem.value;\n          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n          linkTriggers[tarAxisInfo.key] = val;\n        }\n      });\n    }\n  });\n  each(linkTriggers, function (val, tarKey) {\n    processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n  });\n  updateModelActually(showValueMap, axesInfo, outputFinder);\n  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n  dispatchHighDownActually(axesInfo, dispatchAction, api);\n  return outputFinder;\n}\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n  var axis = axisInfo.axis;\n\n  if (axis.scale.isBlank() || !axis.containData(newValue)) {\n    return;\n  }\n\n  if (!axisInfo.involveSeries) {\n    updaters.showPointer(axisInfo, newValue);\n    return;\n  } // Heavy calculation. So put it after axis.containData checking.\n\n\n  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n  var payloadBatch = payloadInfo.payloadBatch;\n  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.\n  // By defualt use the first involved series data as a sample to connect.\n\n  if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n    zrUtil.extend(outputFinder, payloadBatch[0]);\n  } // If no linkSource input, this process is for collecting link\n  // target, where snap should not be accepted.\n\n\n  if (!dontSnap && axisInfo.snap) {\n    if (axis.containData(snapToValue) && snapToValue != null) {\n      newValue = snapToValue;\n    }\n  }\n\n  updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder); // Tooltip should always be snapToValue, otherwise there will be\n  // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n\n  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n  var axis = axisInfo.axis;\n  var dim = axis.dim;\n  var snapToValue = value;\n  var payloadBatch = [];\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  each(axisInfo.seriesModels, function (series, idx) {\n    var dataDim = series.coordDimToDataDim(dim);\n    var seriesNestestValue;\n    var dataIndices;\n\n    if (series.getAxisTooltipData) {\n      var result = series.getAxisTooltipData(dataDim, value, axis);\n      dataIndices = result.dataIndices;\n      seriesNestestValue = result.nestestValue;\n    } else {\n      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex\n      // when data length is not same.\n      false, axis.type === 'category' ? 0.5 : null);\n\n      if (!dataIndices.length) {\n        return;\n      }\n\n      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n    }\n\n    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n      return;\n    }\n\n    var diff = value - seriesNestestValue;\n    var dist = Math.abs(diff); // Consider category case\n\n    if (dist <= minDist) {\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        snapToValue = seriesNestestValue;\n        payloadBatch.length = 0;\n      }\n\n      each(dataIndices, function (dataIndex) {\n        payloadBatch.push({\n          seriesIndex: series.seriesIndex,\n          dataIndexInside: dataIndex,\n          dataIndex: series.getData().getRawIndex(dataIndex)\n        });\n      });\n    }\n  });\n  return {\n    payloadBatch: payloadBatch,\n    snapToValue: snapToValue\n  };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n  showValueMap[axisInfo.key] = {\n    value: value,\n    payloadBatch: payloadBatch\n  };\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n  var payloadBatch = payloadInfo.payloadBatch;\n  var axis = axisInfo.axis;\n  var axisModel = axis.model;\n  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,\n  // whose length will be used to judge whether dispatch action.\n\n  if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n    return;\n  }\n\n  var coordSysModel = axisInfo.coordSys.model;\n  var coordSysKey = modelHelper.makeKey(coordSysModel);\n  var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n  if (!coordSysItem) {\n    coordSysItem = dataByCoordSys.map[coordSysKey] = {\n      coordSysId: coordSysModel.id,\n      coordSysIndex: coordSysModel.componentIndex,\n      coordSysType: coordSysModel.type,\n      coordSysMainType: coordSysModel.mainType,\n      dataByAxis: []\n    };\n    dataByCoordSys.list.push(coordSysItem);\n  }\n\n  coordSysItem.dataByAxis.push({\n    axisDim: axis.dim,\n    axisIndex: axisModel.componentIndex,\n    axisType: axisModel.type,\n    axisId: axisModel.id,\n    value: value,\n    // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n    // depends that all models have been updated. So it should not be performed\n    // here. Considering axisPointerModel used here is volatile, which is hard\n    // to be retrieve in TooltipView, we prepare parameters here.\n    valueLabelOpt: {\n      precision: axisPointerModel.get('label.precision'),\n      formatter: axisPointerModel.get('label.formatter')\n    },\n    seriesDataIndices: payloadBatch.slice()\n  });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n  var outputAxesInfo = outputFinder.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    var valItem = showValueMap[key];\n\n    if (valItem) {\n      !axisInfo.useHandle && (option.status = 'show');\n      option.value = valItem.value; // For label formatter param and highlight.\n\n      option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n    } // When always show (e.g., handle used), remain\n    // original value and status.\n    else {\n        // If hide, value still need to be set, consider\n        // click legend to toggle axis blank.\n        !axisInfo.useHandle && (option.status = 'hide');\n      } // If status is 'hide', should be no info in payload.\n\n\n    option.status === 'show' && outputAxesInfo.push({\n      axisDim: axisInfo.axis.dim,\n      axisIndex: axisInfo.axis.model.componentIndex,\n      value: option.value\n    });\n  });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n  // Basic logic: If no showTip required, hideTip will be dispatched.\n  if (illegalPoint(point) || !dataByCoordSys.list.length) {\n    dispatchAction({\n      type: 'hideTip'\n    });\n    return;\n  } // In most case only one axis (or event one series is used). It is\n  // convinient to fetch payload.seriesIndex and payload.dataIndex\n  // dirtectly. So put the first seriesIndex and dataIndex of the first\n  // axis on the payload.\n\n\n  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n  dispatchAction({\n    type: 'showTip',\n    escapeConnect: true,\n    x: point[0],\n    y: point[1],\n    tooltipOption: payload.tooltipOption,\n    position: payload.position,\n    dataIndexInside: sampleItem.dataIndexInside,\n    dataIndex: sampleItem.dataIndex,\n    seriesIndex: sampleItem.seriesIndex,\n    dataByCoordSys: dataByCoordSys.list\n  });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n  // FIXME\n  // highlight status modification shoule be a stage of main process?\n  // (Consider confilct (e.g., legend and axisPointer) and setOption)\n  var zr = api.getZr();\n  var highDownKey = 'axisPointerLastHighlights';\n  var lastHighlights = get(zr)[highDownKey] || {};\n  var newHighlights = get(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.\n  // Build hash map and remove duplicate incidentally.\n\n  each(axesInfo, function (axisInfo, key) {\n    var option = axisInfo.axisPointerModel.option;\n    option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n      newHighlights[key] = batchItem;\n    });\n  }); // Diff.\n\n  var toHighlight = [];\n  var toDownplay = [];\n  zrUtil.each(lastHighlights, function (batchItem, key) {\n    !newHighlights[key] && toDownplay.push(batchItem);\n  });\n  zrUtil.each(newHighlights, function (batchItem, key) {\n    !lastHighlights[key] && toHighlight.push(batchItem);\n  });\n  toDownplay.length && api.dispatchAction({\n    type: 'downplay',\n    escapeConnect: true,\n    batch: toDownplay\n  });\n  toHighlight.length && api.dispatchAction({\n    type: 'highlight',\n    escapeConnect: true,\n    batch: toHighlight\n  });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n  for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n    var inputAxisInfo = inputAxesInfo[i];\n\n    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n      return inputAxisInfo;\n    }\n  }\n}\n\nfunction makeMapperParam(axisInfo) {\n  var axisModel = axisInfo.axis.model;\n  var item = {};\n  var dim = item.axisDim = axisInfo.axis.dim;\n  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n  item.axisName = item[dim + 'AxisName'] = axisModel.name;\n  item.axisId = item[dim + 'AxisId'] = axisModel.id;\n  return item;\n}\n\nfunction illegalPoint(point) {\n  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axisPointer/axisTrigger.js\n// module id = 932\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/CartesianAxisView.js\n// module id = 933\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar eventUtil = require(\"zrender/lib/core/event\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar each = zrUtil.each;\nvar toCamelCase = formatUtil.toCamelCase;\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\n\nfunction assembleTransition(duration) {\n  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n  var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;\n  return zrUtil.map(vendors, function (vendorPrefix) {\n    return vendorPrefix + 'transition:' + transitionText;\n  }).join(';');\n}\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\n\n\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n  each(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\n\n\nfunction assembleCssText(tooltipModel) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0.\n\n  transitionDuration && cssText.push(assembleTransition(transitionDuration));\n\n  if (backgroundColor) {\n    if (env.canvasSupported) {\n      cssText.push('background-Color:' + backgroundColor);\n    } else {\n      // for ie\n      cssText.push('background-Color:#' + zrColor.toHex(backgroundColor));\n      cssText.push('filter:alpha(opacity=70)');\n    }\n  } // Border style\n\n\n  each(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = toCamelCase(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  }); // Text style\n\n  cssText.push(assembleFont(textStyleModel)); // Padding\n\n  if (padding != null) {\n    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n  }\n\n  return cssText.join(';') + ';';\n}\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\n\n\nfunction TooltipContent(container, api) {\n  var el = document.createElement('div');\n  var zr = this._zr = api.getZr();\n  this.el = el;\n  this._x = api.getWidth() / 2;\n  this._y = api.getHeight() / 2;\n  container.appendChild(el);\n  this._container = container;\n  this._show = false;\n  /**\n   * @private\n   */\n\n  this._hideTimeout;\n  var self = this;\n\n  el.onmouseenter = function () {\n    // clear the timeout in hideLater and keep showing tooltip\n    if (self._enterable) {\n      clearTimeout(self._hideTimeout);\n      self._show = true;\n    }\n\n    self._inContent = true;\n  };\n\n  el.onmousemove = function (e) {\n    e = e || window.event;\n\n    if (!self._enterable) {\n      // Try trigger zrender event to avoid mouse\n      // in and out shape too frequently\n      var handler = zr.handler;\n      eventUtil.normalizeEvent(container, e, true);\n      handler.dispatch('mousemove', e);\n    }\n  };\n\n  el.onmouseleave = function () {\n    if (self._enterable) {\n      if (self._show) {\n        self.hideLater(self._hideDelay);\n      }\n    }\n\n    self._inContent = false;\n  };\n}\n\nTooltipContent.prototype = {\n  constructor: TooltipContent,\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  _enterable: true,\n\n  /**\n   * Update when tooltip is rendered\n   */\n  update: function () {\n    // FIXME\n    // Move this logic to ec main?\n    var container = this._container;\n    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n    var domStyle = container.style;\n\n    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n      domStyle.position = 'relative';\n    } // Hide the tooltip\n    // PENDING\n    // this.hide();\n\n  },\n  show: function (tooltipModel) {\n    clearTimeout(this._hideTimeout);\n    var el = this.el;\n    el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n    + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');\n    el.style.display = el.innerHTML ? 'block' : 'none';\n    this._show = true;\n  },\n  setContent: function (content) {\n    this.el.innerHTML = content == null ? '' : content;\n  },\n  setEnterable: function (enterable) {\n    this._enterable = enterable;\n  },\n  getSize: function () {\n    var el = this.el;\n    return [el.clientWidth, el.clientHeight];\n  },\n  moveTo: function (x, y) {\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var zr = this._zr;\n    var viewportRootOffset;\n\n    if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n      x += viewportRootOffset.offsetLeft;\n      y += viewportRootOffset.offsetTop;\n    }\n\n    var style = this.el.style;\n    style.left = x + 'px';\n    style.top = y + 'px';\n    this._x = x;\n    this._y = y;\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n    this._show = false;\n  },\n  hideLater: function (time) {\n    if (this._show && !(this._inContent && this._enterable)) {\n      if (time) {\n        this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times\n\n        this._show = false;\n        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  },\n  isShow: function () {\n    return this._show;\n  }\n};\nvar _default = TooltipContent;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 934\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../../echarts\");\n\nvar _default = echarts.extendComponentModel({\n  type: 'tooltip',\n  dependencies: ['axisPointer'],\n  defaultOption: {\n    zlevel: 0,\n    z: 8,\n    show: true,\n    // tooltip\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    // 'single' | 'multipleByCoordSys'\n    //  {Array} | {Function}\n    // position: null\n    // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n    // align: null,\n    // verticalAlign: null,\n    //  content  viewRect  false \n    confine: false,\n    // {string}Template  {Function}\n    // formatter: null\n    showDelay: 0,\n    // ms\n    hideDelay: 100,\n    // s\n    transitionDuration: 0.4,\n    enterable: false,\n    // 0.7\n    backgroundColor: 'rgba(50,50,50,0.7)',\n    // \n    borderColor: '#333',\n    // px4\n    borderRadius: 4,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // Extra css text\n    extraCssText: '',\n    // \n    axisPointer: {\n      // \n      // 'line' | 'shadow' | 'cross'\n      type: 'line',\n      // type  line  tooltip line \n      //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n      //  'auto' cateogry  x \n      //  angle \n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {} // lineStyle and shadowStyle should not be specified here,\n        // otherwise it will always override those styles on option.axisPointer.\n\n      }\n    },\n    textStyle: {\n      color: '#fff',\n      fontSize: 14\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 935\n// module chunks = 1 2 3 141 142 143 144 145","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar TooltipContent = require(\"./TooltipContent\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar findPointFromSeries = require(\"../axisPointer/findPointFromSeries\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar Model = require(\"../../model/Model\");\n\nvar globalListener = require(\"../axisPointer/globalListener\");\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar axisPointerViewHelper = require(\"../axisPointer/viewHelper\");\n\nvar bind = zrUtil.bind;\nvar each = zrUtil.each;\nvar parsePercent = numberUtil.parsePercent;\nvar proxyRect = new graphic.Rect({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\n\nvar _default = echarts.extendComponentView({\n  type: 'tooltip',\n  init: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    var tooltipContent = new TooltipContent(api.getDom(), api);\n    this._tooltipContent = tooltipContent;\n  },\n  render: function (tooltipModel, ecModel, api) {\n    if (env.node) {\n      return;\n    } // Reset\n\n\n    this.group.removeAll();\n    /**\n     * @private\n     * @type {module:echarts/component/tooltip/TooltipModel}\n     */\n\n    this._tooltipModel = tooltipModel;\n    /**\n     * @private\n     * @type {module:echarts/model/Global}\n     */\n\n    this._ecModel = ecModel;\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n\n    this._api = api;\n    /**\n     * Should be cleaned when render.\n     * @private\n     * @type {Array.<Array.<Object>>}\n     */\n\n    this._lastDataByCoordSys = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update();\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n    this._initGlobalListener();\n\n    this._keepShow();\n  },\n  _initGlobalListener: function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  },\n  _keepShow: function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api; // Try to keep the tooltip show when refreshing\n\n    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && tooltipModel.get('triggerOn') !== 'none') {\n      var self = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        self.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self._lastX,\n          y: self._lastY\n        });\n      });\n    }\n  },\n\n  /**\n   * Show tip manually by\n   * dispatchAction({\n   *     type: 'showTip',\n   *     x: 10,\n   *     y: 10\n   * });\n   * Or\n   * dispatchAction({\n   *      type: 'showTip',\n   *      seriesIndex: 0,\n   *      dataIndex or dataIndexInside or name\n   * });\n   *\n   *  TODO Batch\n   */\n  manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env.node) {\n      return;\n    }\n\n    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket\n\n    this._ticket = ''; // When triggered from axisPointer.\n\n    var dataByCoordSys = payload.dataByCoordSys;\n\n    if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.position = [payload.x, payload.y];\n      el.update();\n      el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements.\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        event: {},\n        dataByCoordSys: payload.dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n\n      var pointInfo = findPointFromSeries(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          position: payload.position,\n          target: pointInfo.el,\n          event: {}\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target,\n        event: {}\n      }, dispatchAction);\n    }\n  },\n  manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n\n    if (!this._alwaysShowContent) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n\n    this._lastX = this._lastY = null;\n\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  },\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n    if (!seriesModel) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n    if (tooltipModel.get('trigger') !== 'axis') {\n      return;\n    }\n\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  },\n  _tryShow: function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n\n    if (!tooltipModel) {\n      return;\n    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\n\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } // Always show item tooltip if mouse is on the element with dataIndex\n    else if (el && el.dataIndex != null) {\n        this._lastDataByCoordSys = null;\n\n        this._showSeriesItemTooltip(e, el, dispatchAction);\n      } // Tooltip provided directly. Like legend.\n      else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n  },\n  _showOrMove: function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easyer to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = zrUtil.bind(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  },\n  _showAxisTooltip: function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleDefaultHTML = [];\n    var singleParamsList = [];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n    each(dataByCoordSys, function (itemCoordSys) {\n      // var coordParamList = [];\n      // var coordDefaultHTML = [];\n      // var coordTooltipModel = buildTooltipModel([\n      //     e.tooltipOption,\n      //     itemCoordSys.tooltipOption,\n      //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n      //     globalTooltipModel\n      // ]);\n      // var displayMode = coordTooltipModel.get('displayMode');\n      // var paramsList = displayMode === 'single' ? singleParamsList : [];\n      each(itemCoordSys.dataByAxis, function (item) {\n        var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n        var axisValue = item.value;\n        var seriesDefaultHTML = [];\n\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n\n        var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);\n        zrUtil.each(item.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams.axisDim = item.axisDim;\n          dataParams.axisIndex = item.axisIndex;\n          dataParams.axisType = item.axisType;\n          dataParams.axisId = item.axisId;\n          dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n          dataParams.axisValueLabel = valueLabel;\n\n          if (dataParams) {\n            singleParamsList.push(dataParams);\n            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n          }\n        }); // Default tooltip content\n        // FIXME\n        // (1) shold be the first data which has name?\n        // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\n        var firstLine = valueLabel;\n        singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));\n      });\n    }, this); // In most case, the second axis is shown upper than the first one.\n\n    singleDefaultHTML.reverse();\n    singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n    var positionExpr = e.position;\n\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);\n      }\n    }); // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n\n  },\n  _showSeriesItemTooltip: function (e, el, dispatchAction) {\n    var ecModel = this._ecModel; // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n\n    var seriesIndex = el.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.\n\n    var dataModel = el.dataModel || seriesModel;\n    var dataIndex = el.dataIndex;\n    var dataType = el.dataType;\n    var data = dataModel.getData();\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n    var tooltipTrigger = tooltipModel.get('trigger');\n\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);\n    }); // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n\n\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  },\n  _showComponentItemTooltip: function (e, el, dispatchAction) {\n    var tooltipOpt = el.tooltip;\n\n    if (typeof tooltipOpt === 'string') {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n    }\n\n    var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on cooridinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n\n    this._showOrMove(subTooltipModel, function () {\n      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);\n    }); // If not dispatch showTip, tip may be hide triggered by axis.\n\n\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  },\n  _showTooltipContent: function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\n    // Reset ticket\n    this._ticket = '';\n\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n\n    var tooltipContent = this._tooltipContent;\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n\n    if (formatter && typeof formatter === 'string') {\n      html = formatUtil.formatTpl(formatter, params, true);\n    } else if (typeof formatter === 'function') {\n      var callback = bind(function (cbTicket, html) {\n        if (cbTicket === this._ticket) {\n          tooltipContent.setContent(html);\n\n          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n        }\n      }, this);\n      this._ticket = asyncTicket;\n      html = formatter(params, asyncTicket, callback);\n    }\n\n    tooltipContent.setContent(html);\n    tooltipContent.show(tooltipModel);\n\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  },\n\n  /**\n   * @param  {string|Function|Array.<number>|Object} positionExpr\n   * @param  {number} x Mouse x\n   * @param  {number} y Mouse y\n   * @param  {boolean} confine Whether confine tooltip content in view rect.\n   * @param  {Object|<Array.<Object>} params\n   * @param  {module:zrender/Element} el target element\n   * @param  {module:echarts/ExtensionAPI} api\n   * @return {Array.<number>}\n   */\n  _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n    var viewWidth = this._api.getWidth();\n\n    var viewHeight = this._api.getHeight();\n\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n\n    if (typeof positionExpr === 'function') {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n\n    if (zrUtil.isArray(positionExpr)) {\n      x = parsePercent(positionExpr[0], viewWidth);\n      y = parsePercent(positionExpr[1], viewHeight);\n    } else if (zrUtil.isObject(positionExpr)) {\n      positionExpr.width = contentSize[0];\n      positionExpr.height = contentSize[1];\n      var layoutRect = layoutUtil.getLayoutRect(positionExpr, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null; // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n\n      vAlign = null;\n    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if (typeof positionExpr === 'string' && el) {\n        var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n        x = pos[0];\n        y = pos[1];\n      } else {\n        var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n        x = pos[0];\n        y = pos[1];\n      }\n\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n    if (tooltipModel.get('confine')) {\n      var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n\n    content.moveTo(x, y);\n  },\n  // FIXME\n  // Should we remove this but leave this to user?\n  _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    return !!contentNotChanged;\n  },\n  _hide: function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  },\n  dispose: function (ecModel, api) {\n    if (env.node) {\n      return;\n    }\n\n    this._tooltipContent.hide();\n\n    globalListener.unregister('itemTooltip', api);\n  }\n});\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\n\n\nfunction buildTooltipModel(modelCascade) {\n  var resultModel = modelCascade.pop();\n\n  while (modelCascade.length) {\n    var tooltipOpt = modelCascade.pop();\n\n    if (tooltipOpt) {\n      if (tooltipOpt instanceof Model) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      } // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n\n\n      if (typeof tooltipOpt === 'string') {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n\n      resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n    }\n  }\n\n  return resultModel;\n}\n\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n\n  if (gapH != null) {\n    if (x + width + gapH > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n\n  return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n  var size = getOuterSize(el);\n  var width = size.width;\n  var height = size.height;\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\n\nfunction getOuterSize(el) {\n  var width = el.clientWidth;\n  var height = el.clientHeight; // Consider browser compatibility.\n  // IE8 does not support getComputedStyle.\n\n  if (document.defaultView && document.defaultView.getComputedStyle) {\n    var stl = document.defaultView.getComputedStyle(el);\n\n    if (stl) {\n      width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n      height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var gap = 5;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - gap;\n      break;\n\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + gap;\n      break;\n\n    case 'left':\n      x = rect.x - domWidth - gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n\n    case 'right':\n      x = rect.x + rectWidth + gap;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n\n  return [x, y];\n}\n\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipView.js\n// module id = 936\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // \n  z: 0,\n  // \n  // \n  inverse: false,\n  // \n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // degree\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // \n  nameTextStyle: {},\n  // \n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // \n  axisLine: {\n    // show\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // lineStyle\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // \n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // \n  axisTick: {\n    // show\n    show: true,\n    // grid\n    inside: false,\n    // length\n    length: 5,\n    // lineStyle\n    lineStyle: {\n      width: 1\n    }\n  },\n  // axis.axisLabel\n  axisLabel: {\n    show: true,\n    // grid\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // TEXTSTYLE\n    fontSize: 12\n  },\n  // \n  splitLine: {\n    // show\n    show: true,\n    // lineStylelineStyle\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // \n  splitArea: {\n    // show\n    show: false,\n    // areaStyleareaStyle\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // \n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // \n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // \n  boundaryGap: [0, 0],\n  // ,  'dataMin' \n  // min: null,\n  //  'dataMax' \n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 0_min_max\n  // scale: false,\n  // 5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 937\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 938\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 939\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 940\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 941\n// module chunks = 1 2 3 141 142 143 144 145","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 942\n// module chunks = 1 2 3 141 142 143 144 145","var BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar bbox = require(\"zrender/lib/core/bbox\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar polygonContain = require(\"zrender/lib/contain/polygon\");\n\n/**\n * @module echarts/coord/geo/Region\n */\n\n/**\n * @param {string} name\n * @param {Array} geometries\n * @param {Array.<number>} cp\n */\nfunction Region(name, geometries, cp) {\n  /**\n   * @type {string}\n   * @readOnly\n   */\n  this.name = name;\n  /**\n   * @type {Array.<Array>}\n   * @readOnly\n   */\n\n  this.geometries = geometries;\n\n  if (!cp) {\n    var rect = this.getBoundingRect();\n    cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  } else {\n    cp = [cp[0], cp[1]];\n  }\n  /**\n   * @type {Array.<number>}\n   */\n\n\n  this.center = cp;\n}\n\nRegion.prototype = {\n  constructor: Region,\n  properties: null,\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    var rect = this._rect;\n\n    if (rect) {\n      return rect;\n    }\n\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * @param {<Array.<number>} coord\n   * @return {boolean}\n   */\n  contain: function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n  transformTo: function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  }\n};\nvar _default = Region;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/geo/Region.js\n// module id = 943\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Region = require(\"./Region\");\n\n/**\n * Parse and decode geo json\n * @module echarts/coord/geo/parseGeoJson\n */\nfunction decode(json) {\n  if (!json.UTF8Encoding) {\n    return json;\n  }\n\n  var encodeScale = json.UTF8Scale;\n\n  if (encodeScale == null) {\n    encodeScale = 1024;\n  }\n\n  var features = json.features;\n\n  for (var f = 0; f < features.length; f++) {\n    var feature = features[f];\n    var geometry = feature.geometry;\n    var coordinates = geometry.coordinates;\n    var encodeOffsets = geometry.encodeOffsets;\n\n    for (var c = 0; c < coordinates.length; c++) {\n      var coordinate = coordinates[c];\n\n      if (geometry.type === 'Polygon') {\n        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (var c2 = 0; c2 < coordinate.length; c2++) {\n          var polygon = coordinate[c2];\n          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);\n        }\n      }\n    }\n  } // Has been decoded\n\n\n  json.UTF8Encoding = false;\n  return json;\n}\n\nfunction decodePolygon(coordinate, encodeOffsets, encodeScale) {\n  var result = [];\n  var prevX = encodeOffsets[0];\n  var prevY = encodeOffsets[1];\n\n  for (var i = 0; i < coordinate.length; i += 2) {\n    var x = coordinate.charCodeAt(i) - 64;\n    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding\n\n    x = x >> 1 ^ -(x & 1);\n    y = y >> 1 ^ -(y & 1); // Delta deocding\n\n    x += prevX;\n    y += prevY;\n    prevX = x;\n    prevY = y; // Dequantize\n\n    result.push([x / encodeScale, y / encodeScale]);\n  }\n\n  return result;\n}\n/**\n * @alias module:echarts/coord/geo/parseGeoJson\n * @param {Object} geoJson\n * @return {module:zrender/container/Group}\n */\n\n\nfunction _default(geoJson) {\n  decode(geoJson);\n  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {\n    // Output of mapshaper may have geometry null\n    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;\n  }), function (featureObj) {\n    var properties = featureObj.properties;\n    var geo = featureObj.geometry;\n    var coordinates = geo.coordinates;\n    var geometries = [];\n\n    if (geo.type === 'Polygon') {\n      geometries.push({\n        type: 'polygon',\n        // According to the GeoJSON specification.\n        // First must be exterior, and the rest are all interior(holes).\n        exterior: coordinates[0],\n        interiors: coordinates.slice(1)\n      });\n    }\n\n    if (geo.type === 'MultiPolygon') {\n      zrUtil.each(coordinates, function (item) {\n        if (item[0]) {\n          geometries.push({\n            type: 'polygon',\n            exterior: item[0],\n            interiors: item.slice(1)\n          });\n        }\n      });\n    }\n\n    var region = new Region(properties.name, geometries, properties.cp);\n    region.properties = properties;\n    return region;\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/geo/parseGeoJson.js\n// module id = 944\n// module chunks = 1 2 3 141 142 143 144 145","function defaultKeyGetter(item) {\n  return item;\n}\n/**\n * @param {Array} oldArr\n * @param {Array} newArr\n * @param {Function} oldKeyGetter\n * @param {Function} newKeyGetter\n * @param {Object} [context] Can be visited by this.context in callback.\n */\n\n\nfunction DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {\n  this._old = oldArr;\n  this._new = newArr;\n  this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n  this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n  this.context = context;\n}\n\nDataDiffer.prototype = {\n  constructor: DataDiffer,\n\n  /**\n   * Callback function when add a data\n   */\n  add: function (func) {\n    this._add = func;\n    return this;\n  },\n\n  /**\n   * Callback function when update a data\n   */\n  update: function (func) {\n    this._update = func;\n    return this;\n  },\n\n  /**\n   * Callback function when remove a data\n   */\n  remove: function (func) {\n    this._remove = func;\n    return this;\n  },\n  execute: function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    var i;\n    initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);\n    initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this); // Travel by inverted order to make sure order consistency\n    // when duplicate keys exists (consider newDataIndex.pop() below).\n    // For performance consideration, these code below do not look neat.\n\n    for (i = 0; i < oldArr.length; i++) {\n      var key = oldDataKeyArr[i];\n      var idx = newDataIndexMap[key]; // idx can never be empty array here. see 'set null' logic below.\n\n      if (idx != null) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var len = idx.length;\n\n        if (len) {\n          len === 1 && (newDataIndexMap[key] = null);\n          idx = idx.unshift();\n        } else {\n          newDataIndexMap[key] = null;\n        }\n\n        this._update && this._update(idx, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var key = newDataKeyArr[i];\n\n      if (newDataIndexMap.hasOwnProperty(key)) {\n        var idx = newDataIndexMap[key];\n\n        if (idx == null) {\n          continue;\n        } // idx can never be empty array here. see 'set null' logic above.\n\n\n        if (!idx.length) {\n          this._add && this._add(idx);\n        } else {\n          for (var j = 0, len = idx.length; j < len; j++) {\n            this._add && this._add(idx[j]);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {\n  for (var i = 0; i < arr.length; i++) {\n    // Add prefix to avoid conflict with Object.prototype.\n    var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);\n    var existence = map[key];\n\n    if (existence == null) {\n      keyArr.push(key);\n      map[key] = i;\n    } else {\n      if (!existence.length) {\n        map[key] = existence = [existence];\n      }\n\n      existence.push(i);\n    }\n  }\n}\n\nvar _default = DataDiffer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/DataDiffer.js\n// module id = 945\n// module chunks = 1 2 3 141 142 143 144 145","var zrender = require(\"zrender/lib/zrender\");\n\nexports.zrender = zrender;\n\nvar matrix = require(\"zrender/lib/core/matrix\");\n\nexports.matrix = matrix;\n\nvar vector = require(\"zrender/lib/core/vector\");\n\nexports.vector = vector;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar colorTool = require(\"zrender/lib/tool/color\");\n\nexports.color = colorTool;\n\nvar graphic = require(\"./util/graphic\");\n\nexports.graphic = graphic;\n\nvar numberUtil = require(\"./util/number\");\n\nexports.number = numberUtil;\n\nvar formatUtil = require(\"./util/format\");\n\nexports.format = formatUtil;\n\nvar _throttle = require(\"./util/throttle\");\n\nvar throttle = _throttle.throttle;\nexports.throttle = _throttle.throttle;\n\nvar ecHelper = require(\"./helper\");\n\nexports.helper = ecHelper;\n\nvar _List = require(\"./data/List\");\n\nexports.List = _List;\n\nvar _Model = require(\"./model/Model\");\n\nexports.Model = _Model;\n\nvar _Axis = require(\"./coord/Axis\");\n\nexports.Axis = _Axis;\n\nvar _env = require(\"zrender/lib/core/env\");\n\nexports.env = _env;\n\nvar _parseGeoJson = require(\"./coord/geo/parseGeoJson\");\n\nexports.parseGeoJson = _parseGeoJson;\n\n/**\n * Do not mount those modules on 'src/echarts' for better tree shaking.\n */\nvar ecUtil = {};\nzrUtil.each(['map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge'], function (name) {\n  ecUtil[name] = zrUtil[name];\n});\nexports.util = ecUtil;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/export.js\n// module id = 946\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar createListFromArray = require(\"./chart/helper/createListFromArray\");\n\nvar axisHelper = require(\"./coord/axisHelper\");\n\nvar axisModelCommonMixin = require(\"./coord/axisModelCommonMixin\");\n\nvar Model = require(\"./model/Model\");\n\nvar _completeDimensions = require(\"./data/helper/completeDimensions\");\n\nexports.completeDimensions = _completeDimensions;\n\nvar _symbol = require(\"./util/symbol\");\n\nexports.createSymbol = _symbol.createSymbol;\n\n/**\n * Create a muti dimension List structure from seriesModel.\n * @param  {module:echarts/model/Model} seriesModel\n * @return {module:echarts/data/List} list\n */\nfunction createList(seriesModel) {\n  var data = seriesModel.get('data');\n  return createListFromArray(data, seriesModel, seriesModel.ecModel);\n}\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n */\n\n\n/**\n * Create scale\n * @param {Array.<number>} dataExtent\n * @param {Object|module:echarts/Model} option\n */\nfunction createScale(dataExtent, option) {\n  var axisModel = option;\n\n  if (!(option instanceof Model)) {\n    axisModel = new Model(option);\n    zrUtil.mixin(axisModel, axisModelCommonMixin);\n  }\n\n  var scale = axisHelper.createScaleByModel(axisModel);\n  scale.setExtent(dataExtent[0], dataExtent[1]);\n  axisHelper.niceScaleExtent(scale, axisModel);\n  return scale;\n}\n/**\n * Mixin common methods to axis model,\n *\n * Inlcude methods\n * `getFormattedLabels() => Array.<string>`\n * `getCategories() => Array.<string>`\n * `getMin(origin: boolean) => number`\n * `getMax(origin: boolean) => number`\n * `getNeedCrossZero() => boolean`\n * `setRange(start: number, end: number)`\n * `resetRange()`\n */\n\n\nfunction mixinAxisModelCommonMethods(Model) {\n  zrUtil.mixin(Model, axisModelCommonMixin);\n}\n\nexports.createList = createList;\nexports.createScale = createScale;\nexports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/helper.js\n// module id = 947\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nvar PI = Math.PI;\n/**\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} [opts]\n * @param {string} [opts.text]\n * @param {string} [opts.color]\n * @param {string} [opts.textColor]\n * @return {module:zrender/Element}\n */\n\nfunction _default(api, opts) {\n  opts = opts || {};\n  zrUtil.defaults(opts, {\n    text: 'loading',\n    color: '#c23531',\n    textColor: '#000',\n    maskColor: 'rgba(255, 255, 255, 0.8)',\n    zlevel: 0\n  });\n  var mask = new graphic.Rect({\n    style: {\n      fill: opts.maskColor\n    },\n    zlevel: opts.zlevel,\n    z: 10000\n  });\n  var arc = new graphic.Arc({\n    shape: {\n      startAngle: -PI / 2,\n      endAngle: -PI / 2 + 0.1,\n      r: 10\n    },\n    style: {\n      stroke: opts.color,\n      lineCap: 'round',\n      lineWidth: 5\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  var labelRect = new graphic.Rect({\n    style: {\n      fill: 'none',\n      text: opts.text,\n      textPosition: 'right',\n      textDistance: 10,\n      textFill: opts.textColor\n    },\n    zlevel: opts.zlevel,\n    z: 10001\n  });\n  arc.animateShape(true).when(1000, {\n    endAngle: PI * 3 / 2\n  }).start('circularInOut');\n  arc.animateShape(true).when(1000, {\n    startAngle: PI * 3 / 2\n  }).delay(300).start('circularInOut');\n  var group = new graphic.Group();\n  group.add(arc);\n  group.add(labelRect);\n  group.add(mask); // Inject resize\n\n  group.resize = function () {\n    var cx = api.getWidth() / 2;\n    var cy = api.getHeight() / 2;\n    arc.setShape({\n      cx: cx,\n      cy: cy\n    });\n    var r = arc.shape.r;\n    labelRect.setShape({\n      x: cx - r,\n      y: cy - r,\n      width: r * 2,\n      height: r * 2\n    });\n    mask.setShape({\n      x: 0,\n      y: 0,\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  };\n\n  group.resize();\n  return group;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/loading/default.js\n// module id = 948\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMinin = require(\"./mixin/colorPalette\");\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar each = zrUtil.each;\nvar filter = zrUtil.filter;\nvar map = zrUtil.map;\nvar isArray = zrUtil.isArray;\nvar indexOf = zrUtil.indexOf;\nvar isObject = zrUtil.isObject;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  constructor: GlobalModel,\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = []; //  component model  merge\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);\n      } else {\n        newCptTypes.push(mainType);\n      }\n    }); // FIXME OPTION \n\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n    this._seriesIndices = this._seriesIndices || [];\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel instanceof ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name;\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = zrUtil.extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            zrUtil.extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n      }\n    }\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = zrUtil.clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series'},\n   *     function (model, index) {...}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (zrUtil.isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    this._seriesIndices = createSeriesIndices(filteredSeries);\n  },\n  restoreData: function () {\n    var componentsMap = this._componentsMap;\n    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        component.restoreData();\n      });\n    });\n  }\n});\n/**\n * @inner\n */\n\nfunction mergeTheme(option, theme) {\n  zrUtil.each(theme, function (themeItem, name) {\n    //  component model  merge  model \n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = zrUtil.createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices = null;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  zrUtil.merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!zrUtil.isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(seriesModels) {\n  return map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || [];\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nzrUtil.mixin(GlobalModel, colorPaletteMinin);\nvar _default = GlobalModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Global.js\n// module id = 949\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar ComponentModel = require(\"./Component\");\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\n * TERM EXPLANATIONS:\n *\n * [option]:\n *\n *     An object that contains definitions of components. For example:\n *     var option = {\n *         title: {...},\n *         legend: {...},\n *         visualMap: {...},\n *         series: [\n *             {data: [...]},\n *             {data: [...]},\n *             ...\n *         ]\n *     };\n *\n * [rawOption]:\n *\n *     An object input to echarts.setOption. 'rawOption' may be an\n *     'option', or may be an object contains multi-options. For example:\n *     var option = {\n *         baseOption: {\n *             title: {...},\n *             legend: {...},\n *             series: [\n *                 {data: [...]},\n *                 {data: [...]},\n *                 ...\n *             ]\n *         },\n *         timeline: {...},\n *         options: [\n *             {title: {...}, series: {data: [...]}},\n *             {title: {...}, series: {data: [...]}},\n *             ...\n *         ],\n *         media: [\n *             {\n *                 query: {maxWidth: 320},\n *                 option: {series: {x: 20}, visualMap: {show: false}}\n *             },\n *             {\n *                 query: {minWidth: 320, maxWidth: 720},\n *                 option: {series: {x: 500}, visualMap: {show: true}}\n *             },\n *             {\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\n *             }\n *         ]\n *     };\n *\n * @alias module:echarts/model/OptionManager\n * @param {module:echarts/ExtensionAPI} api\n */\n\nfunction OptionManager(api) {\n  /**\n   * @private\n   * @type {module:echarts/ExtensionAPI}\n   */\n  this._api = api;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._timelineOptions = [];\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n\n  this._mediaList = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._mediaDefault;\n  /**\n   * -1, means default.\n   * empty means no media.\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._currentMediaIndices = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._optionBackup;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\n   * @public\n   * @param {Object} rawOption Raw option.\n   * @param {module:echarts/model/Global} ecModel\n   * @param {Array.<Function>} optionPreprocessorFuncs\n   * @return {Object} Init option\n   */\n  setOption: function (rawOption, optionPreprocessorFuncs) {\n    rawOption = clone(rawOption, true); // FIXME\n    //  timeline options  media baseOption\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\n   * @param {boolean} isRecreate\n   * @return {Object}\n   */\n  mountOption: function (isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // resetclone\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Object}\n   */\n  getTimelineOption: function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Array.<Object>}\n   */\n  getMediaOption: function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // mediaDefault\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/OptionManager.js\n// module id = 950\n// module chunks = 1 2 3 141 142 143 144 145","var platform = ''; // Navigator not exists in node\n\nif (typeof navigator !== 'undefined') {\n  platform = navigator.platform || '';\n}\n\nvar _default = {\n  // \n  // backgroundColor: 'rgba(0,0,0,0)',\n  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n  // \n  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n  // \n  color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],\n  //  Grid \n  // grid: {},\n  // \n  textStyle: {\n    // color: '#000',\n    // decoration: 'none',\n    // PENDING\n    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n    // fontFamily: 'Arial, Verdana, sans-serif',\n    fontSize: 12,\n    fontStyle: 'normal',\n    fontWeight: 'normal'\n  },\n  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n  // Default is source-over\n  blendMode: null,\n  animation: 'auto',\n  animationDuration: 1000,\n  animationDurationUpdate: 300,\n  animationEasing: 'exponentialOut',\n  animationEasingUpdate: 'cubicOut',\n  animationThreshold: 2000,\n  // Configuration for progressive/incremental rendering\n  progressiveThreshold: 3000,\n  progressive: 400,\n  // Threshold of if use single hover layer to optimize.\n  // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n  // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n  // which is unexpected.\n  // see example <echarts/test/heatmap-large.html>.\n  hoverLayerThreshold: 3000,\n  // See: module:echarts/scale/Time\n  useUTC: false\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/globalDefault.js\n// module id = 951\n// module chunks = 1 2 3 141 142 143 144 145","var makeStyleMapper = require(\"./makeStyleMapper\");\n\nvar getAreaStyle = makeStyleMapper([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);\nvar _default = {\n  getAreaStyle: function (excludes, includes) {\n    return getAreaStyle(this, excludes, includes);\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/areaStyle.js\n// module id = 952\n// module chunks = 1 2 3 141 142 143 144 145","var _default = {\n  getBoxLayoutParams: function () {\n    return {\n      left: this.get('left'),\n      top: this.get('top'),\n      right: this.get('right'),\n      bottom: this.get('bottom'),\n      width: this.get('width'),\n      height: this.get('height')\n    };\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/boxLayout.js\n// module id = 953\n// module chunks = 1 2 3 141 142 143 144 145","var makeStyleMapper = require(\"./makeStyleMapper\");\n\nvar getItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);\nvar _default = {\n  getItemStyle: function (excludes, includes) {\n    var style = getItemStyle(this, excludes, includes);\n    var lineDash = this.getBorderLineDash();\n    lineDash && (style.lineDash = lineDash);\n    return style;\n  },\n  getBorderLineDash: function () {\n    var lineType = this.get('borderType');\n    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/itemStyle.js\n// module id = 954\n// module chunks = 1 2 3 141 142 143 144 145","var makeStyleMapper = require(\"./makeStyleMapper\");\n\nvar getLineStyle = makeStyleMapper([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getLineStyle: function (excludes) {\n    var style = getLineStyle(this, excludes);\n    var lineDash = this.getLineDash(style.lineWidth);\n    lineDash && (style.lineDash = lineDash);\n    return style;\n  },\n  getLineDash: function (lineWidth) {\n    if (lineWidth == null) {\n      lineWidth = 1;\n    }\n\n    var lineType = this.get('type');\n    var dotSize = Math.max(lineWidth, 2);\n    var dashSize = lineWidth * 4;\n    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/lineStyle.js\n// module id = 955\n// module chunks = 1 2 3 141 142 143 144 145","var textContain = require(\"zrender/lib/contain/text\");\n\nvar graphicUtil = require(\"../../util/graphic\");\n\nvar PATH_COLOR = ['textStyle', 'color'];\nvar _default = {\n  /**\n   * Get color property or get color from option.textStyle.color\n   * @param {boolean} [isEmphasis]\n   * @return {string}\n   */\n  getTextColor: function (isEmphasis) {\n    var ecModel = this.ecModel;\n    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);\n  },\n\n  /**\n   * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n   * @return {string}\n   */\n  getFont: function () {\n    return graphicUtil.getFont({\n      fontStyle: this.getShallow('fontStyle'),\n      fontWeight: this.getShallow('fontWeight'),\n      fontSize: this.getShallow('fontSize'),\n      fontFamily: this.getShallow('fontFamily')\n    }, this.ecModel);\n  },\n  getTextRect: function (text) {\n    return textContain.getBoundingRect(text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/textStyle.js\n// module id = 956\n// module chunks = 1 2 3 141 142 143 144 145","var _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar isArray = _util.isArray;\nvar isObject = _util.isObject;\n\nvar compatStyle = require(\"./helper/compatStyle\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n// Compatitable with 2.0\nfunction get(opt, path) {\n  path = path.split(',');\n  var obj = opt;\n\n  for (var i = 0; i < path.length; i++) {\n    obj = obj && obj[path[i]];\n\n    if (obj == null) {\n      break;\n    }\n  }\n\n  return obj;\n}\n\nfunction set(opt, path, val, overwrite) {\n  path = path.split(',');\n  var obj = opt;\n  var key;\n\n  for (var i = 0; i < path.length - 1; i++) {\n    key = path[i];\n\n    if (obj[key] == null) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  if (overwrite || obj[path[i]] == null) {\n    obj[path[i]] = val;\n  }\n}\n\nfunction compatLayoutProperties(option) {\n  each(LAYOUT_PROPERTIES, function (prop) {\n    if (prop[0] in option && !(prop[1] in option)) {\n      option[prop[1]] = option[prop[0]];\n    }\n  });\n}\n\nvar LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];\nvar COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];\nvar COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];\n\nfunction _default(option, isTheme) {\n  compatStyle(option, isTheme); // Make sure series array for model initialization.\n\n  option.series = normalizeToArray(option.series);\n  each(option.series, function (seriesOpt) {\n    if (!isObject(seriesOpt)) {\n      return;\n    }\n\n    var seriesType = seriesOpt.type;\n\n    if (seriesType === 'pie' || seriesType === 'gauge') {\n      if (seriesOpt.clockWise != null) {\n        seriesOpt.clockwise = seriesOpt.clockWise;\n      }\n    }\n\n    if (seriesType === 'gauge') {\n      var pointerColor = get(seriesOpt, 'pointer.color');\n      pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n    }\n\n    for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n      if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n        compatLayoutProperties(seriesOpt);\n        break;\n      }\n    }\n  }); // dataRange has changed to visualMap\n\n  if (option.dataRange) {\n    option.visualMap = option.dataRange;\n  }\n\n  each(COMPATITABLE_COMPONENTS, function (componentName) {\n    var options = option[componentName];\n\n    if (options) {\n      if (!isArray(options)) {\n        options = [options];\n      }\n\n      each(options, function (option) {\n        compatLayoutProperties(option);\n      });\n    }\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/backwardCompat.js\n// module id = 957\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];\n\nfunction compatItemStyle(opt) {\n  var itemStyleOpt = opt && opt.itemStyle;\n\n  if (!itemStyleOpt) {\n    return;\n  }\n\n  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n    var styleName = POSSIBLE_STYLES[i];\n    var normalItemStyleOpt = itemStyleOpt.normal;\n    var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\n    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n      opt[styleName] = opt[styleName] || {};\n\n      if (!opt[styleName].normal) {\n        opt[styleName].normal = normalItemStyleOpt[styleName];\n      } else {\n        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n      }\n\n      normalItemStyleOpt[styleName] = null;\n    }\n\n    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n      opt[styleName] = opt[styleName] || {};\n\n      if (!opt[styleName].emphasis) {\n        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n      } else {\n        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n      }\n\n      emphasisItemStyleOpt[styleName] = null;\n    }\n  }\n}\n\nfunction compatTextStyle(opt, propName) {\n  var labelOptSingle = isObject(opt) && opt[propName];\n  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;\n\n  if (textStyle) {\n    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {\n      var propName = modelUtil.TEXT_STYLE_OPTIONS[i];\n\n      if (textStyle.hasOwnProperty(propName)) {\n        labelOptSingle[propName] = textStyle[propName];\n      }\n    }\n  }\n}\n\nfunction compatLabelTextStyle(labelOpt) {\n  if (isObject(labelOpt)) {\n    compatTextStyle(labelOpt, 'normal');\n    compatTextStyle(labelOpt, 'emphasis');\n  }\n}\n\nfunction processSeries(seriesOpt) {\n  if (!isObject(seriesOpt)) {\n    return;\n  }\n\n  compatItemStyle(seriesOpt);\n  compatLabelTextStyle(seriesOpt.label); // treemap\n\n  compatLabelTextStyle(seriesOpt.upperLabel); // graph\n\n  compatLabelTextStyle(seriesOpt.edgeLabel);\n  var markPoint = seriesOpt.markPoint;\n  compatItemStyle(markPoint);\n  compatLabelTextStyle(markPoint && markPoint.label);\n  var markLine = seriesOpt.markLine;\n  compatItemStyle(seriesOpt.markLine);\n  compatLabelTextStyle(markLine && markLine.label);\n  var markArea = seriesOpt.markArea;\n  compatLabelTextStyle(markArea && markArea.label); // For gauge\n\n  compatTextStyle(seriesOpt, 'axisLabel');\n  compatTextStyle(seriesOpt, 'title');\n  compatTextStyle(seriesOpt, 'detail');\n  var data = seriesOpt.data;\n\n  if (data) {\n    for (var i = 0; i < data.length; i++) {\n      compatItemStyle(data[i]);\n      compatLabelTextStyle(data[i] && data[i].label);\n    }\n  } // mark point data\n\n\n  var markPoint = seriesOpt.markPoint;\n\n  if (markPoint && markPoint.data) {\n    var mpData = markPoint.data;\n\n    for (var i = 0; i < mpData.length; i++) {\n      compatItemStyle(mpData[i]);\n      compatLabelTextStyle(mpData[i] && mpData[i].label);\n    }\n  } // mark line data\n\n\n  var markLine = seriesOpt.markLine;\n\n  if (markLine && markLine.data) {\n    var mlData = markLine.data;\n\n    for (var i = 0; i < mlData.length; i++) {\n      if (zrUtil.isArray(mlData[i])) {\n        compatItemStyle(mlData[i][0]);\n        compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);\n        compatItemStyle(mlData[i][1]);\n        compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);\n      } else {\n        compatItemStyle(mlData[i]);\n        compatLabelTextStyle(mlData[i] && mlData[i].label);\n      }\n    }\n  }\n}\n\nfunction toArr(o) {\n  return zrUtil.isArray(o) ? o : o ? [o] : [];\n}\n\nfunction toObj(o) {\n  return (zrUtil.isArray(o) ? o[0] : o) || {};\n}\n\nfunction _default(option, isTheme) {\n  each(toArr(option.series), function (seriesOpt) {\n    isObject(seriesOpt) && processSeries(seriesOpt);\n  });\n  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n  each(axes, function (axisName) {\n    each(toArr(option[axisName]), function (axisOpt) {\n      if (axisOpt) {\n        compatTextStyle(axisOpt, 'axisLabel');\n        compatTextStyle(axisOpt.axisPointer, 'label');\n      }\n    });\n  });\n  each(toArr(option.parallel), function (parallelOpt) {\n    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n    compatTextStyle(parallelAxisDefault, 'axisLabel');\n    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n  });\n  each(toArr(option.calendar), function (calendarOpt) {\n    compatTextStyle(calendarOpt, 'dayLabel');\n    compatTextStyle(calendarOpt, 'monthLabel');\n    compatTextStyle(calendarOpt, 'yearLabel');\n  }); // radar.name.textStyle\n\n  each(toArr(option.radar), function (radarOpt) {\n    compatTextStyle(radarOpt, 'name');\n  });\n  each(toArr(option.geo), function (geoOpt) {\n    if (isObject(geoOpt)) {\n      compatLabelTextStyle(geoOpt.label);\n      each(toArr(geoOpt.regions), function (regionObj) {\n        compatLabelTextStyle(regionObj.label);\n      });\n    }\n  });\n  compatLabelTextStyle(toObj(option.timeline).label);\n  compatTextStyle(toObj(option.axisPointer), 'label');\n  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 958\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar IntervalScale = require(\"./Interval\");\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n// Use some method of IntervalScale\nvar scaleProto = Scale.prototype;\nvar intervalScaleProto = IntervalScale.prototype;\nvar getPrecisionSafe = numberUtil.getPrecisionSafe;\nvar roundingErrorFix = numberUtil.round;\nvar mathFloor = Math.floor;\nvar mathCeil = Math.ceil;\nvar mathPow = Math.pow;\nvar mathLog = Math.log;\nvar LogScale = Scale.extend({\n  type: 'log',\n  base: 10,\n  $constructor: function () {\n    Scale.apply(this, arguments);\n    this._originalScale = new IntervalScale();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getTicks: function () {\n    var originalScale = this._originalScale;\n    var extent = this._extent;\n    var originalExtent = originalScale.getExtent();\n    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n      var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158\n\n      powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n      powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n      return powVal;\n    }, this);\n  },\n\n  /**\n   * @param {number} val\n   * @return {string}\n   */\n  getLabel: intervalScaleProto.getLabel,\n\n  /**\n   * @param  {number} val\n   * @return {number}\n   */\n  scale: function (val) {\n    val = scaleProto.scale.call(this, val);\n    return mathPow(this.base, val);\n  },\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  setExtent: function (start, end) {\n    var base = this.base;\n    start = mathLog(start) / mathLog(base);\n    end = mathLog(end) / mathLog(base);\n    intervalScaleProto.setExtent.call(this, start, end);\n  },\n\n  /**\n   * @return {number} end\n   */\n  getExtent: function () {\n    var base = this.base;\n    var extent = scaleProto.getExtent.call(this);\n    extent[0] = mathPow(base, extent[0]);\n    extent[1] = mathPow(base, extent[1]); // Fix #4158\n\n    var originalScale = this._originalScale;\n    var originalExtent = originalScale.getExtent();\n    originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n    originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n    return extent;\n  },\n\n  /**\n   * @param  {Array.<number>} extent\n   */\n  unionExtent: function (extent) {\n    this._originalScale.unionExtent(extent);\n\n    var base = this.base;\n    extent[0] = mathLog(extent[0]) / mathLog(base);\n    extent[1] = mathLog(extent[1]) / mathLog(base);\n    scaleProto.unionExtent.call(this, extent);\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, true, function (val) {\n      return val > 0;\n    }));\n  },\n\n  /**\n   * Update interval and extent of intervals for nice ticks\n   * @param  {number} [approxTickNum = 10] Given approx tick number\n   */\n  niceTicks: function (approxTickNum) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (span === Infinity || span <= 0) {\n      return;\n    }\n\n    var interval = numberUtil.quantity(span);\n    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.\n\n    if (err <= 0.5) {\n      interval *= 10;\n    } // Interval should be integer\n\n\n    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n      interval *= 10;\n    }\n\n    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n\n  /**\n   * Nice extent.\n   * @override\n   */\n  niceExtent: function (opt) {\n    intervalScaleProto.niceExtent.call(this, opt);\n    var originalScale = this._originalScale;\n    originalScale.__fixMin = opt.fixMin;\n    originalScale.__fixMax = opt.fixMax;\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  LogScale.prototype[methodName] = function (val) {\n    val = mathLog(val) / mathLog(this.base);\n    return scaleProto[methodName].call(this, val);\n  };\n});\n\nLogScale.create = function () {\n  return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n  return roundingErrorFix(val, getPrecisionSafe(originalVal));\n}\n\nvar _default = LogScale;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Log.js\n// module id = 959\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n  init: function (data, extent) {\n    this._data = data;\n    this._extent = extent || [0, data.length - 1];\n  },\n  parse: function (val) {\n    return typeof val === 'string' ? zrUtil.indexOf(this._data, val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function (rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._data[rank] != null;\n  },\n\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function (val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function (val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n\n  /**\n   * @return {Array}\n   */\n  getTicks: function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n\n    return ticks;\n  },\n\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function (n) {\n    return this._data[n];\n  },\n\n  /**\n   * @return {number}\n   */\n  count: function () {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, false));\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\n\nvar _default = OrdinalScale;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Ordinal.js\n// module id = 960\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar scaleHelper = require(\"./helper\");\n\nvar IntervalScale = require(\"./Interval\");\n\n// [About UTC and local time zone]:\n// In most cases, `number.parseDate` will treat input data string as local time\n// (except time zone is specified in time string). And `format.formateTime` returns\n// local time by default. option.useUTC is false by default. This design have\n// concidered these common case:\n// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n// in local time by default.\n// (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n// as its original time, without any time difference.\nvar intervalScaleProto = IntervalScale.prototype;\nvar mathCeil = Math.ceil;\nvar mathFloor = Math.floor;\nvar ONE_SECOND = 1000;\nvar ONE_MINUTE = ONE_SECOND * 60;\nvar ONE_HOUR = ONE_MINUTE * 60;\nvar ONE_DAY = ONE_HOUR * 24; // FIXME \n\nvar bisect = function (a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (a[mid][1] < x) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return lo;\n};\n/**\n * @alias module:echarts/coord/scale/Time\n * @constructor\n */\n\n\nvar TimeScale = IntervalScale.extend({\n  type: 'time',\n\n  /**\n   * @override\n   */\n  getLabel: function (val) {\n    var stepLvl = this._stepLvl;\n    var date = new Date(val);\n    return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n  },\n\n  /**\n   * @override\n   */\n  niceExtent: function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      // Expand extent\n      extent[0] -= ONE_DAY;\n      extent[1] += ONE_DAY;\n    } // If there are no data and extent are [Infinity, -Infinity]\n\n\n    if (extent[1] === -Infinity && extent[0] === Infinity) {\n      var d = new Date();\n      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      extent[0] = extent[1] - ONE_DAY;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n    }\n  },\n\n  /**\n   * @override\n   */\n  niceTicks: function (approxTickNum, minInterval, maxInterval) {\n    approxTickNum = approxTickNum || 10;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n    var approxInterval = span / approxTickNum;\n\n    if (minInterval != null && approxInterval < minInterval) {\n      approxInterval = minInterval;\n    }\n\n    if (maxInterval != null && approxInterval > maxInterval) {\n      approxInterval = maxInterval;\n    }\n\n    var scaleLevelsLen = scaleLevels.length;\n    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n    var interval = level[1]; // Same with interval scale if span is much larger than 1 year\n\n    if (level[0] === 'year') {\n      var yearSpan = span / interval; // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n      // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\n      var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n      interval *= yearStep;\n    }\n\n    var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;\n    var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];\n    scaleHelper.fixExtent(niceExtent, extent);\n    this._stepLvl = level; // Interval will be used in getTicks\n\n    this._interval = interval;\n    this._niceExtent = niceExtent;\n  },\n  parse: function (val) {\n    // val might be float.\n    return +numberUtil.parseDate(val);\n  }\n});\nzrUtil.each(['contain', 'normalize'], function (methodName) {\n  TimeScale.prototype[methodName] = function (val) {\n    return intervalScaleProto[methodName].call(this, this.parse(val));\n  };\n}); // Steps from d3\n\nvar scaleLevels = [// Format              interval\n['hh:mm:ss', ONE_SECOND], // 1s\n['hh:mm:ss', ONE_SECOND * 5], // 5s\n['hh:mm:ss', ONE_SECOND * 10], // 10s\n['hh:mm:ss', ONE_SECOND * 15], // 15s\n['hh:mm:ss', ONE_SECOND * 30], // 30s\n['hh:mm\\nMM-dd', ONE_MINUTE], // 1m\n['hh:mm\\nMM-dd', ONE_MINUTE * 5], // 5m\n['hh:mm\\nMM-dd', ONE_MINUTE * 10], // 10m\n['hh:mm\\nMM-dd', ONE_MINUTE * 15], // 15m\n['hh:mm\\nMM-dd', ONE_MINUTE * 30], // 30m\n['hh:mm\\nMM-dd', ONE_HOUR], // 1h\n['hh:mm\\nMM-dd', ONE_HOUR * 2], // 2h\n['hh:mm\\nMM-dd', ONE_HOUR * 6], // 6h\n['hh:mm\\nMM-dd', ONE_HOUR * 12], // 12h\n['MM-dd\\nyyyy', ONE_DAY], // 1d\n['MM-dd\\nyyyy', ONE_DAY * 2], // 2d\n['MM-dd\\nyyyy', ONE_DAY * 3], // 3d\n['MM-dd\\nyyyy', ONE_DAY * 4], // 4d\n['MM-dd\\nyyyy', ONE_DAY * 5], // 5d\n['MM-dd\\nyyyy', ONE_DAY * 6], // 6d\n['week', ONE_DAY * 7], // 7d\n['MM-dd\\nyyyy', ONE_DAY * 10], // 10d\n['week', ONE_DAY * 14], // 2w\n['week', ONE_DAY * 21], // 3w\n['month', ONE_DAY * 31], // 1M\n['week', ONE_DAY * 42], // 6w\n['month', ONE_DAY * 62], // 2M\n['week', ONE_DAY * 42], // 10w\n['quarter', ONE_DAY * 380 / 4], // 3M\n['month', ONE_DAY * 31 * 4], // 4M\n['month', ONE_DAY * 31 * 5], // 5M\n['half-year', ONE_DAY * 380 / 2], // 6M\n['month', ONE_DAY * 31 * 8], // 8M\n['month', ONE_DAY * 31 * 10], // 10M\n['year', ONE_DAY * 380] // 1Y\n];\n/**\n * @param {module:echarts/model/Model}\n * @return {module:echarts/scale/Time}\n */\n\nTimeScale.create = function (model) {\n  return new TimeScale({\n    useUTC: model.ecModel.get('useUTC')\n  });\n};\n\nvar _default = TimeScale;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Time.js\n// module id = 961\n// module chunks = 1 2 3 141 142 143 144 145","var Group = require(\"zrender/lib/container/Group\");\n\nvar componentUtil = require(\"../util/component\");\n\nvar clazzUtil = require(\"../util/clazz\");\n\nvar Component = function () {\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n  this.group = new Group();\n  /**\n   * @type {string}\n   * @readOnly\n   */\n\n  this.uid = componentUtil.getUID('viewComponent');\n};\n\nComponent.prototype = {\n  constructor: Component,\n  init: function (ecModel, api) {},\n  render: function (componentModel, ecModel, api, payload) {},\n  dispose: function () {}\n};\nvar componentProto = Component.prototype;\n\ncomponentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {// Do nothing;\n}; // Enable Component.extend.\n\n\nclazzUtil.enableClassExtend(Component); // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\nclazzUtil.enableClassManagement(Component, {\n  registerWhenExtend: true\n});\nvar _default = Component;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Component.js\n// module id = 962\n// module chunks = 1 2 3 141 142 143 144 145","var Gradient = require(\"zrender/lib/graphic/Gradient\");\n\nfunction _default(ecModel) {\n  function encodeColor(seriesModel) {\n    var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n    var data = seriesModel.getData();\n    var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n    || seriesModel.getColorFromPalette(seriesModel.get('name')); // Default color\n    // FIXME Set color function or use the platte color\n\n    data.setVisual('color', color); // Only visible series has each data be visual encoded\n\n    if (!ecModel.isSeriesFiltered(seriesModel)) {\n      if (typeof color === 'function' && !(color instanceof Gradient)) {\n        data.each(function (idx) {\n          data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));\n        });\n      } // itemStyle in each data item\n\n\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var color = itemModel.get(colorAccessPath, true);\n\n        if (color != null) {\n          data.setItemVisual(idx, 'color', color);\n        }\n      });\n    }\n  }\n\n  ecModel.eachRawSeries(encodeColor);\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/seriesColor.js\n// module id = 963\n// module chunks = 1 2 3 141 142 143 144 145","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-39b0517a\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/less-loader/dist/cjs.js?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./ZLCommonSearch.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"7f807ae8\", content, true, {});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-39b0517a\",\"scoped\":true,\"hasInlineConfig\":false}!./~/less-loader/dist/cjs.js?{\"sourceMap\":true}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/components/ZLCommonSearch.vue\n// module id = 964\n// module chunks = 2 93 94 95 96 97 99 100","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-39b0517a\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!less-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./ZLCommonSearch.vue\")\n}\nvar Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./ZLCommonSearch.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-39b0517a\\\",\\\"hasScoped\\\":true}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./ZLCommonSearch.vue\"),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  \"data-v-39b0517a\",\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/ZLCommonSearch.vue\n// module id = 965\n// module chunks = 2 93 94 95 96 97 99 100","var Component = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./ZLCommonTable.vue\"),\n  /* template */\n  require(\"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-bac2cffa\\\",\\\"hasScoped\\\":false}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./ZLCommonTable.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/ZLCommonTable.vue\n// module id = 966\n// module chunks = 2 96 97 98 99 100 101 157","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    ref: \"formHeight\"\n  }, [_c('el-card', {\n    staticClass: \"box-card__form console-width-12\"\n  }, [_c('el-form', {\n    staticClass: \"filterform cf\",\n    attrs: {\n      \"label-width\": _vm.conditionWdith\n    },\n    nativeOn: {\n      \"keyup\": function($event) {\n        if (!('button' in $event) && _vm._k($event.keyCode, \"enter\", 13, $event.key, \"Enter\")) { return null; }\n        return _vm.onSearchButtonClick($event)\n      }\n    }\n  }, [_vm._l((_vm.fieldValues), function(field, index) {\n    return _c('el-form-item', {\n      key: index,\n      attrs: {\n        \"label\": field.name\n      }\n    }, [(field.type === 'date') ? _c('el-date-picker', {\n      attrs: {\n        \"align\": \"right\",\n        \"type\": \"date\",\n        \"format\": \"yyyy-MM-dd\"\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'daterange') ? _c('el-date-picker', {\n      attrs: {\n        \"type\": \"daterange\",\n        \"align\": \"right\",\n        \"picker-options\": _vm.pickerOptions\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'datetimerange') ? _c('el-date-picker', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"type\": \"datetimerange\",\n        \"align\": \"right\",\n        \"format\": \"yyyy-MM-dd HH:mm\",\n        \"picker-options\": _vm.pickerOptionsI\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'forbidden_daterange') ? _c('el-date-picker', {\n      attrs: {\n        \"type\": \"forbidden_daterange\",\n        \"align\": \"right\",\n        \"readonly\": true,\n        \"picker-options\": _vm.pickerOptions\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'select') ? _c('el-select', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"clearable\": \"\"\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }, _vm._l((field.label), function(item) {\n      return _c('el-option', {\n        key: item.value,\n        attrs: {\n          \"label\": item.label,\n          \"value\": item.value\n        }\n      })\n    }), 1) : _vm._e(), _vm._v(\" \"), (field.type === 'select-many') ? _c('el-select', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"multiple\": \"\",\n        \"collapse-tags\": \"\",\n        \"placeholder\": \"\",\n        \"clearable\": \"\"\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }, _vm._l((field.label), function(item) {\n      return _c('el-option', {\n        key: item.value,\n        attrs: {\n          \"label\": item.label,\n          \"value\": item.value\n        }\n      })\n    }), 1) : _vm._e(), _vm._v(\" \"), (field.type === null || field.type === 'string') ? _c('el-input', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"placeholder\": field.name\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e(), _vm._v(\" \"), (field.type === 'checkbox') ? _c('el-checkbox', {\n      staticClass: \"framewidth\",\n      attrs: {\n        \"label\": field.label,\n        \"true-label\": 1\n      },\n      model: {\n        value: (field.value),\n        callback: function($$v) {\n          _vm.$set(field, \"value\", $$v)\n        },\n        expression: \"field.value\"\n      }\n    }) : _vm._e()], 1)\n  }), _vm._v(\" \"), (_vm.multi === 'A') ? _c('el-form-item', {\n    attrs: {\n      \"label\": \"\"\n    }\n  }, [(_vm.multi === 'A') ? _c('el-input', {\n    staticClass: \"inputwidth\",\n    model: {\n      value: (_vm.a_val),\n      callback: function($$v) {\n        _vm.a_val = $$v\n      },\n      expression: \"a_val\"\n    }\n  }, [_c('el-select', {\n    staticClass: \"selectwidth\",\n    attrs: {\n      \"slot\": \"prepend\"\n    },\n    slot: \"prepend\",\n    model: {\n      value: (_vm.a_type),\n      callback: function($$v) {\n        _vm.a_type = $$v\n      },\n      expression: \"a_type\"\n    }\n  }, [_c('el-option', {\n    attrs: {\n      \"label\": \"\",\n      \"value\": 1\n    }\n  }), _vm._v(\" \"), _c('el-option', {\n    attrs: {\n      \"label\": \"\",\n      \"value\": 2\n    }\n  })], 1)], 1) : _vm._e()], 1) : _vm._e(), _vm._v(\" \"), _c('el-form-item', [_c('el-button', {\n    staticClass: \"ui-color3\",\n    on: {\n      \"click\": _vm.onSearchButtonClick\n    }\n  }, [_vm._v(\"\")]), _vm._v(\" \"), _c('el-button', {\n    staticClass: \"ui-color2\",\n    on: {\n      \"click\": _vm.onRestButtonClick\n    }\n  }, [_vm._v(\"\")])], 1)], 2)], 1)], 1)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-39b0517a\",\"hasScoped\":true}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/ZLCommonSearch.vue\n// module id = 967\n// module chunks = 2 93 94 95 96 97 99 100","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"percent-table\"\n  }, [(_vm.$store.state.resolution === 'high') ? _c('el-table', {\n    directives: [{\n      name: \"loading\",\n      rawName: \"v-loading\",\n      value: (_vm.isLoading),\n      expression: \"isLoading\"\n    }],\n    staticClass: \"adjust-table ui-color4\",\n    attrs: {\n      \"border\": \"\",\n      \"highlight-current-row\": \"\",\n      \"data\": _vm.tableData,\n      \"height\": _vm.tabHeight\n    },\n    on: {\n      \"select\": _vm.ischeckbox,\n      \"select-all\": _vm.ischeckbox\n    }\n  }, [_vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'select') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"type\": \"selection\",\n        \"width\": \"35\",\n        \"align\": \"center\"\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'checkbox') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": \"55\",\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_c('el-checkbox', {\n            attrs: {\n              \"disabled\": scope.$index === 0 ? false : true\n            },\n            on: {\n              \"change\": function($event) {\n                _vm.checkChange(item.value)\n              }\n            },\n            model: {\n              value: (item.value),\n              callback: function($$v) {\n                _vm.$set(item, \"value\", $$v)\n              },\n              expression: \"item.value\"\n            }\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'normal') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"prop\": item.name,\n        \"label\": item.label,\n        \"formatter\": item.formatter ? _vm.format : null,\n        \"align\": \"center\",\n        \"sortable\": \"\",\n        \"filters\": item.tagFilter ? _vm.tagSearch : null,\n        \"filter-method\": item.tagFilter ? _vm.filterTag : null\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'hovernormal') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"prop\": item.name,\n        \"label\": item.label,\n        \"formatter\": item.formatter ? _vm.format : null,\n        \"align\": \"center\",\n        \"filters\": item.tagFilter ? _vm.tagSearch : null,\n        \"filter-method\": item.tagFilter ? _vm.filterTag : null\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_c('el-tooltip', {\n            attrs: {\n              \"trigger\": \"hover\",\n              \"placement\": \"top\",\n              \"effect\": \"dark\"\n            }\n          }, [_c('div', {\n            staticClass: \"name-wrapper\",\n            attrs: {\n              \"slot\": \"content\"\n            },\n            slot: \"content\"\n          }, [_vm._v(\"\\n                        \" + _vm._s(scope.row.item) + \"\\n                    \")]), _vm._v(\" \"), _c('el-tag', {\n            staticClass: \"custom-tag\"\n          }, [_vm._v(_vm._s(scope.row.item))])], 1)]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'button') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\"\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClick(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'isbutton') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\",\n                \"disabled\": _vm.isbutton\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClickI(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'choose') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.width,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._t(\"default\", [_c('el-checkbox-group', {\n            model: {\n              value: (scope.row.checkList),\n              callback: function($$v) {\n                _vm.$set(scope.row, \"checkList\", $$v)\n              },\n              expression: \"scope.row.checkList\"\n            }\n          }, _vm._l((item.chooses), function(c) {\n            return _c('el-checkbox', {\n              key: c.name,\n              attrs: {\n                \"label\": c.code\n              }\n            }, [_vm._v(_vm._s(c.label))])\n          }), 1)])]\n        }\n      }])\n    }) : _vm._e()\n  })], 2) : _c('el-table', {\n    directives: [{\n      name: \"loading\",\n      rawName: \"v-loading\",\n      value: (_vm.isLoading),\n      expression: \"isLoading\"\n    }],\n    staticClass: \"ui-color4 adjust-table\",\n    attrs: {\n      \"border\": \"\",\n      \"highlight-current-row\": \"\",\n      \"data\": _vm.tableData,\n      \"height\": _vm.tabHeight\n    },\n    on: {\n      \"select-all\": _vm.ischeckbox,\n      \"select\": _vm.ischeckbox\n    }\n  }, [_vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'select') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"type\": \"selection\",\n        \"width\": \"35\",\n        \"align\": \"center\"\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'checkbox') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": \"55\",\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_c('el-checkbox', {\n            attrs: {\n              \"disabled\": scope.$index === 0 ? false : true\n            },\n            on: {\n              \"change\": function($event) {\n                _vm.checkChange(item.value)\n              }\n            },\n            model: {\n              value: (item.value),\n              callback: function($$v) {\n                _vm.$set(item, \"value\", $$v)\n              },\n              expression: \"item.value\"\n            }\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'normal') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"prop\": item.name,\n        \"label\": item.label,\n        \"formatter\": item.formatter ? _vm.format : null,\n        \"align\": \"center\",\n        \"sortable\": \"\",\n        \"filters\": item.tagFilter ? _vm.tagSearch : null,\n        \"filter-method\": item.tagFilter ? _vm.filterTag : null\n      }\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'button') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\"\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClick(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'isbutton') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.buttons), function(b) {\n            return _vm._t(\"default\", [_c('el-button', {\n              attrs: {\n                \"type\": \"text\"\n              },\n              on: {\n                \"click\": function($event) {\n                  _vm.buttonClick(b.name, scope.$index, _vm.tableData)\n                }\n              }\n            }, [_vm._v(_vm._s(b.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  }), _vm._v(\" \"), _vm._l((_vm.arrValues), function(item, index) {\n    return (item.type === 'choose') ? _c('el-table-column', {\n      key: index,\n      attrs: {\n        \"width\": item.widthI,\n        \"label\": item.label,\n        \"align\": \"center\"\n      },\n      scopedSlots: _vm._u([{\n        key: \"default\",\n        fn: function(scope) {\n          return [_vm._l((item.chooses), function(c) {\n            return _vm._t(\"default\", [_c('el-checkbox', [_vm._v(_vm._s(c.label))])])\n          })]\n        }\n      }])\n    }) : _vm._e()\n  })], 2)], 1)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-bac2cffa\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/ZLCommonTable.vue\n// module id = 968\n// module chunks = 2 96 97 98 99 100 101 157","var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which\n  };\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = proxy; // Attach handler\n\n  proxy.handler = this;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  Draggable.call(this);\n  util.each(handlerNames, function (name) {\n    proxy.on && proxy.on(name, this[name], this);\n  }, this);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n    var element = event.toElement || event.relatedTarget;\n    var innerDom;\n\n    do {\n      element = element && element.parentNode;\n    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));\n\n    !innerDom && this.trigger('globalout', {\n      event: event\n    });\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * cursor style\n   * @param {string} [cursorStyle='default']  crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * \n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} \n   * @param {string} eventName \n   * @param {Object} event \n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      //  zrender \n      this.trigger(eventName, eventPacket); // \n      //  click  dispose painter \n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] == 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n    var hovered = this.findHover(event.zrX, event.zrY);\n    var hoveredTarget = hovered.target;\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mosueup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 969\n// module chunks = 1 2 3 141 142 143 144 145","var util = require(\"./core/util\");\n\nvar _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = require(\"./graphic/Style\");\n\nvar Pattern = require(\"./graphic/Pattern\");\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * dom\n *\n * @inner\n * @param {string} id dom id \n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style; // append~\n\n  newDomStyle.position = 'absolute';\n  newDomStyle.left = 0;\n  newDomStyle.top = 0;\n  newDomStyle.width = width + 'px';\n  newDomStyle.height = height + 'px';\n  newDom.width = width * dpr;\n  newDom.height = height * dpr; // id\n\n  newDom.setAttribute('data-zr-dom-id', id);\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // \n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0;\n    domStyle['margin'] = 0;\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * \n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * \n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * alpha\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  elCount: 0,\n  __dirty: true,\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.__currentValues = {};\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n    this.ctxBack.__currentValues = {};\n\n    if (dpr != 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n    domStyle.width = width + 'px';\n    domStyle.height = height + 'px';\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr != 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} clearAll Clear all with out motion blur\n   */\n  clear: function (clearAll) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor) {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 970\n// module chunks = 1 2 3 141 142 143 144 145","var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar log = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction preProcessLayer(layer) {\n  layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n  if (layer.__unusedCount == 1) {\n    layer.clear();\n  }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  if (clipPaths == prevClipPaths) {\n    // Can both be null or undefined\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // \n\n  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root \n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * \n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @type {private}\n   */\n\n  this._layerConfig = {};\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    if (opts.width != null) {\n      root.width = opts.width;\n    }\n\n    if (opts.height != null) {\n      root.height = opts.height;\n    } // Use canvas width and height directly\n\n\n    var width = root.width;\n    var height = root.height;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\n    var mainLayer = new Layer(root, this, 1);\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[0] = mainLayer;\n    zlevelList.push(0);\n    this._domRoot = root;\n  } // Layers for progressive rendering\n\n\n  this._progressiveLayers = [];\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n  this._hoverlayer;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} [paintAll=false] displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n\n    this._paintList(list, paintAll); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        layer.refresh();\n      }\n    }\n\n    this.refreshHover();\n\n    if (this._progressiveLayers.length) {\n      this._startProgessive();\n    }\n\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(1e5);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  _startProgessive: function () {\n    var self = this;\n\n    if (!self._furtherProgressive) {\n      return;\n    } // Use a token to stop progress steps triggered by\n    // previous zr.refresh calling.\n\n\n    var token = self._progressiveToken = +new Date();\n    self._progress++;\n    requestAnimationFrame(step);\n\n    function step() {\n      // In case refreshed or disposed\n      if (token === self._progressiveToken && self.storage) {\n        self._doPaintList(self.storage.getDisplayList());\n\n        if (self._furtherProgressive) {\n          self._progress++;\n          requestAnimationFrame(step);\n        } else {\n          self._progressiveToken = -1;\n        }\n      }\n    }\n  },\n  _clearProgressive: function () {\n    this._progressiveToken = -1;\n    this._progress = 0;\n    util.each(this._progressiveLayers, function (layer) {\n      layer.__dirty && layer.clear();\n    });\n  },\n  _paintList: function (list, paintAll) {\n    if (paintAll == null) {\n      paintAll = false;\n    }\n\n    this._updateLayerStatus(list);\n\n    this._clearProgressive();\n\n    this.eachBuiltinLayer(preProcessLayer);\n\n    this._doPaintList(list, paintAll);\n\n    this.eachBuiltinLayer(postProcessLayer);\n  },\n  _doPaintList: function (list, paintAll) {\n    var currentLayer;\n    var currentZLevel;\n    var ctx; // var invTransform = [];\n\n    var scope;\n    var progressiveLayerIdx = 0;\n    var currentProgressiveLayer;\n    var width = this._width;\n    var height = this._height;\n    var layerProgress;\n    var frame = this._progress;\n\n    function flushProgressiveLayer(layer) {\n      var dpr = ctx.dpr || 1;\n      ctx.save();\n      ctx.globalAlpha = 1;\n      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame\n\n      currentLayer.__dirty = true;\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n      ctx.restore();\n    }\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n      var elFrame = el.__frame; // Flush at current context\n      // PENDING\n\n      if (elFrame < 0 && currentProgressiveLayer) {\n        flushProgressiveLayer(currentProgressiveLayer);\n        currentProgressiveLayer = null;\n      } // Change draw layer\n\n\n      if (currentZLevel !== elZLevel) {\n        if (ctx) {\n          ctx.restore();\n        } // Reset scope\n\n\n        scope = {}; // Only 0 zlevel if only has one canvas\n\n        currentZLevel = elZLevel;\n        currentLayer = this.getLayer(currentZLevel);\n\n        if (!currentLayer.__builtin__) {\n          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);\n        }\n\n        ctx = currentLayer.ctx;\n        ctx.save(); // Reset the count\n\n        currentLayer.__unusedCount = 0;\n\n        if (currentLayer.__dirty || paintAll) {\n          currentLayer.clear();\n        }\n      }\n\n      if (!(currentLayer.__dirty || paintAll)) {\n        continue;\n      }\n\n      if (elFrame >= 0) {\n        // Progressive layer changed\n        if (!currentProgressiveLayer) {\n          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];\n          currentProgressiveLayer.ctx.save();\n          currentProgressiveLayer.renderScope = {};\n\n          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {\n            // flushProgressiveLayer(currentProgressiveLayer);\n            // Quick jump all progressive elements\n            // All progressive element are not dirty, jump over and flush directly\n            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;\n\n            continue;\n          }\n\n          layerProgress = currentProgressiveLayer.__progress;\n\n          if (!currentProgressiveLayer.__dirty) {\n            // Keep rendering\n            frame = layerProgress;\n          }\n\n          currentProgressiveLayer.__progress = frame + 1;\n        }\n\n        if (elFrame === frame) {\n          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n        }\n      } else {\n        this._doPaintEl(el, currentLayer, paintAll, scope);\n      }\n\n      el.__dirty = false;\n    }\n\n    if (currentProgressiveLayer) {\n      flushProgressiveLayer(currentProgressiveLayer);\n    } // Restore the lastLayer ctx\n\n\n    ctx && ctx.restore(); // If still has clipping state\n    // if (scope.prevElClipPaths) {\n    //     ctx.restore();\n    // }\n\n    this._furtherProgressive = false;\n    util.each(this._progressiveLayers, function (layer) {\n      if (layer.__maxProgress >= layer.__progress) {\n        this._furtherProgressive = true;\n      }\n    }, this);\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements\n\n      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (scope.prevElClipPaths) {\n          scope.prevClipLayer.ctx.restore();\n          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevClipLayer = currentLayer;\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   *  zlevel \n   * @param {number} zlevel\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel) {\n    if (this._singleCanvas) {\n      return this._layers[0];\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      log('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      log('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    var layers = this._layers;\n    var progressiveLayers = this._progressiveLayers;\n    var elCountsLastFrame = {};\n    var progressiveElCountsLastFrame = {};\n    this.eachBuiltinLayer(function (layer, z) {\n      elCountsLastFrame[z] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    util.each(progressiveLayers, function (layer, idx) {\n      progressiveElCountsLastFrame[idx] = layer.elCount;\n      layer.elCount = 0;\n      layer.__dirty = false;\n    });\n    var progressiveLayerCount = 0;\n    var currentProgressiveLayer;\n    var lastProgressiveKey;\n    var frameCount = 0;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var el = list[i];\n      var zlevel = this._singleCanvas ? 0 : el.zlevel;\n      var layer = layers[zlevel];\n      var elProgress = el.progressive;\n\n      if (layer) {\n        layer.elCount++;\n        layer.__dirty = layer.__dirty || el.__dirty;\n      } /////// Update progressive\n\n\n      if (elProgress >= 0) {\n        // Fix wrong progressive sequence problem.\n        if (lastProgressiveKey !== elProgress) {\n          lastProgressiveKey = elProgress;\n          frameCount++;\n        }\n\n        var elFrame = el.__frame = frameCount - 1;\n\n        if (!currentProgressiveLayer) {\n          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n          currentProgressiveLayer = progressiveLayers[idx];\n\n          if (!currentProgressiveLayer) {\n            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);\n            currentProgressiveLayer.initContext();\n          }\n\n          currentProgressiveLayer.__maxProgress = 0;\n        }\n\n        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n        currentProgressiveLayer.elCount++;\n        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);\n\n        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n          // Should keep rendering this  layer because progressive rendering is not finished yet\n          layer.__dirty = true;\n        }\n      } else {\n        el.__frame = -1;\n\n        if (currentProgressiveLayer) {\n          currentProgressiveLayer.__nextIdxNotProg = i;\n          progressiveLayerCount++;\n          currentProgressiveLayer = null;\n        }\n      }\n    }\n\n    if (currentProgressiveLayer) {\n      progressiveLayerCount++;\n      currentProgressiveLayer.__nextIdxNotProg = i;\n    } // \n\n\n    this.eachBuiltinLayer(function (layer, z) {\n      if (elCountsLastFrame[z] !== layer.elCount) {\n        layer.__dirty = true;\n      }\n    });\n    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n    util.each(progressiveLayers, function (layer, idx) {\n      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n        el.__dirty = true;\n      }\n\n      if (layer.__dirty) {\n        layer.__progress = 0;\n      }\n    });\n  },\n\n  /**\n   * hover\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n\n  /**\n   * zlevel\n   *\n   * @param {string} zlevel\n   * @param {Object} config \n   * @param {string} [config.clearColor=0] \n   * @param {string} [config.motionBlur=false] \n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 alpha\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      var layer = this._layers[zlevel];\n\n      if (layer) {\n        util.merge(layer, layerConfig[zlevel], true);\n      }\n    }\n  },\n\n  /**\n   * \n   * @param {number} zlevel zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * \n   */\n  resize: function (width, height) {\n    var domRoot = this._domRoot; // FIXME Why ?\n\n    domRoot.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    domRoot.style.display = ''; // resize\n\n    if (this._width != width || height != this._height) {\n      domRoot.style.width = width + 'px';\n      domRoot.style.height = height + 'px';\n\n      for (var id in this._layers) {\n        if (this._layers.hasOwnProperty(id)) {\n          this._layers[id].resize(width, height);\n        }\n      }\n\n      util.each(this._progressiveLayers, function (layer) {\n        layer.resize(width, height);\n      });\n      this.refresh(true);\n    }\n\n    this._width = width;\n    this._height = height;\n    return this;\n  },\n\n  /**\n   * \n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * \n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas) {\n      return this._layers[0].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clearColor = opts.backgroundColor;\n    imageLayer.clear();\n    var displayList = this.storage.getDisplayList(true);\n    var scope = {};\n    var zlevel;\n    var self = this;\n\n    function findAndDrawOtherLayer(smaller, larger) {\n      var zlevelList = self._zlevelList;\n\n      if (smaller == null) {\n        smaller = -Infinity;\n      }\n\n      var intermediateLayer;\n\n      for (var i = 0; i < zlevelList.length; i++) {\n        var z = zlevelList[i];\n        var layer = self._layers[z];\n\n        if (!layer.__builtin__ && z > smaller && z < larger) {\n          intermediateLayer = layer;\n          break;\n        }\n      }\n\n      if (intermediateLayer && intermediateLayer.renderToCanvas) {\n        imageLayer.ctx.save();\n        intermediateLayer.renderToCanvas(imageLayer.ctx);\n        imageLayer.ctx.restore();\n      }\n    }\n\n    for (var i = 0; i < displayList.length; i++) {\n      var el = displayList[i];\n\n      if (el.zlevel !== zlevel) {\n        findAndDrawOtherLayer(zlevel, el.zlevel);\n        zlevel = el.zlevel;\n      }\n\n      this._doPaintEl(el, imageLayer, true, scope);\n    }\n\n    findAndDrawOtherLayer(zlevel, Infinity);\n    return imageLayer.dom;\n  },\n\n  /**\n   * \n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * \n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur;\n    var shadowOffsetX = style.shadowOffsetX;\n    var shadowOffsetY = style.shadowOffsetY;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 971\n// module chunks = 1 2 3 141 142 143 144 145","var util = require(\"./core/util\");\n\nvar env = require(\"./core/env\");\n\nvar Group = require(\"./container/Group\");\n\nvar timsort = require(\"./core/timsort\");\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n *  (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * \n   * @param {boolean} [update=false] \n   * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n   *\n   * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * \n   * GroupShapeShape\n   * zlevel > z > \n   * @param {boolean} [includeIgnore=false]  ignore \n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {\n    //     displayList[i].__renderidx = i;\n    // }\n    // displayList.sort(shapeCompareFunc);\n\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME \n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath  clipPath \n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * (Shape)(Group)\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * (Shape)(Group)\n   * @param {string|Array.<string>} [el] Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // el\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    el.__storage = this;\n    el.dirty(false);\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 972\n// module chunks = 1 2 3 141 142 143 144 145","var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   *  clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   *  animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * \n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * \n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta);\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * \n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * \n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * \n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * animator\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] \n   * @param  {Function} [options.getter=null]\n   *         gettergetter\n   * @param  {Function} [options.setter=null]\n   *         settersetter\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 973\n// module chunks = 1 2 3 141 142 143 144 145","var easingFuncs = require(\"./easing\");\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // \n\n  this._life = options.life || 1000; // \n\n  this._delay = options.delay || 0; // \n  // this._startTime = new Date().getTime() + this._delay;// \n\n  this._initialized = false; // \n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // \n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // \n\n    if (percent == 1) {\n      if (this.loop) {\n        this.restart(globalTime); // \n        //  stage.update \n\n        return 'restart';\n      } // \n      // Animation.update\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 974\n// module chunks = 1 2 3 141 142 143 144 145","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // t^3\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // t^4\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // t^5\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // sin(t)\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 2^t\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // sqrt(1-t^2)\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // \n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 975\n// module chunks = 1 2 3 141 142 143 144 145","var _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * \n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 976\n// module chunks = 1 2 3 141 142 143 144 145","var curve = require(\"../core/curve\");\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 977\n// module chunks = 1 2 3 141 142 143 144 145","/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 978\n// module chunks = 1 2 3 141 142 143 144 145","var PathProxy = require(\"../core/PathProxy\");\n\nvar line = require(\"./line\");\n\nvar cubic = require(\"./cubic\");\n\nvar quadratic = require(\"./quadratic\");\n\nvar arc = require(\"./arc\");\n\nvar _util = require(\"./util\");\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = require(\"../core/curve\");\n\nvar windingLine = require(\"./windingLine\");\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // \n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_, y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema == 2) {\n        // \n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // \n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc \n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } //  subpath \n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i == 1) {\n      //  L, C, Q\n      //  previous point  point\n      //\n      //  Arc \n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo  subpath, \n        //  closePath \n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE  L, C, Q  NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc \n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc \n\n        var psi = data[i++];\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; //  arc \n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // \n          x0 = x1;\n          y0 = y1;\n        } // zr scale, x\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); //  subpath \n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 979\n// module chunks = 1 2 3 141 142 143 144 145","var windingLine = require(\"./windingLine\");\n\nvar EPSILON = 1e-8;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n}\n\nfunction contain(points, x, y) {\n  var w = 0;\n  var p = points[0];\n\n  if (!p) {\n    return false;\n  }\n\n  for (var i = 1; i < points.length; i++) {\n    var p2 = points[i];\n    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\n    p = p2;\n  } // Close polygon\n\n\n  var p0 = points[0];\n\n  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {\n    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\n  }\n\n  return w !== 0;\n}\n\nexports.contain = contain;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/polygon.js\n// module id = 980\n// module chunks = 1 2 3 141 142 143 144 145","var _curve = require(\"../core/curve\");\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 981\n// module chunks = 1 2 3 141 142 143 144 145","var eventUtil = require(\"./event\");\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 982\n// module chunks = 1 2 3 141 142 143 144 145","var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n\nvar GestureMgr = require(\"../core/GestureMgr\");\n\nvar TOUCH_CLICK_DELAY = 300;\nvar mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\nvar touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\nvar pointerEventNames = {\n  pointerdown: 1,\n  pointerup: 1,\n  pointermove: 1,\n  pointerout: 1\n};\nvar pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n  var nm = name.replace('mouse', 'pointer');\n  return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n  var gestureMgr = proxy._gestureMgr;\n  stage === 'start' && gestureMgr.clear();\n  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);\n  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n  if (gestureInfo) {\n    var type = gestureInfo.type;\n    event.gestureEvent = type;\n    proxy.handler.dispatchToElement({\n      target: gestureInfo.target\n    }, type, gestureInfo.event);\n  }\n} // function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\n\n\nfunction setTouchTimer(instance) {\n  instance._touching = true;\n  clearTimeout(instance._touchTimer);\n  instance._touchTimer = setTimeout(function () {\n    instance._touching = false;\n  }, 700);\n}\n\nvar domHandlers = {\n  /**\n   * Mouse move handler\n   * @inner\n   * @param {Event} event\n   */\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger('mousemove', event);\n  },\n\n  /**\n   * Mouse out handler\n   * @inner\n   * @param {Event} event\n   */\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var element = event.toElement || event.relatedTarget;\n\n    if (element != this.dom) {\n      while (element && element.nodeType != 9) {\n        // rootdommouseOut\n        if (element === this.dom) {\n          return;\n        }\n\n        element = element.parentNode;\n      }\n    }\n\n    this.trigger('mouseout', event);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    this._lastTouchMoment = new Date();\n    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should\n    // be triggered, and must before `mousedown` triggered.\n\n    domHandlers.mousemove.call(this, event);\n    domHandlers.mousedown.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    domHandlers.mousemove.call(this, event);\n    setTouchTimer(this);\n  },\n\n  /**\n   * Touch\n   * @inner\n   * @param {Event} event\n   */\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and\n    // mouse event in upper applicatoin.\n\n    event.zrByTouch = true;\n    processGesture(this, event, 'end');\n    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      domHandlers.click.call(this, event);\n    }\n\n    setTouchTimer(this);\n  },\n  pointerdown: function (event) {\n    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    domHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check domHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      domHandlers.mouseout.call(this, event);\n    }\n  }\n};\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// Common handlers\n\n\nzrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  domHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * dom \n *\n * @inner\n * @param {module:zrender/Handler} instance \n */\n\nfunction initDomHandler(instance) {\n  zrUtil.each(touchHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(pointerHandlerNames, function (name) {\n    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n  });\n  zrUtil.each(mouseHandlerNames, function (name) {\n    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n  });\n\n  function makeMouseHandler(fn, instance) {\n    return function () {\n      if (instance._touching) {\n        return;\n      }\n\n      return fn.apply(instance, arguments);\n    };\n  }\n}\n\nfunction HandlerDomProxy(dom) {\n  Eventful.call(this);\n  this.dom = dom;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._touching = false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._touchTimer;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr = new GestureMgr();\n  this._handlers = {};\n  initDomHandler(this);\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    mountHandlers(pointerHandlerNames, this); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    mountHandlers(mouseHandlerNames, this);\n  }\n\n  function mountHandlers(handlerNames, instance) {\n    zrUtil.each(handlerNames, function (name) {\n      addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n    }, instance);\n  }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n  for (var i = 0; i < handlerNames.length; i++) {\n    var name = handlerNames[i];\n    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style.cursor = cursorStyle || 'default';\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 983\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"./Path\");\n\n// CompoundPath to improve performance\nvar _default = Path.extend({\n  type: 'compound',\n  shape: {\n    paths: null\n  },\n  _updatePathDirty: function () {\n    var dirtyPath = this.__dirtyPath;\n    var paths = this.shape.paths;\n\n    for (var i = 0; i < paths.length; i++) {\n      // Mark as dirty if any subpath is dirty\n      dirtyPath = dirtyPath || paths[i].__dirtyPath;\n    }\n\n    this.__dirtyPath = dirtyPath;\n    this.__dirty = this.__dirty || dirtyPath;\n  },\n  beforeBrush: function () {\n    this._updatePathDirty();\n\n    var paths = this.shape.paths || [];\n    var scale = this.getGlobalScale(); // Update path scale\n\n    for (var i = 0; i < paths.length; i++) {\n      if (!paths[i].path) {\n        paths[i].createPathProxy();\n      }\n\n      paths[i].path.setScale(scale[0], scale[1]);\n    }\n  },\n  buildPath: function (ctx, shape) {\n    var paths = shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].buildPath(ctx, paths[i].shape, true);\n    }\n  },\n  afterBrush: function () {\n    var paths = this.shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].__dirtyPath = false;\n    }\n  },\n  getBoundingRect: function () {\n    this._updatePathDirty();\n\n    return Path.prototype.getBoundingRect.call(this);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 984\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 985\n// module chunks = 1 2 3 141 142 143 144 145","var zrUtil = require(\"../core/util\");\n\nvar Gradient = require(\"./Gradient\");\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 986\n// module chunks = 1 2 3 141 142 143 144 145","var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"./helper/text\");\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Always bind style\n\n    style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 987\n// module chunks = 1 2 3 141 142 143 144 145","var _vector = require(\"../../core/vector\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * \n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points \n * @param {number} smooth , 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint \n *                            [[0, 0], [100, 100]], \n *                           \n * @param {Array} \n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min, max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // \n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 988\n// module chunks = 1 2 3 141 142 143 144 145","var _vector = require(\"../../core/vector\");\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points \n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 989\n// module chunks = 1 2 3 141 142 143 144 145","var textHelper = require(\"../helper/text\");\n\nvar BoundingRect = require(\"../../core/BoundingRect\");\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 990\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 991\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\nvar vec2 = require(\"../../core/vector\");\n\nvar _curve = require(\"../../core/curve\");\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 992\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 993\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 994\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * \n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 995\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\nvar polyHelper = require(\"../helper/poly\");\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 996\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\nvar roundRectHelper = require(\"../helper/roundRect\");\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // r1r2r3r4\n    // r1          [1, 1, 1, 1]\n    // r[1]        [1, 1, 1, 1]\n    // r[1, 2]     [1, 2, 1, 2]\n    // r[1, 2, 3]  [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 997\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 998\n// module chunks = 1 2 3 141 142 143 144 145","var Path = require(\"../Path\");\n\nvar fixClipWithShadow = require(\"../helper/fixClipWithShadow\");\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 999\n// module chunks = 1 2 3 141 142 143 144 145"],"sourceRoot":""}